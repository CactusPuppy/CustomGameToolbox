import "../main.ostw";
import "./menuDefinitions.ostw";
import "../utils/2DArray.ostw";

import "gameControl/gameControlMenu.ostw";
import "cheats/cheatsMenu.ostw";
import "tools/toolsMenu.ostw";


rule: "[Menu] Set up action grid" -100
{
  ButtonActionGrid = [];
  ButtonActionGrid[MenuState.MAIN_MENU] = mainMenuButtonActions;
  ButtonActionGrid[MenuState.GAME_CONTROL] = gameControlButtonActions;
  ButtonActionGrid[MenuState.CONFIRMING_END_GAME] = [true, true];
  ButtonActionGrid[MenuState.CHEATS] = cheatButtonActions;
  ButtonActionGrid[MenuState.TOOLS] = toolsMenuButtonActions;
}
rule: "[Menu] Set up button label grid" -100
Event.OngoingPlayer
{
  ButtonLabelGrid = [];
  ButtonLabelGrid[MenuState.MAIN_MENU] = mainMenuButtonLabels;
  ButtonLabelGrid[MenuState.GAME_CONTROL] = gameControlButtonLabels;
  ButtonLabelGrid[MenuState.CHEATS] = cheatButtonLabels;
  ButtonLabelGrid[MenuState.TOOLS] = toolsMenuButtonLabels;
}
rule: "[Menu] Set up color grid" -100
Event.OngoingPlayer
{
  ButtonColorGrid = [];
  ButtonColorGrid[MenuState.MAIN_MENU] = mainMenuButtonColors;
  ButtonColorGrid[MenuState.GAME_CONTROL] = gameControlButtonColors;
  ButtonColorGrid[MenuState.CHEATS] = cheatButtonColors;
  ButtonColorGrid[MenuState.TOOLS] = toolsMenuButtonColors;
}

MenuState[] mainMenuButtonActions: [
  MenuState.CLOSED, MenuState.INFORMATION, MenuState.CLOSED, MenuState.MODIFICATIONS,         MenuState.CLOSED,
  MenuState.CLOSED, MenuState.CLOSED,      MenuState.CLOSED, MenuState.CLOSED,                MenuState.CLOSED,
  MenuState.CLOSED, MenuState.CLOSED,      MenuState.CLOSED, MenuState.CLOSED,                MenuState.CLOSED,
  MenuState.CLOSED, MenuState.TOOLS,       MenuState.CLOSED, MenuState.DUMMY_BOTS_AND_REPLAY, MenuState.CLOSED
];
String[] mainMenuButtonLabels: [
  "", "Information", "", "Modifications",     "",
  "", "",            "", "",                  "",
  "", "",            "", "",                  "",
  "", "Tools",       "", "Dummy Bots/Replay", ""
];
Color[] mainMenuButtonColors: [
  null, Color.White,  null, Color.White, null,
  null, null,         null, null,        null,
  null, null,         null, null,        null,
  null, Color.White,  null, Color.White, null
];

rule: "Global menu setup"
{
  # Create prompt to open mneu
  CreateHudText(
    VisibleTo:     (!LocalPlayer().hideMenuOpenTooltip || (LocalPlayer().currentMenuState != MenuState.CLOSED)) ? LocalPlayer() : null,
    Text:          <"Hold [<0> + <1>] to <2> menu",
                      InputBindingString(Button.Crouch),
                      InputBindingString(Button.Interact),
                      LocalPlayer().currentMenuState == MenuState.CLOSED ? "open" : "close">,
    Location:      Location.Top,
    SortOrder:     1,
    TextColor:     LocalPlayer().currentMenuState == MenuState.CLOSED ? Color.Green : Color.Red,
    Reevaluation:  HudTextRev.VisibleToStringAndColor,
    Spectators:    Spectators.VisibleNever);
  # Create controls hint
  OnScreenText.CreateOnScreenText(
    VisibleTo:     LocalPlayer().currentMenuState != MenuState.CLOSED ? LocalPlayer() : null,
    Header:          "{0} SELECT  |  {2} {1}".Format([InputBindingString(Button.PrimaryFire), InputBindingString(Button.SecondaryFire), LocalPlayer().currentMenuState == MenuState.MAIN_MENU ? "CLOSE" : "BACK"]),
    PositionX:     0,
    PositionY:     -1.5,
    Scale:         2,
    Color:         Color.White,
    Reevaluation:  InworldTextRev.VisibleToPositionAndString,
    Spectators:    Spectators.VisibleNever);
  # DEBUG: grid params
  printMenuValues();
  // # Create grid menu items
  for (Number colIndex = 0; colIndex < numCols; colIndex++) {
    for (Number rowIndex = 0; rowIndex < numRows; rowIndex++) {
      menuButton(EvaluateOnce(colIndex), EvaluateOnce(rowIndex));
    }
  }
  CreateEndGameConfirmationScreen();

  # DEBUG: Show current menu state and current x/y menu indexes
  CreateHudText(
    VisibleTo: LocalPlayer(),
    Text: $"shape: {numCols}, {numRows} | x: {LocalPlayer().menuXIndex} | y: {LocalPlayer().menuYIndex} | val: {currentActionGrid(LocalPlayer())[gridIndex(LocalPlayer().menuXIndex, LocalPlayer().menuYIndex)]}",
    Reevaluation: HudTextRev.VisibleToAndString
  );
}

rule: "When player first opens menu, hide tooltip when menu is closed"
Event.OngoingPlayer
if (!hideMenuOpenTooltip)
if (currentMenuState != MenuState.CLOSED)
{
  hideMenuOpenTooltip = true;
}

rule: "Initialize player and perform cleanup"
Event.OngoingPlayer
if (currentMenuState != MenuState.CLOSED)
{
  // cursor = new Cursor();
  SetAimSpeed(EventPlayer(), 0);
  StartFacing(EventPlayer(), FacingDirectionOf(EventPlayer()), 1000, Relative.ToWorld, FacingRev.None);
  StartForcingPlayerPosition(EventPlayer(), PositionOf(EventPlayer()), false);
  SetGravity(EventPlayer(), 0);
  DisallowButton(Button: Button.PrimaryFire);
  DisallowButton(Button: Button.SecondaryFire);
  DisallowButton(Button: Button.Ability1);
  DisallowButton(Button: Button.Ability2);
  DisallowButton(Button: Button.Ultimate);
  DisallowButton(Button: Button.Crouch);
  DisallowButton(Button: Button.Jump);
  DisallowButton(Button: Button.Reload);
  SetInvisible(EventPlayer(), InvisibleTo.All);
  SetStatus(EventPlayer(), null, Status.PhasedOut, 1000000);
  DisableKillFeed();
  DisableGameModeInworldUI();
  DisableGameModeHud();
  DisableHeroHud();
  StartCamera(EventPlayer(), EyePosition(), EyePosition() + FacingDirectionOf(), 100);

  menuXIndex = 0; menuYIndex = 0;

  WaitUntil(currentMenuState == MenuState.CLOSED, 9999);

  StopCamera();
  EnableKillFeed();
  EnableGameModeInworldUI();
  EnableGameModeHud();
  EnableHeroHud();
  StopFacing(EventPlayer());
  StopForcingPlayerPosition();
  SetGravity(EventPlayer(), 100);
  SetAimSpeed(EventPlayer(), 100);
  # Give a leniency period for buttons to be let go of
  Wait(0.25, WaitBehavior.RestartWhenTrue);
  AllowButton(Button: Button.PrimaryFire);
  AllowButton(Button: Button.SecondaryFire);
  AllowButton(Button: Button.Ability1);
  AllowButton(Button: Button.Ability2);
  AllowButton(Button: Button.Ultimate);
  AllowButton(Button: Button.Crouch);
  AllowButton(Button: Button.Jump);
  AllowButton(Button: Button.Reload);
  SetInvisible(EventPlayer(), InvisibleTo.None);
  ClearStatus(EventPlayer(), Status.PhasedOut);
}

rule: "When player holds Crouch + Interact long enough, toggle menu"
Event.OngoingPlayer
if (IsAlive())
if (IsButtonHeld(EventPlayer(), Button.Crouch))
if (IsButtonHeld(EventPlayer(), Button.Interact))
{
  Wait(0.25, WaitBehavior.AbortWhenFalse);
  if (currentMenuState == MenuState.CLOSED) {
    currentMenuState = MenuState.MAIN_MENU;
  } else {
    currentMenuState = MenuState.CLOSED;
  }
}

rule: "Primary fire to select current item"
Event.OngoingPlayer
if (IsButtonHeld(EventPlayer(), Button.PrimaryFire))
{
  AbortIf(currentMenuState == MenuState.CLOSED);
  AbortIf(currentActionItem() == 0);
  switch (currentMenuState) {
    case MenuState.MAIN_MENU:
      HandleMainMenuClick();
      break;
    case MenuState.GAME_CONTROL:
      HandleGameControlClick();
      break;
    case MenuState.CONFIRMING_END_GAME:
      HandleConfirmEndGameClick();
      break;
    case MenuState.CHEATS:
      HandleCheatClick();
      break;
    case MenuState.TOOLS:
      HandleToolsMenuClick();
      break;
  }
}

rule: "Secondary fire to go back"
Event.OngoingPlayer
if (IsButtonHeld(EventPlayer(), Button.SecondaryFire))
{
  AbortIf(currentMenuState == MenuState.CLOSED);
  if (currentMenuState == MenuState.MAIN_MENU) {
    currentMenuState = MenuState.CLOSED;
    return;
  }
  if (ArrayContains([MenuState.INFORMATION, MenuState.MODIFICATIONS, MenuState.TOOLS,
      MenuState.DUMMY_BOTS_AND_REPLAY], currentMenuState)) {
    currentMenuState = MenuState.MAIN_MENU;
  }
  if (currentMenuState == MenuState.CONFIRMING_END_GAME) {
    currentMenuState = MenuState.GAME_CONTROL;
  }
}

rule: "Menu left-right"
Event.OngoingPlayer
if (currentMenuState != MenuState.CLOSED)
if (AbsoluteValue(XOf(ThrottleOf(EventPlayer()))) > 0.5)
{
  cache_startIndex1 = menuXIndex;
  if (XOf(ThrottleOf(EventPlayer())) > 0) {
    findLeft();
  } else {
    findRight();
  }
}

rule: "Menu up-down"
Event.OngoingPlayer
if (currentMenuState != MenuState.CLOSED)
if (AbsoluteValue(ZOf(ThrottleOf())) > 0.5) {
  cache_startIndex1 = menuYIndex;
  if (ZOf(ThrottleOf()) > 0) {
    findUp();
  } else {
    findDown();
  }
}

MenuState[] NO_AUTO_SET_INDICES_MENUS: [MenuState.CONFIRMING_END_GAME];
rule: "When menu state changes, find new first selection" -1
Event.OngoingPlayer
if (currentMenuState != MenuState.CLOSED)
{
  MinWait();
  // # DEBUG
  // SmallMessage(AllPlayers(), $"Current action grid element count: {CountOf(currentActionGrid())}");
  if (currentActionGrid() != 0 && !ArrayContains(NO_AUTO_SET_INDICES_MENUS, currentMenuState)) {
    // # DEBUG
    // SmallMessage(AllPlayers(), "Entering autoset");
    AutoSetMenuIndices();
  }
  WaitUntil(currentMenuState != EvaluateOnce(currentMenuState), 1000000);
  LoopIfConditionIsTrue();
}

void AutoSetMenuIndices() {
  menuXIndex = 0; menuYIndex = 0;
  while (menuYIndex < numRows) {
    while (menuXIndex < numCols) {
      if (currentActionItem() != 0) {
        return;
      }
      menuXIndex = menuXIndex + 1;
    }
    menuYIndex = menuYIndex + 1;
    menuXIndex = 0;
  }
}

void HandleMainMenuClick() {
  currentMenuState = mainMenuActionGrid[currentGridIndex()];
}
