import "../main.ostw";
import "../OSTWUtils/OnScreenText.del";
import "../OSTWUtils/Math.del";

import "gameControl/gameControlMenu.ostw";
import "cheats/cheatsMenu.ostw";

enum MenuState
{
  CLOSED = 0,
  MAIN_MENU,
  REPLAY_BOTS,
  SET_CAMERA,
  SET_RESPAWN,
  CHEATS,
  GAME_CONTROL,
  CONFIRMING_END_GAME,
  CUSTOMIZE_HUD
}

globalvar Any[][] ActionGrid;
rule: "[Menu] Set up action grid" -100
{
  ActionGrid = [];
  ActionGrid[MenuState.MAIN_MENU] = mainMenuActions;
  ActionGrid[MenuState.GAME_CONTROL] = gameControlActions;
  ActionGrid[MenuState.CONFIRMING_END_GAME] = [true, true];
  ActionGrid[MenuState.CHEATS] = cheatActions;
}
// Index is rowIndex * numCols + colIndex
MenuState[] mainMenuActionGrid: ActionGrid[MenuState.MAIN_MENU];

playervar MenuState currentMenuState = MenuState.CLOSED;
// playervar Cursor | Number cursor = -1;
playervar Number menuXIndex; // Positive to the right
playervar Number menuYIndex; // Positive downwards
playervar Boolean hideMenuOpenTooltip;

MenuState[] mainMenuActions: [
  MenuState.CHEATS, MenuState.CLOSED, MenuState.CLOSED, MenuState.CLOSED,
  MenuState.CLOSED, MenuState.CLOSED, MenuState.CLOSED, MenuState.CLOSED,
  MenuState.CLOSED, MenuState.CLOSED, MenuState.CLOSED, MenuState.CLOSED,
  MenuState.CLOSED, MenuState.CLOSED, MenuState.CLOSED, MenuState.GAME_CONTROL
];

Number xLim: 2.5;
Number yLim: 1.25;
Number firstRowY: 1;
Number rowSeparation: 0.5;
Number firstColumnX: -2.0;
Number columnSeparation: 1.0;
Number rowIndexToY(Number rowIndex): firstRowY - (rowSeparation * rowIndex);
Number colIndexToX(Number colIndex): firstColumnX + (columnSeparation * colIndex);
Number numCols: RoundToInteger((xLim - firstColumnX) / columnSeparation, Rounding.Down); // 4
Number numRows: RoundToInteger((firstRowY + yLim) / rowSeparation, Rounding.Down); // 4
Number gridIndex(Number colIndex, Number rowIndex): rowIndex * numCols + colIndex;
Boolean isSelectingButton(Player p = LocalPlayer(), Number colIndex = 0, Number rowIndex = 0): p.menuXIndex == colIndex && p.menuYIndex == rowIndex;
Any[] currentActionGrid(Player p = EventPlayer()): ActionGrid[p.currentMenuState];
Number currentGridIndex(Player p = EventPlayer()): gridIndex(p.menuXIndex, p.menuYIndex);
Any currentActionItem(Player p = EventPlayer()): currentActionGrid(p)[currentGridIndex(p)];

String menuText(String label, Boolean isSelected = false): isSelected ? <"><0><1><0><", SineFromDegrees((TotalTimeElapsed() * 360) % 360) > 0.2 ? "   " : " ", label> : label;
Boolean isSelectingGridIndex(Player p = EventPlayer(), Number x = 0, Number y = 0): p.menuXIndex == x && p.menuYIndex == y;

Any menuButton(String label, Number colIndex, Number rowIndex, MenuState parentMenu,
                   Color color = Color.White,Number scale = 2):
  OnScreenText.CreateOnScreenText(
    VisibleTo: LocalPlayer().currentMenuState == parentMenu ? LocalPlayer() : null,
    Header: menuText(label, isSelectingGridIndex(LocalPlayer(), x: colIndex, y: rowIndex)),
    PositionX: colIndexToX(colIndex),
    PositionY: rowIndexToY(rowIndex),
    Scale: scale,
    Reevaluation: InworldTextRev.VisibleToPositionAndString,
    Color: color,
    Spectators: Spectators.VisibleNever
  );

Any menuButtonDynamicColor(String label, Number colIndex, Number rowIndex, MenuState parentMenu,
                   Color color = Color.White,Number scale = 2):
  OnScreenText.CreateOnScreenText(
    VisibleTo: LocalPlayer().currentMenuState == parentMenu ? LocalPlayer() : null,
    Header: menuText(label, isSelectingGridIndex(LocalPlayer(), x: colIndex, y: rowIndex)),
    PositionX: colIndexToX(colIndex),
    PositionY: rowIndexToY(rowIndex),
    Scale: scale,
    Reevaluation: InworldTextRev.VisibleToPositionStringAndColor,
    Color: color,
    Spectators: Spectators.VisibleNever
  );

void CreateMainMenuButtons() {
  # Game control button
  OnScreenText.CreateOnScreenText(
    VisibleTo:     LocalPlayer().currentMenuState == MenuState.MAIN_MENU ? LocalPlayer() : null,
    Header:        menuText("Game Control", isSelectingGridIndex(LocalPlayer(), x: 3, y: 3)),
    PositionX:     colIndexToX(3),
    PositionY:     rowIndexToY(3),
    Scale:         2,
    Reevaluation:  InworldTextRev.VisibleToPositionAndString,
    Color:         Color.Rose,
    Spectators:    Spectators.VisibleNever);
}

rule: "Global menu setup"
{
  # Create prompt to open mneu
  CreateHudText(
    VisibleTo:     (!LocalPlayer().hideMenuOpenTooltip || (LocalPlayer().currentMenuState != MenuState.CLOSED)) ? LocalPlayer() : null,
    Text:          <"Hold [<0> + <1>] to <2> menu",
                      InputBindingString(Button.Crouch),
                      InputBindingString(Button.Interact),
                      LocalPlayer().currentMenuState == MenuState.CLOSED ? "open" : "close">,
    Location:      Location.Top,
    SortOrder:     1,
    TextColor:     LocalPlayer().currentMenuState == MenuState.CLOSED ? Color.Green : Color.Red,
    Reevaluation:  HudTextRev.VisibleToStringAndColor,
    Spectators:    Spectators.VisibleNever);
  # Create controls hint
  OnScreenText.CreateOnScreenText(
    VisibleTo:     LocalPlayer().currentMenuState != MenuState.CLOSED ? LocalPlayer() : null,
    Header:          "{0} SELECT  |  {2} {1}".Format([InputBindingString(Button.PrimaryFire), InputBindingString(Button.SecondaryFire), LocalPlayer().currentMenuState == MenuState.MAIN_MENU ? "CLOSE" : "BACK"]),
    PositionX:     0,
    PositionY:     -1.5,
    Scale:         2,
    Color:         Color.White,
    Reevaluation:  InworldTextRev.VisibleToPositionAndString,
    Spectators:    Spectators.VisibleNever);

  CreateMainMenuButtons();
  CreateGameControlButtons();
  CreateCheatButtons();

  # DEBUG: Show current menu state and current x/y menu indexes
  CreateHudText(
    VisibleTo: LocalPlayer(),
    Text: $"currMenu: {LocalPlayer().currentMenuState} | x: {LocalPlayer().menuXIndex} | y: {LocalPlayer().menuYIndex} | val: {currentActionGrid(LocalPlayer())[gridIndex(LocalPlayer().menuXIndex, LocalPlayer().menuYIndex)]}",
    Reevaluation: HudTextRev.VisibleToAndString
  );
}

rule: "When player first opens menu, hide tooltip when menu is closed"
Event.OngoingPlayer
if (!hideMenuOpenTooltip)
if (currentMenuState != MenuState.CLOSED)
{
  hideMenuOpenTooltip = true;
}

rule: "Initialize player and perform cleanup"
Event.OngoingPlayer
if (currentMenuState != MenuState.CLOSED)
{
  // cursor = new Cursor();
  SetAimSpeed(EventPlayer(), 0);
  StartFacing(EventPlayer(), FacingDirectionOf(EventPlayer()), 1000, Relative.ToWorld, FacingRev.None);
  StartForcingPlayerPosition(EventPlayer(), PositionOf(EventPlayer()), false);
  SetGravity(EventPlayer(), 0);
  DisallowButton(Button: Button.PrimaryFire);
  DisallowButton(Button: Button.SecondaryFire);
  DisallowButton(Button: Button.Ability1);
  DisallowButton(Button: Button.Ability2);
  DisallowButton(Button: Button.Ultimate);
  DisallowButton(Button: Button.Crouch);
  DisallowButton(Button: Button.Jump);
  DisallowButton(Button: Button.Reload);
  SetInvisible(EventPlayer(), InvisibleTo.All);
  SetStatus(EventPlayer(), null, Status.PhasedOut, 1000000);
  DisableGameModeHud();
  DisableHeroHud();
  StartCamera(EventPlayer(), EyePosition(), EyePosition() + FacingDirectionOf(), 100);

  menuXIndex = 0; menuYIndex = 0;

  WaitUntil(currentMenuState == MenuState.CLOSED, 9999);

  StopCamera();
  EnableGameModeHud();
  EnableHeroHud();
  StopFacing(EventPlayer());
  StopForcingPlayerPosition();
  SetGravity(EventPlayer(), 100);
  SetAimSpeed(EventPlayer(), 100);
  # Give a leniency period for buttons to be let go of
  Wait(0.25, WaitBehavior.RestartWhenTrue);
  AllowButton(Button: Button.PrimaryFire);
  AllowButton(Button: Button.SecondaryFire);
  AllowButton(Button: Button.Ability1);
  AllowButton(Button: Button.Ability2);
  AllowButton(Button: Button.Ultimate);
  AllowButton(Button: Button.Crouch);
  AllowButton(Button: Button.Jump);
  AllowButton(Button: Button.Reload);
  SetInvisible(EventPlayer(), InvisibleTo.None);
  ClearStatus(EventPlayer(), Status.PhasedOut);
}

rule: "When player holds Crouch + Interact long enough, toggle menu"
Event.OngoingPlayer
if (IsAlive())
if (IsButtonHeld(EventPlayer(), Button.Crouch))
if (IsButtonHeld(EventPlayer(), Button.Interact))
{
  Wait(0.25, WaitBehavior.AbortWhenFalse);
  if (currentMenuState == MenuState.CLOSED) {
    currentMenuState = MenuState.MAIN_MENU;
    # DEBUG: Show text count
    SmallMessage(EventPlayer(), "Text Count: {0}".Format([TextCount()]));
  } else {
    currentMenuState = MenuState.CLOSED;
  }
}

rule: "Primary fire to select current item"
Event.OngoingPlayer
if (IsButtonHeld(EventPlayer(), Button.PrimaryFire))
{
  AbortIf(currentMenuState == MenuState.CLOSED);
  AbortIf(currentActionItem() == 0);
  switch (currentMenuState) {
    case MenuState.MAIN_MENU:
      HandleMainMenuClick();
      break;
    case MenuState.GAME_CONTROL:
      HandleGameControlClick();
      break;
    case MenuState.CONFIRMING_END_GAME:
      HandleConfirmEndGameClick();
      break;
    case MenuState.CHEATS:
      HandleCheatClick();
      break;
  }
}

rule: "Secondary fire to go back"
Event.OngoingPlayer
if (IsButtonHeld(EventPlayer(), Button.SecondaryFire))
{
  AbortIf(currentMenuState == MenuState.CLOSED);
  if (currentMenuState == MenuState.MAIN_MENU) {
    currentMenuState = MenuState.CLOSED;
    return;
  }
  if (ArrayContains([MenuState.REPLAY_BOTS, MenuState.SET_CAMERA, MenuState.SET_RESPAWN,
      MenuState.CHEATS, MenuState.GAME_CONTROL, MenuState.CUSTOMIZE_HUD], currentMenuState)) {
    currentMenuState = MenuState.MAIN_MENU;
  }
  if (currentMenuState == MenuState.CONFIRMING_END_GAME) {
    currentMenuState = MenuState.GAME_CONTROL;
  }
}

playervar Number cache_startIndex1;
playervar Number cache_startIndex2;
rule: "Menu left-right"
Event.OngoingPlayer
if (currentMenuState != MenuState.CLOSED)
if (AbsoluteValue(XOf(ThrottleOf(EventPlayer()))) > 0.5)
{
  cache_startIndex1 = menuXIndex;
  if (XOf(ThrottleOf(EventPlayer())) > 0) {
    findLeft();
  } else {
    findRight();
  }
}

rule: "Menu up-down"
Event.OngoingPlayer
if (currentMenuState != MenuState.CLOSED)
if (AbsoluteValue(ZOf(ThrottleOf())) > 0.5) {
  cache_startIndex1 = menuYIndex;
  if (ZOf(ThrottleOf()) > 0) {
    findUp();
  } else {
    findDown();
  }
}

/* NOTE: The following subroutines expect `cache_startIndex1` to be set PRIOR TO CALL.
 * These subroutines CAN infinitely loop if the menu is somehow in a bad state
 * (i.e. somehow selecting a blank button).
 */
void findLeft() playervar "[SUB] Find first item to the left" {
  menuXIndex--;
  if (menuXIndex < 0) menuXIndex = numCols - 1;
  AbortIf(currentActionItem() != 0);
  cache_startIndex2 = menuYIndex;
  moveSelectionDown();
  // LogToInspector($"step: post-scan: {menuXIndex}, {menuYIndex} | {currentActionItem()}");

  LoopIf(cache_startIndex1 != menuXIndex && currentActionItem() == 0);
}

void findRight() playervar "[SUB] Find first item to the right" {
  menuXIndex++;
  if (menuXIndex >= numCols) menuXIndex = 0;
  AbortIf(currentActionItem() != 0);
  cache_startIndex2 = menuYIndex;
  moveSelectionUp();
  // LogToInspector($"step: post-scan: {menuXIndex}, {menuYIndex} | {currentActionItem()}");

  LoopIf(cache_startIndex1 != menuXIndex && currentActionItem() == 0);
}

void findUp() playervar "[SUB] Find first item upwards" {
  menuYIndex--;
  if (menuYIndex < 0) menuYIndex = numRows - 1;
  AbortIf(currentActionItem() != 0);
  cache_startIndex2 = menuXIndex;
  moveSelectionLeft();
  // LogToInspector($"step: post-scan: {menuXIndex}, {menuYIndex} | {currentActionItem()}");
  LoopIf(cache_startIndex1 != menuYIndex && currentActionItem() == 0);
}

void findDown() playervar "[SUB] Find first item downwards" {
  menuYIndex++;
  if (menuYIndex >= numRows) menuYIndex = 0;
  AbortIf(currentActionItem() != 0);
  cache_startIndex2 = menuXIndex;
  moveSelectionRight();
  // LogToInspector($"step: post-scan: {menuXIndex}, {menuYIndex} | {currentActionItem()}");
  LoopIf(cache_startIndex1 != menuYIndex && currentActionItem() == 0);
}

/* NOTE: These subroutines expect `cache_startIndex2` to be set PRIOR TO CALL.
 * These subroutines CAN infinitely loop if the menu is somehow in a bad state
 * (i.e. somehow selecting a blank button).
 */
void moveSelectionLeft() playervar "[SUB] Move selection left"
{
  menuXIndex--;
  if (menuXIndex < 0) { menuXIndex = numCols - 1; }
  // LogToInspector($"  sub (left): {menuXIndex}, {menuYIndex} | {currentActionItem()}");
  LoopIf(cache_startIndex2 != menuXIndex && currentActionItem() == 0);
}

void moveSelectionRight() playervar "[SUB] Move selection right"
{
  menuXIndex++;
  if (menuXIndex >= numCols) { menuXIndex = 0; }
  // LogToInspector($"  sub (right): {menuXIndex}, {menuYIndex} | {currentActionItem()}");
  LoopIf(cache_startIndex2 != menuXIndex && currentActionItem() == 0);
}

void moveSelectionUp() playervar "[SUB] Move selection up"
{
  menuYIndex--;
  if (menuYIndex < 0) { menuYIndex = numRows - 1; }
  // LogToInspector($"  sub (up): {menuXIndex}, {menuYIndex} | {currentActionItem()}");
  LoopIf(cache_startIndex2 != menuYIndex && currentActionItem() == 0);
}

void moveSelectionDown() playervar "[SUB] Move selection down"
{
  menuYIndex++;
  if (menuYIndex >= numRows) { menuYIndex = 0; }
  // LogToInspector($"  sub (down): {menuXIndex}, {menuYIndex} | {currentActionItem()}");
  LoopIf(cache_startIndex2 != menuYIndex && currentActionItem() == 0);
}

MenuState[] NO_AUTO_SET_INDICES_MENUS: [MenuState.CONFIRMING_END_GAME];
rule: "When menu state changes, find new first selection" -1
Event.OngoingPlayer
if (currentMenuState != MenuState.CLOSED)
{
  MinWait();
  // # DEBUG
  // SmallMessage(AllPlayers(), $"Current action grid element count: {CountOf(currentActionGrid())}");
  if (currentActionGrid() != 0 && !ArrayContains(NO_AUTO_SET_INDICES_MENUS, currentMenuState)) {
    // # DEBUG
    // SmallMessage(AllPlayers(), "Entering autoset");
    AutoSetMenuIndices();
  }
  WaitUntil(currentMenuState != EvaluateOnce(currentMenuState), 1000000);
  LoopIfConditionIsTrue();
}

void AutoSetMenuIndices() {
  menuXIndex = 0; menuYIndex = 0;
  while (menuYIndex < numRows) {
    while (menuXIndex < numCols) {
      if (currentActionItem() != 0) {
        return;
      }
      menuXIndex = menuXIndex + 1;
    }
    menuYIndex = menuYIndex + 1;
    menuXIndex = 0;
  }
}

void HandleMainMenuClick() {
  currentMenuState = mainMenuActionGrid[currentGridIndex()];
}
