settings
{
	main
	{
		Description: "CactusPuppy's Toolbox | v2.0.0\r\nCode: OVVVC\r\n\r\nA set of tools that make custom games more useful for recreating, testing, and recording Overwatch scenarios."
		Mode Name: "CactusPuppy's Toolbox"
	}

	lobby
	{
		Match Voice Chat: Enabled
	}

	modes
	{
		Clash

		Control

		Escort

		Flashpoint

		Hybrid

		Push

		General
		{
			Competitive Rules: On
			Game Mode Start: Manual
			Limit Roles: 1 Tank 2 Offense 2 Support
			Tank Role Passive Health Bonus: Disabled
		}
	}
}

variables
{
	global:
		4: i
		5: _extendedGlobalCollection
		6: UseRoleQueueHealth
		7: ButtonActionGrid
		8: logBuffer
		9: AllButtons
		10: isTimePaused
		13: OptimizeMetricsForOverTime
		14: MetricsUpdatePeriod
		15: activeModifications
		16: AUTO_REGEN_DELAY
		17: SLOW_MOTION_SPEED
		18: punchingBagTargetHealthProportio
		19: nextSelectionEntityId
		20: uniqueHeroSkinCombosRemaining
		21: rainbowVector
		22: BUTTON_SPAM_PERIOD
		23: allBotsReplayDuringRecording
		24: SHOULD_LOOP_CLIP
		25: RECORD_IN_SLOW_MOTION
		26: SHOW_REPLAY_TIMECODES
		27: interactDestroysDeployableCompen
		28: QuickActions
		29: ActionSettings
		30: _watch_triggers
		31: TRIGGERS_ENABLED
		32: colIndex
		33: rowIndex
		34: player
		35: button
		36: _arrayConstructor
		37: t
		38: func_group

	player:
		0: TankHealthPool
		1: menuActivationPoint
		2: ButtonLabelGrid
		3: ButtonColorGrid
		4: currentMenuState
		5: menuXIndex
		6: tempMenuXIndex
		7: menuYIndex
		8: tempMenuYIndex
		9: hideMenuOpenTooltip
		10: _extendedPlayerCollection
		11: buttonLocks
		12: toolsActionID
		13: actionToConfirm
		14: confirmationState
		15: position1
		16: isMovingPosition1
		17: position2
		18: isMovingPosition2
		19: playerRulerState
		20: rulerEffects
		21: thirdPersonState
		22: baseFacingDirection
		23: thirdPersonHeight
		24: thirdPersonDistance
		25: thirdPersonPosAngle
		26: thirdPersonFacPolar
		27: thirdPersonFacAzim
		28: isNoClipActive
		29: invisibilityLockCount
		30: phasedOutLockCount
		31: activeInfoDisplays
		32: infoDisplayEntities
		33: healingReceivedEvents
		34: healReceivedInPeriod
		35: healReceivedInPeriodNonSelf
		36: healingDealtEvents
		37: healDealtInPeriod
		38: healDealtInPeriodNonSelf
		39: structArraysStartIndex
		40: structArraysCount
		41: sweepNewlyValidEventsIndex
		42: oldTimeAcceptanceThreshold
		43: eventTimestamp
		44: damageReceivedEvents
		45: damageReceivedInPeriod
		46: damageReceivedInPeriodNonSelf
		47: damageDealtEvents
		48: damageDealtInPeriod
		49: damageDealtInPeriodNonSelf
		50: effectStartTimestamp
		52: effectDuration
		53: totalDamageDisplayTextID
		54: lastDamageDisplayTextID
		55: totalDamage
		56: lastDamageInstanceAmount
		57: lastDamageInstancePosition
		58: totalHealingDisplayTextID
		59: lastHealingDisplayTextID
		60: totalHealing
		61: lastHealInstanceAmount
		62: lastHealInstancePosition
		63: selectedBotsReplayAction
		64: selectedControl
		65: selectionSetDistance
		66: selectedBot
		67: selectedBots
		68: positionControl
		69: facingControl
		70: botControlMode
		71: isPunchingBag
		72: selectedBotEditAction
		73: pinnedPosition
		74: tempHeroStorage
		75: buttonControlStates
		76: recordingHero
		77: originalHero
		78: waitingOnPlayer
		79: recordingPlayStopFlag
		80: replayResetPoint
		81: frame
		82: totalFrames
		83: playbackOffset
		84: lastRecordedState
		85: recording_changes_type
		86: recording_changes_new_value
		87: recording_frame
		88: currentFrame_changes_type
		89: currentFrame_changes_new_value
		90: currentFrame_frame
		91: nextFrameIndex
		92: changeBuffer_type
		93: changeBuffer_new_value
		94: replayState
		95: replayStateAction
		96: recordingCountdownText
		97: currentConfigSelection
		98: bot
		99: bot_0
		100: bot_1
		101: cacheMenuYIndex
		102: t
}

subroutines
{
	0: UpdatePlayerButtonStatus
	1: RulerHandlePFire
	2: BotPlacementPFire
	3: HandleConfirmationScreenClick
	4: RulerHandleSFire
	5: BotPlacementSFire
	6: findLeft
	7: zeroOffsets
	8: applyOffsets
	9: findRight
	10: findUp
	11: findDown
	12: ResetAllBotsToResetPoints
	13: StoreTempDataFromBot
	14: LoadTempDataToSelectedBot
	15: DeleteRecording
	16: func_group
}

rule("[main.ostw] Disable Inspector Recording")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		First Of(Global._extendedGlobalCollection) == True;
	}

	actions
	{
		Disable Inspector Recording;
	}
}

rule("[interface/menu.ostw] Set up action grid")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.ButtonActionGrid = Empty Array;
		Global.ButtonActionGrid[1] = Array(0, 0, 3, 0, 0, 0, 0, 4, 0, 0, 0, 0, 5, 0, 0, 0, 0, 6, 0, 0, 0, 0, 10, 0, 0);
		Global.ButtonActionGrid[2] = Array(True, True);
		Global.ButtonActionGrid[5] = Array(0, 0, 11, 0, 0, 0, 1, 2, 3, 0, 0, 7, 10, 8, 0, 0, 6, 4, 5, 0, 0, 0, 9, 0, 0);
		Global.ButtonActionGrid[3] = Array(0, 15, 2, 14, 0, 0, 7, 17, 1, 0, 0, 9, 10, 11, 0, 0, 3, 13, 5, 0, 0, 4, 16, 6, 0);
		Global.ButtonActionGrid[4] = Array(0, 0, 0, 0, 0, 0, 1, 9, 3, 0, 0, 2, 7, 5, 0, 0, 4, 8, 6, 0, 0, 0, 0, 0, 0);
		Global.ButtonActionGrid[6] = Array(0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 6, 3, 7, 0, 0, 0, 4, 0, 0, 0, 0, 5, 0, 0);
		Global.ButtonActionGrid[7] = Array(0, 0, 4, 0, 0, 0, 0, 5, 10, 0, 9, 8, 7, 2, 1, 0, 0, 6, 0, 0, 0, 0, 3, 0, 0);
		Global.ButtonActionGrid[9] = 42;
		Global.ButtonActionGrid[8] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0);
		Global.ButtonActionGrid[10] = 42;
	}
}

rule("[interface/menu.ostw] Init player")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.ButtonLabelGrid = Empty Array;
		Event Player.ButtonLabelGrid[1] = Array(Custom String(""), Custom String(""), Custom String("Information"), Custom String(""),
			Custom String(""), Custom String(""), Custom String(""), Custom String("Modifications"), Custom String(""), Custom String(""),
			Custom String(""), Custom String(""), Custom String("Tools"), Custom String(""), Custom String(""), Custom String(""),
			Custom String(""), Custom String("Dummy Bots/Replay"), Custom String(""), Custom String(""), Custom String(""), Custom String(
			""), Custom String("Config"), Custom String(""), Custom String(""));
		Event Player.ButtonLabelGrid[5] = Array(Custom String(""), Custom String(""), Custom String("Enable Invisibility"), Custom String(
			""), Custom String(""), Custom String(""), Custom String("Set Respawn Point"), Custom String("Change Hero"), Custom String(
			"Enable NoClip"), Custom String(""), Custom String(""), Custom String("Place Ruler"), Custom String("Back to Hero Select"),
			Custom String("Enable 3rd Person"), Custom String(""), Custom String(""), Custom String("Unpause Match Time"), Custom String(
			"Skip Setup"), Custom String("End Match"), Custom String(""), Custom String(""), Custom String(""), Custom String(
			"State Reset"), Custom String(""), Custom String(""));
		Event Player.ButtonLabelGrid[3] = Array(Custom String(""), Custom String("Show Exact Health"), Custom String(
			"Show Distance To Crosshair"), Custom String("Show Is On Objective"), Custom String(""), Custom String(""), Custom String(
			"Show Position/Facing"), Custom String("Show Throttle"), Custom String("Show Move Speed"), Custom String(""), Custom String(
			""), Custom String("Show Altitude"), Custom String("Show If On Ground"), Custom String("Show If On Wall"), Custom String(""),
			Custom String(""), Custom String("Show HPS Dealt"), Custom String("Show Status Effects"), Custom String("Show DPS Dealt"),
			Custom String(""), Custom String(""), Custom String("Show HPS Received"), Custom String("Show Damage/Heal Numbers"),
			Custom String("Show DPS Received"), Custom String(""));
		Event Player.ButtonLabelGrid[4] = Array(Custom String(""), Custom String(""), Custom String(""), Custom String(""), Custom String(
			""), Custom String(""), Custom String("Faster Abilities [OFF]"), Custom String("Unkillable [OFF]"), Custom String(
			"Increased Damage Dealt [OFF]"), Custom String(""), Custom String(""), Custom String("Reduced Damage Taken [OFF]"),
			Custom String("Slow Motion [OFF]"), Custom String("Faster Respawn [OFF]"), Custom String(""), Custom String(""), Custom String(
			"Auto-Regen Health [OFF]"), Custom String("Self-Heal Passive [ON]"), Custom String("Disable Mode Completion [OFF]"),
			Custom String(""), Custom String(""), Custom String(""), Custom String(""), Custom String(""), Custom String(""));
		Event Player.ButtonLabelGrid[6] = Array(Custom String(""), Custom String(""), Custom String("Create Dummy Bot"), Custom String(""),
			Custom String(""), Custom String(""), Custom String(""), Custom String("Create Punching Bag"), Custom String(""),
			Custom String(""), Custom String(""), Custom String("Play All Replays"), Custom String("Edit Dummy Bots"), Custom String(
			"Delete All Replays"), Custom String(""), Custom String(""), Custom String(""), Custom String("Reset Bot Positions"),
			Custom String(""), Custom String(""), Custom String(""), Custom String(""), Custom String("Remove All Bots"), Custom String(
			""), Custom String(""));
		Event Player.ButtonLabelGrid[7] = Array(Custom String(""), Custom String(""), Custom String("Buttons"), Custom String(""),
			Custom String(""), Custom String(""), Custom String(""), Custom String("Set Respawn Point"), Custom String(
			"Make Punching Bag"), Custom String(""), Custom String("Delete Replay"), Custom String("Edit Replay"), Custom String(
			"Record Replay"), Custom String("Change Hero"), Custom String("Switch Team"), Custom String(""), Custom String(""),
			Custom String("Pin Bot To Position"), Custom String(""), Custom String(""), Custom String(""), Custom String(""),
			Custom String("Delete"), Custom String(""), Custom String(""));
		Event Player.ButtonLabelGrid[8] = Array(Custom String(" "), Custom String(" "), Custom String(" "), Custom String(" "),
			Custom String(" "), Custom String(" "), Custom String(" "), Custom String("DELAY PLAYBACK OF REPLAY BY"), Custom String(" "),
			Custom String(" "), Custom String(" "), Custom String("{0}{1}", Custom String("                      "), Custom String("◀")),
			Custom String("0"), Custom String("{0}{1}", Custom String("▶"), Custom String("                      ")), Custom String(" "),
			Custom String(" "), Custom String(" "), Custom String("FRAMES"), Custom String(" "), Custom String(" "), Custom String(" "),
			Custom String(" "), Custom String("Reset Delay"), Custom String(" "), Custom String(" "));
		Event Player.ButtonLabelGrid[10] = Array(Custom String(""), Custom String(""), Custom String(""), Custom String(""), Custom String(
			""), Custom String(""), Custom String("◀"), Array(Custom String("HPS/DPS Meter Optimization"), Custom String(
			"Auto-Regen Delay"), Custom String("Button Spam Period"), Custom String("Slow Motion Speed"), Custom String(
			"Interact Destroys Deployables In Replay"), Custom String("Auto Enable Slow-Mo During Recording"), Custom String(
			"Loop Replay Playback"), Custom String("Show Replay Timecode"), Custom String("Quick Actions Enabled"))
			[Event Player.currentConfigSelection], Custom String("▶"), Custom String(""), Custom String(""), Custom String(""),
			Global.OptimizeMetricsForOverTime ? Custom String("Over Time") : Custom String("Normal"), Custom String(""), Custom String(""),
			Custom String(""), Custom String(""), Custom String(""), Custom String(""), Custom String(""), Custom String(""),
			Custom String(""), Custom String(""), Custom String(""), Custom String(""));
		Event Player.ButtonColorGrid = Empty Array;
		Event Player.ButtonColorGrid[1] = Array(Null, Null, Custom Color(200, 50, 50, 255), Null, Null, Null, Null, Color(Green), Null,
			Null, Null, Null, Color(Sky Blue), Null, Null, Null, Null, Color(Yellow), Null, Null, Null, Null, Color(Violet), Null, Null);
		Event Player.ButtonColorGrid[5] = Array(Custom Color(0, 0, 0, 0), Custom Color(0, 0, 0, 0), Color(Violet), Custom Color(0, 0, 0,
			0), Custom Color(0, 0, 0, 0), Custom Color(0, 0, 0, 0), Custom Color(80, 187, 217, 255), Color(Blue), Color(Green),
			Custom Color(0, 0, 0, 0), Custom Color(0, 0, 0, 0), Color(Yellow), Color(Turquoise), Color(Orange), Custom Color(0, 0, 0, 0),
			Custom Color(0, 0, 0, 0), Custom Color(50, 220, 27, 255), Color(Aqua), Custom Color(200, 50, 50, 255), Custom Color(0, 0, 0,
			0), Custom Color(0, 0, 0, 0), Custom Color(0, 0, 0, 0), Custom Color(97, 97, 97, 255), Custom Color(0, 0, 0, 0), Custom Color(
			0, 0, 0, 0));
		Event Player.ButtonColorGrid[3] = Array(Null, Custom Color(200, 50, 50, 255), Color(Aqua), Color(Turquoise), Null, Null, Color(
			Green), Color(Rose), Color(Orange), Null, Null, Color(Sky Blue), Color(Purple), Color(Violet), Null, Null, Color(Yellow),
			Color(Lime Green), Color(Red), Null, Null, Custom Color(245, 200, 0, 255), Color(Blue), Custom Color(218, 76, 10, 255), Null);
		Event Player.ButtonColorGrid[4] = Array(Null, Null, Null, Null, Null, Null, Color(Gray), Color(Gray), Color(Gray), Null, Null,
			Color(Gray), Color(Gray), Color(Gray), Null, Null, Color(Gray), Color(Yellow), Color(Gray), Null, Null, Null, Null, Null,
			Null);
		Event Player.ButtonColorGrid[6] = Array(Null, Null, Color(Green), Null, Null, Null, Null, Color(Sky Blue), Null, Null, Null, Color(
			Lime Green), Color(Yellow), Custom Color(229, 100, 100, 255), Null, Null, Null, Color(Purple), Null, Null, Null, Null, Color(
			Red), Null, Null);
		Event Player.ButtonColorGrid[7] = Array(Null, Null, Color(Aqua), Null, Null, Null, Null, Color(Yellow), Color(Purple), Null, Color(
			Gray), Color(Gray), Custom Color(186, 70, 213, 255), Color(Green), Color(Blue), Null, Null, Color(Orange), Null, Null, Null,
			Null, Color(Red), Null, Null);
		Event Player.ButtonColorGrid[8] = Array(Null, Null, Null, Null, Null, Null, Null, Color(White), Null, Null, Null, Color(Gray),
			Color(White), Color(Gray), Null, Null, Null, Color(White), Null, Null, Null, Null, Color(Red), Null, Null);
		Event Player.ButtonColorGrid[10] = Array(Null, Null, Null, Null, Null, Null, Color(White), Color(White), Color(White), Null, Null,
			Color(White), Color(White), Color(White), Null, Null, Null, Null, Null, Null, Null, Null, Null, Null, Null);
		If(Event Player.hideMenuOpenTooltip);
			Wait Until(Has Spawned(Event Player), 1000000);
			Wait Until(Event Player.currentMenuState != 0, 1);
			If(Event Player.currentMenuState != 0);
				Event Player.hideMenuOpenTooltip = True;
				Abort;
			End;
			Small Message(Event Player, Custom String("   Hold {0} to open menu", Input Binding String(Button(Interact))));
			Wait Until(Event Player.currentMenuState != 0, 1000000);
			Event Player.hideMenuOpenTooltip = True;
		End;
	}
}

rule("[interface/menu.ostw] When menu state changes, find new first selection")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.currentMenuState != 0;
	}

	actions
	{
		Wait(0.064, Abort When False);
		If(Event Player.currentMenuState == 10);
			Event Player.menuXIndex = 2;
			Event Player.menuYIndex = 1;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
			Global._arrayConstructor[6] = Custom String("◀");
			Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
			Global._arrayConstructor[8] = Custom String("▶");
			Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
			Global._arrayConstructor[11] = Custom String("");
			Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
			Global._arrayConstructor[13] = Custom String("");
			Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
		End;
		If(Global.ButtonActionGrid[Event Player.currentMenuState] != 0 && !Array Contains(Array(2, 9, 10), Event Player.currentMenuState));
			Event Player.menuXIndex = 0;
			Event Player.menuYIndex = 0;
			While(Event Player.menuYIndex < 6);
				While(Event Player.menuXIndex < 5);
					If(Global.ButtonActionGrid[Event Player.currentMenuState][Event Player.menuYIndex * 5 + Event Player.menuXIndex] != 0);
						Skip(6);
					End;
					Event Player.menuXIndex = Event Player.menuXIndex + 1;
				End;
				Event Player.menuYIndex = Event Player.menuYIndex + 1;
				Event Player.menuXIndex = 0;
			End;
		End;
		Wait Until(Event Player.currentMenuState != Evaluate Once(Event Player.currentMenuState), 1000000);
		Loop If Condition Is True;
	}
}

rule("Initial Global")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global._extendedGlobalCollection[0] = !Workshop Setting Toggle(Custom String("99. Debug"), Custom String(
			"Enable Inspector Recording"), False, 0);
		Global.UseRoleQueueHealth = Workshop Setting Toggle(Custom String("02. Hero Settings"), Custom String(
			"Use Role Queue Tank Health"), True, 0);
		Global._extendedGlobalCollection[1] = Workshop Setting Combo(Custom String("01. General"), Custom String("Log Level"), 0, Array(
			Custom String("Debug"), Custom String("Info"), Custom String("Warning"), Custom String("Error")), 0);
		Global.AllButtons = Array(Button(Primary Fire), Button(Secondary Fire), Button(Ability 1), Button(Ability 2), Button(Crouch),
			Button(Jump), Button(Melee), Button(Reload), Button(Ultimate), Button(Interact));
		Global.OptimizeMetricsForOverTime = Workshop Setting Combo(Custom String("05. Information"), Custom String(
			"HPS/DPS Meter Optimization"), 0, Array(Custom String("Normal"), Custom String("Over Time")), 0) == 1;
		Global.MetricsUpdatePeriod = Array(1, 2, 4, 6, 10)[Workshop Setting Combo(Custom String("05. Information"), Custom String(
			"HPS/DPS Meter Accuracy"), 0, Array(Custom String("Perfect (1 Tick | Highest Script Load)"), Custom String(
			"Almost Perfect (2 Ticks | Higher Script Load)"), Custom String("Good (4 Ticks | High Script Load)"), Custom String(
			"Fair (6 Ticks | Medium Script Load)"), Custom String("Poor (10 Ticks | Light Script Load)")), 0)] * 0.016;
		Global.AUTO_REGEN_DELAY = Workshop Setting Integer(Custom String("04. Mod Settings"), Custom String("Auto-Regen Delay"), 5, 1, 20,
			0);
		Global.SLOW_MOTION_SPEED = Workshop Setting Integer(Custom String("04. Mod Settings"), Custom String("Slow Motion Speed"), 25, 10,
			100, 0);
		Global.punchingBagTargetHealthProportio = Workshop Setting Real(Custom String("06. Bot and Replay"), Custom String(
			"Punching Bag Target Health Proportion"), 0.800, 0, 1, 0);
		Global.nextSelectionEntityId = 1;
		Global.uniqueHeroSkinCombosRemaining = 12;
		Global.rainbowVector = Left - Left;
		Global.BUTTON_SPAM_PERIOD = Workshop Setting Real(Custom String("06. Bot and Replay"), Custom String("Bot Button Spam Wait Time"),
			1, 0.100, 30, -1);
		Global.allBotsReplayDuringRecording = Workshop Setting Toggle(Custom String("06. Bot and Replay"), Custom String(
			"All Bots Replay During Recording"), True, 0);
		Global.SHOULD_LOOP_CLIP = Workshop Setting Toggle(Custom String("06. Bot and Replay"), Custom String("Loop Replay Playback"), True,
			0);
		Global.RECORD_IN_SLOW_MOTION = Workshop Setting Toggle(Custom String("06. Bot and Replay"), Custom String(
			"Automatically Enable Slow Motion During Recording"), True, 0);
		Global.SHOW_REPLAY_TIMECODES = Workshop Setting Toggle(Custom String("06. Bot and Replay"), Custom String("Show Replay Timecodes"),
			False, 0);
		Global.interactDestroysDeployableCompen = Workshop Setting Toggle(Custom String("06. Bot and Replay"), Custom String(
			"Interact Destroys Deployables In Replay"), False, 0);
		Global.QuickActions = Array(Array(1, Null), Array(2, Null), Array(3, Null), Array(4, Null), Array(5, Null), Array(6, Null), Array(
			7, Null), Array(8, Null), Array(9, Null), Array(10, Null), Array(11, Null), Array(12, Null));
		Global.ActionSettings = Array(Workshop Setting Combo(Custom String("07. Quick Actions"), Custom String("Crouch + Reload"), 5,
			Array(Custom String("None"), Custom String("Change Hero"), Custom String("Toggle Noclip"), Custom String(
			"Play/Pause All Replays"), Custom String("Damage Self"), Custom String("Reset Self to Respawn Point"), Custom String(
			"Reset All Bot Positions"), Custom String("Toggle Bot Edit Mode"), Custom String("Toggle Third-Person"), Custom String(
			"Toggle Faster Abilities"), Custom String("Toggle Slow Motion"), Custom String("Toggle Self-Heal Passive")), 0),
			Workshop Setting Combo(Custom String("07. Quick Actions"), Custom String("Crouch + Melee"), 4, Array(Custom String("None"),
			Custom String("Change Hero"), Custom String("Toggle Noclip"), Custom String("Play/Pause All Replays"), Custom String(
			"Damage Self"), Custom String("Reset Self to Respawn Point"), Custom String("Reset All Bot Positions"), Custom String(
			"Toggle Bot Edit Mode"), Custom String("Toggle Third-Person"), Custom String("Toggle Faster Abilities"), Custom String(
			"Toggle Slow Motion"), Custom String("Toggle Self-Heal Passive")), 0), Workshop Setting Combo(Custom String(
			"07. Quick Actions"), Custom String("Crouch + Interact"), 8, Array(Custom String("None"), Custom String("Change Hero"),
			Custom String("Toggle Noclip"), Custom String("Play/Pause All Replays"), Custom String("Damage Self"), Custom String(
			"Reset Self to Respawn Point"), Custom String("Reset All Bot Positions"), Custom String("Toggle Bot Edit Mode"), Custom String(
			"Toggle Third-Person"), Custom String("Toggle Faster Abilities"), Custom String("Toggle Slow Motion"), Custom String(
			"Toggle Self-Heal Passive")), 0), Workshop Setting Combo(Custom String("07. Quick Actions"), Custom String(
			"Ability 1 + Interact"), 9, Array(Custom String("None"), Custom String("Change Hero"), Custom String("Toggle Noclip"),
			Custom String("Play/Pause All Replays"), Custom String("Damage Self"), Custom String("Reset Self to Respawn Point"),
			Custom String("Reset All Bot Positions"), Custom String("Toggle Bot Edit Mode"), Custom String("Toggle Third-Person"),
			Custom String("Toggle Faster Abilities"), Custom String("Toggle Slow Motion"), Custom String("Toggle Self-Heal Passive")), 0),
			Workshop Setting Combo(Custom String("07. Quick Actions"), Custom String("Ability 2 + Interact"), 6, Array(Custom String(
			"None"), Custom String("Change Hero"), Custom String("Toggle Noclip"), Custom String("Play/Pause All Replays"), Custom String(
			"Damage Self"), Custom String("Reset Self to Respawn Point"), Custom String("Reset All Bot Positions"), Custom String(
			"Toggle Bot Edit Mode"), Custom String("Toggle Third-Person"), Custom String("Toggle Faster Abilities"), Custom String(
			"Toggle Slow Motion"), Custom String("Toggle Self-Heal Passive")), 0), Workshop Setting Combo(Custom String(
			"07. Quick Actions"), Custom String("Ultimate + Interact"), 1, Array(Custom String("None"), Custom String("Change Hero"),
			Custom String("Toggle Noclip"), Custom String("Play/Pause All Replays"), Custom String("Damage Self"), Custom String(
			"Reset Self to Respawn Point"), Custom String("Reset All Bot Positions"), Custom String("Toggle Bot Edit Mode"), Custom String(
			"Toggle Third-Person"), Custom String("Toggle Faster Abilities"), Custom String("Toggle Slow Motion"), Custom String(
			"Toggle Self-Heal Passive")), 0));
		Global._watch_triggers = Empty Array;
		Global.TRIGGERS_ENABLED = Workshop Setting Toggle(Custom String("07. Quick Actions"), Custom String("Quick Actions Enabled"),
			False, -1);
		Global.func_group = Empty Array;
	}
}

rule("Initial Player")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.currentMenuState = 0;
		Event Player.hideMenuOpenTooltip = Workshop Setting Toggle(Custom String("03. Menu Settings"), Custom String(
			"Hide Before-First-Use Menu Open/Close Tooltip"), True, 0);
		Event Player.buttonLocks = Mapped Array(Global.AllButtons, 0);
		Event Player.activeInfoDisplays = Empty Array;
		Event Player.infoDisplayEntities = Empty Array;
		Event Player.healingReceivedEvents = Empty Array;
		Event Player.healingDealtEvents = Empty Array;
		Event Player.damageReceivedEvents = Empty Array;
		Event Player.damageDealtEvents = Empty Array;
		Event Player.totalDamageDisplayTextID = -1;
		Event Player.lastDamageDisplayTextID = -1;
		Event Player.totalHealingDisplayTextID = -1;
		Event Player.lastHealingDisplayTextID = -1;
		Event Player.selectedBots = Empty Array;
		Event Player.buttonControlStates = Mapped Array(Global.AllButtons, Custom String("None"));
		Event Player.replayState = Custom String("NONE");
		Event Player.replayStateAction = Custom String("NONE");
	}
}

rule("[main.ostw] If start match immediately, do so")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Workshop Setting Toggle(Custom String("01. General"), Custom String("Start Match Immediately"), True, 0) == True;
	}

	actions
	{
		Wait(2, Ignore Condition);
		Start Game Mode;
	}
}

rule("[main.ostw] Skip assembling heroes")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Assembling Heroes == True;
	}

	actions
	{
		If(Is True For All(All Players(All Teams), Current Array Element.toolsActionID != 10));
			Set Match Time(Workshop Setting Integer(Custom String("01. General"), Custom String("Assembling Heroes Length"), 5, 0, 30, 0));
		End;
		If(Global.isTimePaused);
			Unpause Match Time;
			Global.isTimePaused = False;
			Wait Until(!Is Assembling Heroes, 9999);
			If(!Global.isTimePaused);
				Pause Match Time;
			End;
			Global.isTimePaused = True;
		End;
	}
}

rule("[main.ostw] pause match time on start of round")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Workshop Setting Toggle(Custom String("01. General"), Custom String("Automatically Pause Match Time At Round Start"), True, 0)
			== True;
		(Is In Setup || Is Game In Progress) == True;
	}

	actions
	{
		Abort If(Global.isTimePaused);
		If(!Global.isTimePaused);
			Pause Match Time;
		End;
		Global.isTimePaused = True;
	}
}

rule("[main.ostw] Go back to lobby early, skipping victory poses and POTG")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Workshop Setting Toggle(Custom String("01. General"), Custom String("Skip Post-Match Flow"), True, 0) == True;
		Is Match Complete == True;
	}

	actions
	{
		Wait(3, Ignore Condition);
		Return to Lobby;
	}
}

rule("[main.ostw] Avoid getting people stuck in menu")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Between Rounds == True;
	}

	actions
	{
		Event Player.currentMenuState = 0;
	}
}

rule("[main.ostw] Skip setup")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Workshop Setting Toggle(Custom String("01. General"), Custom String("Automatically Skip Setup"), True, 0) == True;
		Is In Setup == True;
	}

	actions
	{
		Set Match Time(0);
		If(Global.isTimePaused);
			Unpause Match Time;
			Global.isTimePaused = False;
			Wait Until(!Is In Setup, 9999);
			If(!Global.isTimePaused);
				Pause Match Time;
			End;
			Global.isTimePaused = True;
		End;
	}
}

rule("Create tank health pool")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.UseRoleQueueHealth == True;
		Array Contains(All Tank Heroes, Hero Of(Event Player)) == True;
		(Hero Of(Event Player) == Hero(D.Va) && Is In Alternate Form(Event Player)) == False;
	}

	actions
	{
		Add Health Pool To Player(Event Player, Health, 150, True, True);
		Event Player.TankHealthPool = Last Created Health Pool;
		Wait Until(!Global.UseRoleQueueHealth || !Array Contains(All Tank Heroes, Hero Of(Event Player)) || (Hero Of(Event Player) == Hero(
			D.Va) && Is In Alternate Form(Event Player)), 1000000);
		Remove Health Pool From Player(Event Player.TankHealthPool);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[interface/menu.ostw] Global menu setup")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Create prompt to open mneu"
		Create HUD Text(Array Contains(All Players(All Teams), Local Player) && (
			!Local Player.hideMenuOpenTooltip || Local Player.currentMenuState != 0) ? Local Player : Null, Null, Null, Custom String(
			"Hold [{0}] to {1} menu", Input Binding String(Button(Interact)), Local Player.currentMenuState == 0 ? Custom String("open")
			: Custom String("close")), Top, 1, Color(White), Color(White), Local Player.currentMenuState == 0 ? Color(Green) : Color(Red),
			Visible To String and Color, Visible Never);
		"Create controls hints"
		Create In-World Text(Local Player.currentMenuState != 0 ? Local Player : Null, Custom String("{0} SELECT  |  {2} {1}",
			Input Binding String(Button(Primary Fire)), Local Player.currentMenuState == 1 ? Custom String("CLOSE") : Custom String(
			"BACK"), Input Binding String(Button(Secondary Fire))), Update Every Frame(True * Eye Position(Local Player)
			+ Empty Array * Cross Product(Facing Direction Of(Local Player), Direction From Angles(Horizontal Angle From Direction(
			Facing Direction Of(Local Player)), Vertical Angle From Direction(Facing Direction Of(Local Player)) - 90))
			+ -168 * Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Local Player)),
			Vertical Angle From Direction(Facing Direction Of(Local Player)) - 90) + 300 * Facing Direction Of(Local Player)), 2,
			Do Not Clip, Visible To Position and String, Color(White), Visible Never);
		"Additional helper text"
		Create In-World Text(Array Contains(Array(1, 9, 10), Local Player.currentMenuState) ? Local Player : Null, Array(Custom String(
			"Use WASD to Navigate"), Custom String("{0}{1}{2}", Custom String("Press/Hold "), Input Binding String(Button(Reload)),
			Custom String(" for Manual Control")), Custom String("{0}{1}{2}", Custom String("Hold "), Input Binding String(Button(
			Ability 1)), Custom String(" for faster adjustments (if applicable)")))[Index Of Array Value(Array(1, 9, 10),
			Local Player.currentMenuState)], Update Every Frame(True * Eye Position(Local Player) + Empty Array * Cross Product(
			Facing Direction Of(Local Player), Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Local Player)),
			Vertical Angle From Direction(Facing Direction Of(Local Player)) - 90)) + -145 * Direction From Angles(
			Horizontal Angle From Direction(Facing Direction Of(Local Player)), Vertical Angle From Direction(Facing Direction Of(
			Local Player)) - 90) + 300 * Facing Direction Of(Local Player)), 2, Do Not Clip, Visible To Position and String, Color(White),
			Visible Never);
		"Create grid menu items"
		Global.colIndex = 0;
		While(Global.colIndex < 5);
			Global.rowIndex = 0;
			While(Global.rowIndex < 6);
				Create In-World Text(Array Contains(Array(0, 2, 9), Local Player.currentMenuState) ? Null : Local Player,
					Local Player.ButtonLabelGrid[Local Player.currentMenuState][Evaluate Once(Global.rowIndex) * 5 + Evaluate Once(Global.colIndex)
					], Update Every Frame(True * Eye Position(Local Player) + 100 * (-3 + 1.500 * Evaluate Once(Global.colIndex)) * Cross Product(
					Facing Direction Of(Local Player), Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Local Player)),
					Vertical Angle From Direction(Facing Direction Of(Local Player)) - 90)) + 100 * (1.200 - 0.450 * Evaluate Once(Global.rowIndex)
					- 0.200) * Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Local Player)),
					Vertical Angle From Direction(Facing Direction Of(Local Player)) - 90) + 300 * Facing Direction Of(Local Player)), 2,
					Do Not Clip, Visible To Position String and Color, Local Player.menuXIndex == Evaluate Once(Global.colIndex)
					&& Local Player.menuYIndex == Evaluate Once(Global.rowIndex) ? Custom Color(255, 255, 255, 155 + 100 * Sine From Degrees(
					Total Time Elapsed * 720 % 360)) : Local Player.ButtonColorGrid[Local Player.currentMenuState][Evaluate Once(Global.rowIndex)
					* 5 + Evaluate Once(Global.colIndex)], Visible Never);
				Global.rowIndex += 1;
			End;
			Global.colIndex += 1;
		End;
		"Create confirm and abort buttons"
		Create In-World Text(Local Player.currentMenuState == 2 ? Local Player : Null, Custom String("{0}{1}{2}", Custom String(
			"Are you sure you want to "), Local Player.actionToConfirm, Custom String("?")), Update Every Frame(True * Eye Position(
			Local Player) + Empty Array * Cross Product(Facing Direction Of(Local Player), Direction From Angles(
			Horizontal Angle From Direction(Facing Direction Of(Local Player)), Vertical Angle From Direction(Facing Direction Of(
			Local Player)) - 90)) + 80 * Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Local Player)),
			Vertical Angle From Direction(Facing Direction Of(Local Player)) - 90) + 300 * Facing Direction Of(Local Player)), 3,
			Do Not Clip, Visible To Position and String, Color(Rose), Visible Never);
		"Create bespoke end match confirm screen"
		Create In-World Text(Local Player.currentMenuState == 2 ? Local Player : Null, Custom String("[YES]"), Update Every Frame(
			True * Eye Position(Local Player) + -70 * Cross Product(Facing Direction Of(Local Player), Direction From Angles(
			Horizontal Angle From Direction(Facing Direction Of(Local Player)), Vertical Angle From Direction(Facing Direction Of(
			Local Player)) - 90)) + -90 * Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Local Player)),
			Vertical Angle From Direction(Facing Direction Of(Local Player)) - 90) + 300 * Facing Direction Of(Local Player)), 3,
			Do Not Clip, Visible To Position String and Color, Local Player.menuXIndex == 0 && Local Player.menuYIndex == 0 ? Custom Color(
			255, 255, 255, 155 + 100 * Sine From Degrees(Total Time Elapsed * 720 % 360)) : Color(Red), Visible Never);
		Create In-World Text(Local Player.currentMenuState == 2 ? Local Player : Null, Custom String("[NO]"), Update Every Frame(
			True * Eye Position(Local Player) + 70 * Cross Product(Facing Direction Of(Local Player), Direction From Angles(
			Horizontal Angle From Direction(Facing Direction Of(Local Player)), Vertical Angle From Direction(Facing Direction Of(
			Local Player)) - 90)) + -90 * Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Local Player)),
			Vertical Angle From Direction(Facing Direction Of(Local Player)) - 90) + 300 * Facing Direction Of(Local Player)), 3,
			Do Not Clip, Visible To Position String and Color, Local Player.menuXIndex == 1 && Local Player.menuYIndex == 0 ? Custom Color(
			255, 255, 255, 155 + 100 * Sine From Degrees(Total Time Elapsed * 720 % 360)) : Color(Lime Green), Visible Never);
		"Create dummy bot editing screen"
		Global.i = 0;
		While(Global.i < Count Of(Global.AllButtons));
			Create In-World Text(Local Player.currentMenuState == 9 ? Local Player : Null, Custom String("{0}: {1}",
				Global.AllButtons[Evaluate Once(Global.i)], Local Player.selectedBot.buttonControlStates[Evaluate Once(Global.i)]),
				Update Every Frame(True * Eye Position(Local Player) + 75 * Cross Product(Facing Direction Of(Local Player),
				Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Local Player)), Vertical Angle From Direction(
				Facing Direction Of(Local Player)) - 90)) + 100 * (1 + Evaluate Once(Global.i) * -0.170 - 0.200) * Direction From Angles(
				Horizontal Angle From Direction(Facing Direction Of(Local Player)), Vertical Angle From Direction(Facing Direction Of(
				Local Player)) - 90) + 300 * Facing Direction Of(Local Player)), 1.250, Do Not Clip, Visible To Position String and Color,
				Local Player.menuXIndex == 0 && Local Player.menuYIndex == Evaluate Once(Global.i) ? Custom Color(255, 255, 255,
				155 + 100 * Sine From Degrees(Total Time Elapsed * 720 % 360)) : Color(Gray), Visible Never);
			Global.i += 1;
		End;
		"Create background orbie"
		Create Effect(Entity Exists(Local Player) && Local Player.currentMenuState != 0 ? Local Player : Null, Orb, Color(Black),
			Local Player.menuActivationPoint[1] - 0.325 * Local Player.menuActivationPoint[2], 0.250, Visible To Position and Radius);
	}
}

rule("[lib/player/buttonControl.del] update player button status")
{
	event
	{
		Subroutine;
		UpdatePlayerButtonStatus;
	}

	actions
	{
		For Global Variable(button, 0, Count Of(Global.AllButtons), 1);
			If(Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Global.AllButtons[Global.button])] == 0);
				Allow Button(Global.player, Global.AllButtons[Global.button]);
			Else;
				Disallow Button(Global.player, Global.AllButtons[Global.button]);
			End;
		End;
	}
}

rule("[interface/menu.ostw] Initialize player and perform cleanup")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.currentMenuState != 0;
	}

	actions
	{
		"Note that we store it for reevaluation, because changing heroes causes a respawn which overwrites non-reeval force pos and facing"
		Event Player.menuActivationPoint = Array(Position Of(Event Player), Eye Position(Event Player), Facing Direction Of(Event Player));
		Stop Transforming Throttle(Event Player);
		Set Aim Speed(Event Player, 0);
		Start Facing(Event Player, Event Player.menuActivationPoint[2], 1000, To World, None);
		Start Forcing Player Position(Event Player, First Of(Event Player.menuActivationPoint), False);
		Set Gravity(Event Player, 0);
		Event Player.buttonLocks = Mapped Array(Event Player.buttonLocks, Current Array Element + 1);
		Global.player = Event Player;
		Call Subroutine(UpdatePlayerButtonStatus);
		Event Player.invisibilityLockCount += 1;
		Event Player.phasedOutLockCount += 1;
		Disable Kill Feed(Event Player);
		Disable Game Mode In-World UI(Event Player);
		Disable Game Mode HUD(Event Player);
		Disable Hero HUD(Event Player);
		Start Camera(Event Player, Event Player.menuActivationPoint[1],
			Event Player.menuActivationPoint[1] + Event Player.menuActivationPoint[2], 100);
		Event Player.menuXIndex = 0;
		Event Player.menuYIndex = 0;
		Wait Until(Event Player.currentMenuState == 0, 9999);
		Stop Camera(Event Player);
		Enable Kill Feed(Event Player);
		Enable Game Mode In-World UI(Event Player);
		Enable Game Mode HUD(Event Player);
		Enable Hero HUD(Event Player);
		Stop Facing(Event Player);
		Stop Forcing Player Position(Event Player);
		If(!Event Player.isNoClipActive);
			Set Gravity(Event Player, 100);
		End;
		Set Aim Speed(Event Player, 100);
		"Give a leniency period for buttons to be let go of"
		Wait(0.250, Ignore Condition);
		Event Player.buttonLocks = Mapped Array(Event Player.buttonLocks, Current Array Element - 1);
		Global.player = Event Player;
		Call Subroutine(UpdatePlayerButtonStatus);
		Event Player.invisibilityLockCount -= 1;
		Event Player.phasedOutLockCount -= 1;
		Loop If Condition Is True;
	}
}

rule("[interface/menu.ostw] When player holds Interact long enough, toggle menu")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == False;
		Is Alive(Event Player) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
	}

	actions
	{
		Wait(Global.activeModifications[7] ? 0.500 * Global.SLOW_MOTION_SPEED / 100 : 0.500, Abort When False);
		If(Event Player.currentMenuState == 0);
			Event Player.currentMenuState = 1;
		Else;
			Event Player.currentMenuState = 0;
		End;
	}
}

rule("[interface/tools/ruler.ostw] Handle player setting first point")
{
	event
	{
		Subroutine;
		RulerHandlePFire;
	}

	actions
	{
		Event Player.isMovingPosition1 = True;
		Wait Until(!Is Button Held(Event Player, Button(Primary Fire)), 99999);
		Event Player.isMovingPosition1 = False;
		Event Player.position1 = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 5 * Facing Direction Of(
			Event Player), All Players(All Teams), Event Player, True);
	}
}

rule("[interface/dummyBotsAndReplay/botPlacementModule.ostw] Handle left-click")
{
	event
	{
		Subroutine;
		BotPlacementPFire;
	}

	actions
	{
		If(!(Has Spawned(Event Player) && Is Alive(Event Player) && Event Player.currentMenuState == 0));
			Skip(31);
		End;
		Event Player.selectedControl = First Of(Sorted Array(Filtered Array(Append To Array(Mapped Array(Filtered Array(All Players(
			All Teams), Is Dummy Bot(Current Array Element) && Current Array Element.replayState == Custom String("NONE")),
			Current Array Element.positionControl), Mapped Array(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.facingControl)), Distance Between(
			Eye Position(Event Player) + Facing Direction Of(Event Player) * Distance Between(Eye Position(Event Player),
			Current Array Element[2]), Current Array Element[2]) <= 1.250), -1 * Dot Product(Facing Direction Of(Event Player),
			Direction Towards(Eye Position(Event Player), Current Array Element[2]))));
		If(Event Player.selectedControl[1] == 0);
			Skip(27);
		End;
		If(Array Contains(Mapped Array(Mapped Array(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.positionControl),
			Current Array Element[1]), Event Player.selectedControl[1]));
			"Check if the bot is currently pinned to a position"
			If(First Of(First Of(Event Player.selectedControl).pinnedPosition) != Null);
				Small Message(Event Player, Custom String("  This bot is pinned to its current location, unpin it first."));
				Play Effect(Event Player, Debuff Impact Sound, Null, Event Player, 100);
				Abort;
			End;
			"If a bot got selected, move it"
			Event Player.selectionSetDistance = Distance Between(Eye Position(Event Player), First Of(Event Player.selectedControl));
			Start Forcing Player Position(First Of(Event Player.selectedControl), Update Every Frame(Ray Cast Hit Position(Eye Position(
				Event Player), Eye Position(Event Player) + Facing Direction Of(Event Player) * Event Player.selectionSetDistance, Null, Null,
				False)), True);
			Wait Until(!(Is Button Held(Event Player, Button(Primary Fire)) && Event Player.botControlMode == 1), 1000000);
			If(Altitude Of(First Of(Event Player.selectedControl)) > 1);
				Set Gravity(First Of(Event Player.selectedControl), 0);
				Wait(0.016, Ignore Condition);
				If(Speed Of(First Of(Event Player.selectedControl)) > 0.050);
					Apply Impulse(First Of(Event Player.selectedControl), Velocity Of(Event Player) * -1, 0.010, To World, Cancel Contrary Motion XYZ);
				End;
			Else;
				Set Gravity(First Of(Event Player.selectedControl), 100);
			End;
			Stop Forcing Player Position(First Of(Event Player.selectedControl));
		Else If(Array Contains(Mapped Array(Mapped Array(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
				&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.facingControl),
				Current Array Element[1]), Event Player.selectedControl[1]));
			"If a bot's facing got selected, rotate it"
			Start Facing(First Of(Event Player.selectedControl), Update Every Frame(Direction Towards(Eye Position(First Of(
				Event Player.selectedControl)), Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
				+ Facing Direction Of(Event Player) * Evaluate Once(Distance Between(Eye Position(Event Player),
				Event Player.selectedControl[2])), Null, Null, False))), 999999, To World, Direction and Turn Rate);
			Wait Until(!(Is Button Held(Event Player, Button(Primary Fire)) && Event Player.botControlMode == 1), 1000000);
			Event Player.selectedControl[2] = Ray Cast Hit Position(Eye Position(First Of(Event Player.selectedControl)), Eye Position(
				First Of(Event Player.selectedControl)) + Facing Direction Of(First Of(Event Player.selectedControl)) * 5, Null, Null, False);
			Stop Facing(First Of(Event Player.selectedControl));
		End;
		Event Player.selectedControl = Null;
	}
}

rule("Handle confirm/cancel")
{
	event
	{
		Subroutine;
		HandleConfirmationScreenClick;
	}

	actions
	{
		If(Event Player.menuXIndex == 1 && Event Player.menuYIndex == 0);
			Event Player.confirmationState = 2;
		Else If(Event Player.menuXIndex == 0 && Event Player.menuYIndex == 0);
			Event Player.confirmationState = 1;
		End;
	}
}

rule("[interface/menu.ostw] Primary fire to select current item")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
	}

	actions
	{
		Abort If(Is Dummy Bot(Event Player));
		"Extra-menu primary fire handling"
		If(Event Player.currentMenuState == 0);
			If(Is Alive(Event Player) && Event Player.playerRulerState == 1);
				Call Subroutine(RulerHandlePFire);
			End;
			If(Event Player.botControlMode == 1);
				Call Subroutine(BotPlacementPFire);
			End;
			Abort;
		End;
		Abort If(
			Global.ButtonActionGrid[Event Player.currentMenuState] != 42 && Global.ButtonActionGrid[Event Player.currentMenuState][Event Player.menuYIndex * 5 + Event Player.menuXIndex] == 0);
		Skip(Array(374, 0, 2, 4, 9, 221, 224, 229, 234, 245)[Index Of Array Value(Array(1, 2, 5, 3, 4, 6, 7, 9, 8),
			Event Player.currentMenuState) + 1]);
		Event Player.currentMenuState = Global.ButtonActionGrid[1][Event Player.menuYIndex * 5 + Event Player.menuXIndex];
		Skip(372);
		Call Subroutine(HandleConfirmationScreenClick);
		Skip(370);
		Abort If(Global.ButtonActionGrid[5][Event Player.menuYIndex * 5 + Event Player.menuXIndex] == 0);
		Event Player.toolsActionID = Global.ButtonActionGrid[5][Event Player.menuYIndex * 5 + Event Player.menuXIndex];
		Wait(0.016, Ignore Condition);
		Event Player.toolsActionID = 0;
		Skip(365);
		Abort If(Global.ButtonActionGrid[3][Event Player.menuYIndex * 5 + Event Player.menuXIndex] == 0);
		If(Array Contains(Event Player.activeInfoDisplays,
			Global.ButtonActionGrid[3][Event Player.menuYIndex * 5 + Event Player.menuXIndex]));
			Modify Player Variable(Event Player, activeInfoDisplays, Remove From Array By Value,
				Global.ButtonActionGrid[3][Event Player.menuYIndex * 5 + Event Player.menuXIndex]);
			Skip(Array(91, 0, 7, 14, 21, 28, 35, 42, 49, 56, 64, 71, 78, 85)[Index Of Array Value(Array(7, 17, 1, 9, 10, 11, 14, 15, 2, 3, 4,
				5, 6), Global.ButtonActionGrid[3][Event Player.menuYIndex * 5 + Event Player.menuXIndex]) + 1]);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
			Global._arrayConstructor[6] = Custom String("Show Position/Facing");
			Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[3];
			Global._arrayConstructor[6] = Color(Green);
			Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
			Skip(84);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
			Global._arrayConstructor[7] = Custom String("Show Throttle");
			Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[3];
			Global._arrayConstructor[7] = Color(Rose);
			Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
			Skip(77);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
			Global._arrayConstructor[8] = Custom String("Show Move Speed");
			Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[3];
			Global._arrayConstructor[8] = Color(Orange);
			Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
			Skip(70);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
			Global._arrayConstructor[11] = Custom String("Show Altitude");
			Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[3];
			Global._arrayConstructor[11] = Color(Sky Blue);
			Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
			Skip(63);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
			Global._arrayConstructor[12] = Custom String("Show If On Ground");
			Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[3];
			Global._arrayConstructor[12] = Color(Purple);
			Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
			Skip(56);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
			Global._arrayConstructor[13] = Custom String("Show If On Wall");
			Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[3];
			Global._arrayConstructor[13] = Color(Violet);
			Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
			Skip(49);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
			Global._arrayConstructor[3] = Custom String("Show Is On Objective");
			Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[3];
			Global._arrayConstructor[3] = Color(Turquoise);
			Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
			Skip(42);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
			Global._arrayConstructor[1] = Custom String("Show Exact Health");
			Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[3];
			Global._arrayConstructor[1] = Custom Color(200, 50, 50, 255);
			Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
			Skip(35);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
			Global._arrayConstructor[2] = Custom String("Show Distance To Crosshair");
			Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[3];
			Global._arrayConstructor[2] = Color(Aqua);
			Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
			Destroy In-World Text(Event Player.infoDisplayEntities[2]);
			Skip(28);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
			Global._arrayConstructor[16] = Custom String("Show HPS Dealt");
			Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[3];
			Global._arrayConstructor[16] = Color(Yellow);
			Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
			Skip(20);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
			Global._arrayConstructor[21] = Custom String("Show HPS Received");
			Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[3];
			Global._arrayConstructor[21] = Custom Color(245, 200, 0, 255);
			Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
			Skip(13);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
			Global._arrayConstructor[18] = Custom String("Show DPS Dealt");
			Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[3];
			Global._arrayConstructor[18] = Color(Red);
			Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
			Skip(6);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
			Global._arrayConstructor[23] = Custom String("Show DPS Received");
			Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[3];
			Global._arrayConstructor[23] = Custom Color(218, 76, 10, 255);
			Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
			Destroy HUD Text(
				Event Player.infoDisplayEntities[Global.ButtonActionGrid[3][Event Player.menuYIndex * 5 + Event Player.menuXIndex]]);
			Skip(114);
		End;
		If(Count Of(Event Player.activeInfoDisplays) >= 5);
			Play Effect(Event Player, Debuff Impact Sound, Null, Event Player, 200);
			Small Message(Event Player, Custom String("{0} Too many active readouts (max {1}).", Icon String(Warning), 5));
			Wait(0.150, Ignore Condition);
			Small Message(Event Player, Custom String("{0} Remove some readouts and try again", Icon String(Warning)));
			Skip(107);
		End;
		Modify Player Variable(Event Player, activeInfoDisplays, Append To Array,
			Global.ButtonActionGrid[3][Event Player.menuYIndex * 5 + Event Player.menuXIndex]);
		Skip(Array(103, 0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96)[Index Of Array Value(Array(7, 17, 1, 9, 10, 11, 14, 15, 2, 3, 4,
			5, 6), Global.ButtonActionGrid[3][Event Player.menuYIndex * 5 + Event Player.menuXIndex]) + 1]);
		Create HUD Text(Event Player.currentMenuState == 0 ? Event Player : Null, Custom String(" POS: {0} ", Update Every Frame(
			Position Of(Event Player))), Custom String("{0}", Custom String(
			"                                                                                          ")), Custom String("LOOK: {0}",
			Update Every Frame(Facing Direction Of(Event Player))), Left, Index Of Array Value(Event Player.activeInfoDisplays, 7), Color(
			White), Color(White), Color(White), Visible To Sort Order and String, Default Visibility);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[6] = Custom String("Hide Position/Facing");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[6] = Color(Gray);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
		Skip(95);
		Create HUD Text(Event Player.currentMenuState == 0 ? Event Player : Null, Custom String(" THROTTLE: {0} ", Update Every Frame(
			Throttle Of(Event Player))), Custom String(" "), Custom String("{0}", Custom String(
			"                                                                                          ")), Left, Index Of Array Value(
			Event Player.activeInfoDisplays, 17), Color(White), Color(White), Color(White), Visible To Sort Order and String,
			Default Visibility);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[7] = Custom String("Hide Throttle");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[7] = Color(Gray);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
		Skip(87);
		Create HUD Text(Event Player.currentMenuState == 0 ? Event Player : Null, Custom String(" SPEED: {0} ", Update Every Frame(
			Speed Of(Event Player))), Custom String("Vert: {0}", Vertical Speed Of(Event Player)), Custom String("Horiz: {0}{1}",
			Horizontal Speed Of(Event Player), Custom String(
			"                                                                                          ")), Left, Index Of Array Value(
			Event Player.activeInfoDisplays, 1), Color(White), Color(White), Color(White), Visible To Sort Order and String,
			Default Visibility);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[8] = Custom String("Hide Move Speed");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[8] = Color(Gray);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
		Skip(79);
		Create HUD Text(Event Player.currentMenuState == 0 ? Event Player : Null, Custom String(" ALT: {0} ", Update Every Frame(
			Altitude Of(Event Player))), Custom String(" "), Custom String("{0}", Custom String(
			"                                                                                          ")), Left, Index Of Array Value(
			Event Player.activeInfoDisplays, 9), Color(White), Color(White), Color(White), Visible To Sort Order and String,
			Default Visibility);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[11] = Custom String("Hide Altitude");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[11] = Color(Gray);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
		Skip(71);
		Create HUD Text(Event Player.currentMenuState == 0 ? Event Player : Null, Custom String(" ON GROUND: {0} ", Update Every Frame(
			Is On Ground(Event Player))), Custom String(" "), Custom String("{0}", Custom String(
			"                                                                                          ")), Left, Index Of Array Value(
			Event Player.activeInfoDisplays, 10), Is On Ground(Event Player) ? Color(Green) : Color(Red), Color(White), Color(White),
			Visible To Sort Order String and Color, Default Visibility);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[12] = Custom String("Hide If On Ground");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[12] = Color(Gray);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
		Skip(63);
		Create HUD Text(Event Player.currentMenuState == 0 ? Event Player : Null, Custom String(" ON WALL: {0} ", Update Every Frame(
			Is On Wall(Event Player)) ? Custom String("True") : Custom String("False")), Custom String(" "), Custom String("{0}",
			Custom String("                                                                                          ")), Left,
			Index Of Array Value(Event Player.activeInfoDisplays, 11), Is On Wall(Event Player) ? Color(Green) : Color(Red), Color(White),
			Color(White), Visible To Sort Order String and Color, Default Visibility);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[13] = Custom String("Hide If On Wall");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[13] = Color(Gray);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
		Skip(55);
		Create HUD Text(Event Player.currentMenuState == 0 ? Event Player : Null, Custom String(" ON OBJECTIVE: {0} ", Update Every Frame(
			Is On Objective(Event Player)) ? Custom String("True") : Custom String("False")), Custom String(" "), Custom String("{0}",
			Custom String("                                                                                          ")), Left,
			Index Of Array Value(Event Player.activeInfoDisplays, 14), Is On Wall(Event Player) ? Color(Green) : Color(Red), Color(White),
			Color(White), Visible To Sort Order String and Color, Default Visibility);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[3] = Custom String("Hide Is On Objective");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[3] = Color(Gray);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
		Skip(47);
		Create HUD Text(Event Player.currentMenuState == 0 ? Event Player : Null, Custom String(" Exact Health: {0} ", Update Every Frame(
			Health(Event Player))), Custom String(" "), Custom String("{0}", Custom String(
			"                                                                                          ")), Left, Index Of Array Value(
			Event Player.activeInfoDisplays, 15), Update Every Frame(Custom Color(((100 * Normalized Health(Event Player)
			< 60 ? 0.640 : 0.640 * (1 - Absolute Value(100 * Normalized Health(Event Player) / 60 % 2 - 1))) + 0.160) * 255, ((
			100 * Normalized Health(Event Player) < 60 ? 0.640 * (1 - Absolute Value(100 * Normalized Health(Event Player) / 60 % 2 - 1))
			: 0.640) + 0.160) * 255, 40.800, 255)), Color(White), Color(White), Visible To Sort Order String and Color,
			Default Visibility);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[1] = Custom String("Hide Exact Health");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[1] = Color(Gray);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
		Skip(39);
		Create In-World Text(Event Player.currentMenuState == 0 ? Event Player : Null, Custom String("DIST: {0}", Distance Between(
			Eye Position(Event Player), Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ 200 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True))), Update Every Frame(
			True * Eye Position(Local Player) + Empty Array * Cross Product(Facing Direction Of(Local Player), Direction From Angles(
			Horizontal Angle From Direction(Facing Direction Of(Local Player)), Vertical Angle From Direction(Facing Direction Of(
			Local Player)) - 90)) + -10 * Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Local Player)),
			Vertical Angle From Direction(Facing Direction Of(Local Player)) - 90) + 300 * Facing Direction Of(Local Player)), 1,
			Do Not Clip, Visible To Position and String, Color(White), Default Visibility);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[2] = Custom String("Hide Distance To Crosshair");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[2] = Color(Gray);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
		Skip(31);
		Create HUD Text(Event Player.currentMenuState == 0 ? Event Player : Null, Custom String("HPS Dealt: {0}", Update Every Frame(
			Event Player.healDealtInPeriod / (Global.OptimizeMetricsForOverTime ? 0.384 : 1))), Custom String("Self: {0}", Max(0,
			Update Every Frame((Event Player.healDealtInPeriod - Event Player.healDealtInPeriodNonSelf) / (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1)))), Custom String("Other: {0}{1}", Update Every Frame(
			Event Player.healDealtInPeriodNonSelf / (Global.OptimizeMetricsForOverTime ? 0.384 : 1)), Custom String(
			"                                                                                          ")), Left, Index Of Array Value(
			Event Player.activeInfoDisplays, 3), Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[16] = Custom String("Hide HPS Dealt");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[16] = Color(Gray);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
		Skip(23);
		Create HUD Text(Event Player.currentMenuState == 0 ? Event Player : Null, Custom String("HPS Received: {0}", Update Every Frame(
			Event Player.healReceivedInPeriod / (Global.OptimizeMetricsForOverTime ? 0.384 : 1))), Custom String("Self: {0}", Max(0,
			Update Every Frame((Event Player.healReceivedInPeriod - Event Player.healReceivedInPeriodNonSelf) / (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1)))), Custom String("Other: {0}{1}", Update Every Frame(
			Event Player.healReceivedInPeriodNonSelf / (Global.OptimizeMetricsForOverTime ? 0.384 : 1)), Custom String(
			"                                                                                          ")), Left, Index Of Array Value(
			Event Player.activeInfoDisplays, 4), Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[21] = Custom String("Hide HPS Received");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[21] = Color(Gray);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
		Skip(15);
		Create HUD Text(Event Player.currentMenuState == 0 ? Event Player : Null, Custom String("DPS Dealt: {0}", Update Every Frame(
			Event Player.damageDealtInPeriod / (Global.OptimizeMetricsForOverTime ? 0.384 : 1))), Custom String("Self: {0}", Max(0,
			Update Every Frame((Event Player.damageDealtInPeriod - Event Player.damageDealtInPeriodNonSelf) / (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1)))), Custom String("Other: {0}{1}", Update Every Frame(
			Event Player.damageDealtInPeriodNonSelf / (Global.OptimizeMetricsForOverTime ? 0.384 : 1)), Custom String(
			"                                                                                          ")), Left, Index Of Array Value(
			Event Player.activeInfoDisplays, 5), Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[18] = Custom String("Hide DPS Dealt");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[18] = Color(Gray);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
		Skip(7);
		Create HUD Text(Event Player.currentMenuState == 0 ? Event Player : Null, Custom String("DPS Received: {0}", Update Every Frame(
			Event Player.damageReceivedInPeriod / (Global.OptimizeMetricsForOverTime ? 0.384 : 1))), Custom String("Self: {0}", Max(0,
			Update Every Frame((Event Player.damageReceivedInPeriod - Event Player.damageReceivedInPeriodNonSelf) / (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1)))), Custom String("Other: {0}{1}", Update Every Frame(
			Event Player.damageReceivedInPeriodNonSelf / (Global.OptimizeMetricsForOverTime ? 0.384 : 1)), Custom String(
			"                                                                                          ")), Left, Index Of Array Value(
			Event Player.activeInfoDisplays, 6), Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[23] = Custom String("Hide DPS Received");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[23] = Color(Gray);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
		Event Player.infoDisplayEntities[Global.ButtonActionGrid[3][Event Player.menuYIndex * 5 + Event Player.menuXIndex]] = Last Text ID;
		Skip(153);
		Abort If(Global.ButtonActionGrid[4][Event Player.menuYIndex * 5 + Event Player.menuXIndex] == 0);
		Global.activeModifications[Global.ButtonActionGrid[4][Event Player.menuYIndex * 5 + Event Player.menuXIndex]] = !Global.activeModifications[Global.ButtonActionGrid[4][Event Player.menuYIndex * 5 + Event Player.menuXIndex]];
		Skip(150);
		Abort If(Global.ButtonActionGrid[6][Event Player.menuYIndex * 5 + Event Player.menuXIndex] == 0);
		Event Player.selectedBotsReplayAction = Global.ButtonActionGrid[6][Event Player.menuYIndex * 5 + Event Player.menuXIndex];
		Wait(0.016, Ignore Condition);
		Event Player.selectedBotsReplayAction = 0;
		Skip(145);
		Abort If(Global.ButtonActionGrid[7][Event Player.menuYIndex * 5 + Event Player.menuXIndex] == 0);
		Event Player.selectedBotEditAction = Global.ButtonActionGrid[7][Event Player.menuYIndex * 5 + Event Player.menuXIndex];
		Wait(0.016, Ignore Condition);
		Event Player.selectedBotEditAction = 0;
		Skip(140);
		If(Count Of(Event Player.selectedBot.buttonControlStates) < Event Player.menuYIndex + 1);
			Event Player.selectedBot.buttonControlStates[Event Player.menuYIndex] = Custom String("None");
		End;
		If(Event Player.selectedBot.buttonControlStates[Event Player.menuYIndex] == Custom String("None"));
			Event Player.selectedBot.buttonControlStates[Event Player.menuYIndex] = Custom String("Holding");
		Else If(Event Player.selectedBot.buttonControlStates[Event Player.menuYIndex] == Custom String("Holding"));
			Event Player.selectedBot.buttonControlStates[Event Player.menuYIndex] = Custom String("Spamming");
		Else;
			Event Player.selectedBot.buttonControlStates[Event Player.menuYIndex] = Custom String("None");
		End;
		Skip(129);
		If(Event Player.menuXIndex == 3 && Event Player.menuYIndex == 2);
			Event Player.selectedBot.playbackOffset += 1;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
			Global._arrayConstructor[12] = Event Player.selectedBot.playbackOffset;
			Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[8];
			Global._arrayConstructor[12] = Color(White);
			Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
			If(Event Player.selectedBot.playbackOffset == 1);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
				Global._arrayConstructor[17] = Custom String("FRAME");
				Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
				Global._arrayConstructor = Event Player.ButtonColorGrid[8];
				Global._arrayConstructor[17] = Color(White);
				Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
			Else;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
				Global._arrayConstructor[17] = Custom String("FRAMES");
				Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
				Global._arrayConstructor = Event Player.ButtonColorGrid[8];
				Global._arrayConstructor[17] = Color(White);
				Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
			End;
		Else If(Event Player.menuXIndex == 1 && Event Player.menuYIndex == 2);
			If(Event Player.selectedBot.playbackOffset <= 0);
				Abort;
			End;
			Event Player.selectedBot.playbackOffset -= 1;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
			Global._arrayConstructor[12] = Event Player.selectedBot.playbackOffset;
			Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[8];
			Global._arrayConstructor[12] = Color(White);
			Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
			If(Event Player.selectedBot.playbackOffset == 1);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
				Global._arrayConstructor[17] = Custom String("FRAME");
				Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
				Global._arrayConstructor = Event Player.ButtonColorGrid[8];
				Global._arrayConstructor[17] = Color(White);
				Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
			Else;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
				Global._arrayConstructor[17] = Custom String("FRAMES");
				Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
				Global._arrayConstructor = Event Player.ButtonColorGrid[8];
				Global._arrayConstructor[17] = Color(White);
				Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
			End;
		Else If(Event Player.menuXIndex == 2 && Event Player.menuYIndex == 4);
			Event Player.selectedBot.playbackOffset = 0;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
			Global._arrayConstructor[12] = Event Player.selectedBot.playbackOffset;
			Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[8];
			Global._arrayConstructor[12] = Color(White);
			Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
			If(Event Player.selectedBot.playbackOffset == 1);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
				Global._arrayConstructor[17] = Custom String("FRAME");
				Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
				Global._arrayConstructor = Event Player.ButtonColorGrid[8];
				Global._arrayConstructor[17] = Color(White);
				Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
			Else;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
				Global._arrayConstructor[17] = Custom String("FRAMES");
				Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
				Global._arrayConstructor = Event Player.ButtonColorGrid[8];
				Global._arrayConstructor[17] = Color(White);
				Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
			End;
			Abort;
		End;
		Event Player.tempMenuXIndex = Event Player.menuXIndex;
		Wait(Global.activeModifications[7] ? 0.250 * Global.SLOW_MOTION_SPEED / 100 : 0.250, Abort When False);
		While(Event Player.currentMenuState == 8 && Is Button Held(Event Player, Button(Primary Fire))
			&& Event Player.menuXIndex == Event Player.tempMenuXIndex);
			If(Event Player.menuXIndex == 3 && Event Player.menuYIndex == 2);
				Event Player.selectedBot.playbackOffset += 1;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
				Global._arrayConstructor[12] = Event Player.selectedBot.playbackOffset;
				Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
				Global._arrayConstructor = Event Player.ButtonColorGrid[8];
				Global._arrayConstructor[12] = Color(White);
				Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
				If(Event Player.selectedBot.playbackOffset == 1);
					Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
					Global._arrayConstructor[17] = Custom String("FRAME");
					Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
					Global._arrayConstructor = Event Player.ButtonColorGrid[8];
					Global._arrayConstructor[17] = Color(White);
					Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
				Else;
					Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
					Global._arrayConstructor[17] = Custom String("FRAMES");
					Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
					Global._arrayConstructor = Event Player.ButtonColorGrid[8];
					Global._arrayConstructor[17] = Color(White);
					Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
				End;
			Else If(Event Player.menuXIndex == 1 && Event Player.menuYIndex == 2);
				If(Event Player.selectedBot.playbackOffset <= 0);
					Abort;
				End;
				Event Player.selectedBot.playbackOffset -= 1;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
				Global._arrayConstructor[12] = Event Player.selectedBot.playbackOffset;
				Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
				Global._arrayConstructor = Event Player.ButtonColorGrid[8];
				Global._arrayConstructor[12] = Color(White);
				Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
				If(Event Player.selectedBot.playbackOffset == 1);
					Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
					Global._arrayConstructor[17] = Custom String("FRAME");
					Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
					Global._arrayConstructor = Event Player.ButtonColorGrid[8];
					Global._arrayConstructor[17] = Color(White);
					Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
				Else;
					Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
					Global._arrayConstructor[17] = Custom String("FRAMES");
					Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
					Global._arrayConstructor = Event Player.ButtonColorGrid[8];
					Global._arrayConstructor[17] = Color(White);
					Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
				End;
			End;
			Wait(0.016, Abort When False);
		End;
	}
}

rule("[interface/tools/ruler.ostw] Handle player setting second point")
{
	event
	{
		Subroutine;
		RulerHandleSFire;
	}

	actions
	{
		Event Player.isMovingPosition2 = True;
		Wait Until(!Is Button Held(Event Player, Button(Secondary Fire)), 99999);
		Event Player.isMovingPosition2 = False;
		Event Player.position2 = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 5 * Facing Direction Of(
			Event Player), All Players(All Teams), Event Player, True);
	}
}

rule("[interface/dummyBotsAndReplay/botPlacementModule.ostw] Handle right-click")
{
	event
	{
		Subroutine;
		BotPlacementSFire;
	}

	actions
	{
		If(!(Has Spawned(Event Player) && Is Alive(Event Player) && Event Player.currentMenuState == 0));
			Skip(8);
		End;
		Event Player.selectedControl = First Of(Sorted Array(Filtered Array(Append To Array(Mapped Array(Filtered Array(All Players(
			All Teams), Is Dummy Bot(Current Array Element) && Current Array Element.replayState == Custom String("NONE")),
			Current Array Element.positionControl), Mapped Array(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.facingControl)), Distance Between(
			Eye Position(Event Player) + Facing Direction Of(Event Player) * Distance Between(Eye Position(Event Player),
			Current Array Element[2]), Current Array Element[2]) <= 1.250), -1 * Dot Product(Facing Direction Of(Event Player),
			Direction Towards(Eye Position(Event Player), Current Array Element[2]))));
		If(Event Player.selectedControl[1] == 0 || Event Player.selectedControl[3] != 1);
			Event Player.selectedControl = Null;
			Skip(3);
		End;
		Event Player.selectedBot = First Of(Event Player.selectedControl);
		Event Player.currentMenuState = 7;
	}
}

rule("[interface/menu.ostw] Secondary fire to go back")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
	}

	actions
	{
		Abort If(Is Dummy Bot(Event Player));
		If(Event Player.currentMenuState == 0);
			If(Is Alive(Event Player) && Event Player.playerRulerState == 1);
				Call Subroutine(RulerHandleSFire);
			End;
			If(Event Player.botControlMode == 1);
				Call Subroutine(BotPlacementSFire);
			End;
			Abort;
		End;
		If(Event Player.currentMenuState == 1);
			Event Player.currentMenuState = 0;
			Abort;
		End;
		If(Array Contains(Array(3, 4, 5, 6, 10), Event Player.currentMenuState));
			Event Player.currentMenuState = 1;
			Abort;
		End;
		If(Event Player.currentMenuState == 2);
			Event Player.confirmationState = 2;
			Abort;
		End;
		If(Array Contains(Array(9, 8), Event Player.currentMenuState));
			Event Player.currentMenuState = 7;
			Abort;
		End;
		If(Event Player.currentMenuState == 7);
			"We need to clear the selected control so that the instructions are shown again"
			Event Player.selectedControl = Null;
			Event Player.currentMenuState = 0;
			Abort;
		End;
	}
}

rule("[interface/menuDefinitions.ostw | SUB] Zero row and column offsets")
{
	event
	{
		Subroutine;
		zeroOffsets;
	}

	actions
	{
		Event Player._extendedPlayerCollection[0] = 0;
		Event Player._extendedPlayerCollection[1] = 0;
	}
}

rule("[interface/menuDefinitions.ostw | SUB] Apply current offsets")
{
	event
	{
		Subroutine;
		applyOffsets;
	}

	actions
	{
		Event Player.menuXIndex = ((Event Player.menuXIndex + Event Player._extendedPlayerCollection[1]) % 5 + 5) % 5;
		Event Player.menuYIndex = ((Event Player.menuYIndex + First Of(Event Player._extendedPlayerCollection)) % 6 + 6) % 6;
	}
}

rule("[interface/menuDefinitions.ostw | SUB] Find first item to the left")
{
	event
	{
		Subroutine;
		findLeft;
	}

	actions
	{
		Call Subroutine(zeroOffsets);
		While(Absolute Value(First Of(Event Player._extendedPlayerCollection)) < 3);
			Event Player._extendedPlayerCollection[1] = -1;
			While(Absolute Value(Event Player._extendedPlayerCollection[1]) < 5);
				"If item here, shift menu selection to the new item"
				If(Global.ButtonActionGrid[Event Player.currentMenuState][(Event Player.menuYIndex + First Of(
					Event Player._extendedPlayerCollection)) * 5 + ((Event Player.menuXIndex + Event Player._extendedPlayerCollection[1]) % 5 + 5)
					% 5] != 0);
					Call Subroutine(applyOffsets);
					Skip(8);
				End;
				Event Player._extendedPlayerCollection[1] -= 1;
			End;
			If(First Of(Event Player._extendedPlayerCollection) >= 0);
				Event Player._extendedPlayerCollection[0] += 1;
			End;
			Event Player._extendedPlayerCollection[0] = First Of(Event Player._extendedPlayerCollection) * -1;
		End;
	}
}

rule("[interface/menuDefinitions.ostw | SUB] Find first item to the right")
{
	event
	{
		Subroutine;
		findRight;
	}

	actions
	{
		Call Subroutine(zeroOffsets);
		While(Absolute Value(First Of(Event Player._extendedPlayerCollection)) < 3);
			Event Player._extendedPlayerCollection[1] = 1;
			While(Event Player._extendedPlayerCollection[1] < 5);
				"If item here, shift menu selection to the new item"
				If(Global.ButtonActionGrid[Event Player.currentMenuState][(Event Player.menuYIndex + First Of(
					Event Player._extendedPlayerCollection)) * 5 + ((Event Player.menuXIndex + Event Player._extendedPlayerCollection[1]) % 5 + 5)
					% 5] != 0);
					Call Subroutine(applyOffsets);
					Skip(8);
				End;
				Event Player._extendedPlayerCollection[1] += 1;
			End;
			If(First Of(Event Player._extendedPlayerCollection) >= 0);
				Event Player._extendedPlayerCollection[0] += 1;
			End;
			Event Player._extendedPlayerCollection[0] = First Of(Event Player._extendedPlayerCollection) * -1;
		End;
	}
}

rule("[interface/menu.ostw] Menu left-right")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.currentMenuState != 0;
		Absolute Value(X Component Of(Throttle Of(Event Player))) > 0.500;
	}

	actions
	{
		If(Event Player.currentMenuState == 9);
			"The left-right function does nothing in this menu page"
			Abort;
		End;
		If(Event Player.currentMenuState == 10);
			"Set the current config item"
			If(Event Player.menuYIndex == 1);
				If(X Component Of(Throttle Of(Event Player)) > 0);
					Event Player.currentConfigSelection = Event Player.currentConfigSelection - 1;
					If(Event Player.currentConfigSelection < 0);
						Event Player.currentConfigSelection = 8;
					End;
				Else;
					Event Player.currentConfigSelection = Event Player.currentConfigSelection + 1;
					If(Event Player.currentConfigSelection >= 9);
						Event Player.currentConfigSelection = 0;
					End;
				End;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[7] = Array(Custom String("HPS/DPS Meter Optimization"), Custom String("Auto-Regen Delay"), Custom String(
					"Button Spam Period"), Custom String("Slow Motion Speed"), Custom String("Interact Destroys Deployables In Replay"),
					Custom String("Auto Enable Slow-Mo During Recording"), Custom String("Loop Replay Playback"), Custom String(
					"Show Replay Timecode"), Custom String("Quick Actions Enabled"))[Event Player.currentConfigSelection];
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(Array(35, 0, 4, 8, 12, 16, 20, 24, 28, 32)[Index Of Array Value(Array(0, 1, 2, 3, 4, 5, 6, 7, 8),
					Event Player.currentConfigSelection) + 1]);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.OptimizeMetricsForOverTime ? Custom String("Over Time") : Custom String("Normal");
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(31);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.AUTO_REGEN_DELAY;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(27);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.BUTTON_SPAM_PERIOD;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(23);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.SLOW_MOTION_SPEED;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(19);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.interactDestroysDeployableCompen;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(15);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.RECORD_IN_SLOW_MOTION;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(11);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.SHOULD_LOOP_CLIP;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(7);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.SHOW_REPLAY_TIMECODES;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(3);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.TRIGGERS_ENABLED;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(198);
			End;
			"Modify the current config item"
			If(X Component Of(Throttle Of(Event Player)) > 0);
				Skip(Array(96, 0, 5, 28, 51, 72, 77, 82, 87, 92)[Index Of Array Value(Array(0, 1, 2, 3, 4, 5, 6, 7, 8),
					Event Player.currentConfigSelection) + 1]);
				Global.OptimizeMetricsForOverTime = !Global.OptimizeMetricsForOverTime;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.OptimizeMetricsForOverTime ? Custom String("Over Time") : Custom String("Normal");
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(91);
				If(Global.AUTO_REGEN_DELAY <= 0.100);
					Skip(89);
				End;
				Global.AUTO_REGEN_DELAY -= Is Button Held(Event Player, Button(Ability 1)) ? 1 : 0.100;
				Global.AUTO_REGEN_DELAY = Max(Global.AUTO_REGEN_DELAY, 0.100);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.AUTO_REGEN_DELAY;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Event Player.tempMenuXIndex = Event Player.menuXIndex;
				Event Player.tempMenuYIndex = Event Player.menuYIndex;
				Wait(Global.activeModifications[7] ? 0.250 * Global.SLOW_MOTION_SPEED / 100 : 0.250, Abort When False);
				While(Event Player.currentMenuState == 10 && X Component Of(Throttle Of(Event Player))
					> 0 && Event Player.menuXIndex == Event Player.tempMenuXIndex && Event Player.menuYIndex == Event Player.tempMenuYIndex);
					If(Global.AUTO_REGEN_DELAY <= 0.100);
						Abort;
					End;
					Global.AUTO_REGEN_DELAY -= Is Button Held(Event Player, Button(Ability 1)) ? 1 : 0.100;
					Global.AUTO_REGEN_DELAY = Max(Global.AUTO_REGEN_DELAY, 0.100);
					Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
					Global._arrayConstructor[12] = Global.AUTO_REGEN_DELAY;
					Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
					Wait(0.064, Abort When False);
				End;
				Skip(68);
				If(Global.BUTTON_SPAM_PERIOD <= 0.100);
					Skip(66);
				End;
				Global.BUTTON_SPAM_PERIOD -= Is Button Held(Event Player, Button(Ability 1)) ? 1 : 0.100;
				Global.BUTTON_SPAM_PERIOD = Max(Global.BUTTON_SPAM_PERIOD, 0.100);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.BUTTON_SPAM_PERIOD;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Event Player.tempMenuXIndex = Event Player.menuXIndex;
				Event Player.tempMenuYIndex = Event Player.menuYIndex;
				Wait(Global.activeModifications[7] ? 0.250 * Global.SLOW_MOTION_SPEED / 100 : 0.250, Abort When False);
				While(Event Player.currentMenuState == 10 && X Component Of(Throttle Of(Event Player))
					> 0 && Event Player.menuXIndex == Event Player.tempMenuXIndex && Event Player.menuYIndex == Event Player.tempMenuYIndex);
					If(Global.BUTTON_SPAM_PERIOD <= 0.100);
						Abort;
					End;
					Global.BUTTON_SPAM_PERIOD -= Is Button Held(Event Player, Button(Ability 1)) ? 1 : 0.100;
					Global.BUTTON_SPAM_PERIOD = Max(Global.BUTTON_SPAM_PERIOD, 0.100);
					Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
					Global._arrayConstructor[12] = Global.BUTTON_SPAM_PERIOD;
					Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
					Wait(0.064, Abort When False);
				End;
				Skip(45);
				If(Global.SLOW_MOTION_SPEED <= 10);
					Skip(43);
				End;
				Global.SLOW_MOTION_SPEED -= 5;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.SLOW_MOTION_SPEED;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Event Player.tempMenuXIndex = Event Player.menuXIndex;
				Event Player.tempMenuYIndex = Event Player.menuYIndex;
				Wait(Global.activeModifications[7] ? 0.250 * Global.SLOW_MOTION_SPEED / 100 : 0.250, Abort When False);
				While(Event Player.currentMenuState == 10 && X Component Of(Throttle Of(Event Player))
					> 0 && Event Player.menuXIndex == Event Player.tempMenuXIndex && Event Player.menuYIndex == Event Player.tempMenuYIndex);
					If(Global.SLOW_MOTION_SPEED <= 10);
						Abort;
					End;
					Global.SLOW_MOTION_SPEED -= 5;
					Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
					Global._arrayConstructor[12] = Global.SLOW_MOTION_SPEED;
					Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
					Wait(Is Button Held(Event Player, Button(Ability 1)) ? 0.064 : 0.100, Abort When False);
				End;
				Skip(24);
				Global.interactDestroysDeployableCompen = !Global.interactDestroysDeployableCompen;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.interactDestroysDeployableCompen;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(19);
				Global.RECORD_IN_SLOW_MOTION = !Global.RECORD_IN_SLOW_MOTION;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.RECORD_IN_SLOW_MOTION;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(14);
				Global.SHOULD_LOOP_CLIP = !Global.SHOULD_LOOP_CLIP;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.SHOULD_LOOP_CLIP;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(9);
				Global.SHOW_REPLAY_TIMECODES = !Global.SHOW_REPLAY_TIMECODES;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.SHOW_REPLAY_TIMECODES;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(4);
				Global.TRIGGERS_ENABLED = !Global.TRIGGERS_ENABLED;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.TRIGGERS_ENABLED;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
			Else;
				Skip(Array(96, 0, 5, 28, 51, 72, 77, 82, 87, 92)[Index Of Array Value(Array(0, 1, 2, 3, 4, 5, 6, 7, 8),
					Event Player.currentConfigSelection) + 1]);
				Global.OptimizeMetricsForOverTime = !Global.OptimizeMetricsForOverTime;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.OptimizeMetricsForOverTime ? Custom String("Over Time") : Custom String("Normal");
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(91);
				If(Global.AUTO_REGEN_DELAY >= 30);
					Skip(89);
				End;
				Global.AUTO_REGEN_DELAY += Is Button Held(Event Player, Button(Ability 1)) ? 1 : 0.100;
				Global.AUTO_REGEN_DELAY = Min(Global.AUTO_REGEN_DELAY, 30);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.AUTO_REGEN_DELAY;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Event Player.tempMenuXIndex = Event Player.menuXIndex;
				Event Player.tempMenuYIndex = Event Player.menuYIndex;
				Wait(Global.activeModifications[7] ? 0.250 * Global.SLOW_MOTION_SPEED / 100 : 0.250, Abort When False);
				While(Event Player.currentMenuState == 10 && X Component Of(Throttle Of(Event Player))
					< 0 && Event Player.menuXIndex == Event Player.tempMenuXIndex && Event Player.menuYIndex == Event Player.tempMenuYIndex);
					If(Global.AUTO_REGEN_DELAY >= 30);
						Abort;
					End;
					Global.AUTO_REGEN_DELAY += Is Button Held(Event Player, Button(Ability 1)) ? 1 : 0.100;
					Global.AUTO_REGEN_DELAY = Min(Global.AUTO_REGEN_DELAY, 30);
					Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
					Global._arrayConstructor[12] = Global.AUTO_REGEN_DELAY;
					Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
					Wait(0.064, Abort When False);
				End;
				Skip(68);
				If(Global.BUTTON_SPAM_PERIOD >= 30);
					Skip(66);
				End;
				Global.BUTTON_SPAM_PERIOD += Is Button Held(Event Player, Button(Ability 1)) ? 1 : 0.100;
				Global.BUTTON_SPAM_PERIOD = Min(Global.BUTTON_SPAM_PERIOD, 30);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.BUTTON_SPAM_PERIOD;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Event Player.tempMenuXIndex = Event Player.menuXIndex;
				Event Player.tempMenuYIndex = Event Player.menuYIndex;
				Wait(Global.activeModifications[7] ? 0.250 * Global.SLOW_MOTION_SPEED / 100 : 0.250, Abort When False);
				While(Event Player.currentMenuState == 10 && X Component Of(Throttle Of(Event Player))
					< 0 && Event Player.menuXIndex == Event Player.tempMenuXIndex && Event Player.menuYIndex == Event Player.tempMenuYIndex);
					If(Global.BUTTON_SPAM_PERIOD >= 30);
						Abort;
					End;
					Global.BUTTON_SPAM_PERIOD += Is Button Held(Event Player, Button(Ability 1)) ? 1 : 0.100;
					Global.BUTTON_SPAM_PERIOD = Min(Global.BUTTON_SPAM_PERIOD, 30);
					Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
					Global._arrayConstructor[12] = Global.BUTTON_SPAM_PERIOD;
					Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
					Wait(0.064, Abort When False);
				End;
				Skip(45);
				If(Global.SLOW_MOTION_SPEED >= 100);
					Skip(43);
				End;
				Global.SLOW_MOTION_SPEED += 5;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.SLOW_MOTION_SPEED;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Event Player.tempMenuXIndex = Event Player.menuXIndex;
				Event Player.tempMenuYIndex = Event Player.menuYIndex;
				Wait(Global.activeModifications[7] ? 0.250 * Global.SLOW_MOTION_SPEED / 100 : 0.250, Abort When False);
				While(Event Player.currentMenuState == 10 && X Component Of(Throttle Of(Event Player))
					< 0 && Event Player.menuXIndex == Event Player.tempMenuXIndex && Event Player.menuYIndex == Event Player.tempMenuYIndex);
					If(Global.SLOW_MOTION_SPEED >= 100);
						Abort;
					End;
					Global.SLOW_MOTION_SPEED += 5;
					Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
					Global._arrayConstructor[12] = Global.SLOW_MOTION_SPEED;
					Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
					Wait(Is Button Held(Event Player, Button(Ability 1)) ? 0.064 : 0.100, Abort When False);
				End;
				Skip(24);
				Global.interactDestroysDeployableCompen = !Global.interactDestroysDeployableCompen;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.interactDestroysDeployableCompen;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(19);
				Global.RECORD_IN_SLOW_MOTION = !Global.RECORD_IN_SLOW_MOTION;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.RECORD_IN_SLOW_MOTION;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(14);
				Global.SHOULD_LOOP_CLIP = !Global.SHOULD_LOOP_CLIP;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.SHOULD_LOOP_CLIP;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(9);
				Global.SHOW_REPLAY_TIMECODES = !Global.SHOW_REPLAY_TIMECODES;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.SHOW_REPLAY_TIMECODES;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Skip(4);
				Global.TRIGGERS_ENABLED = !Global.TRIGGERS_ENABLED;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[12] = Global.TRIGGERS_ENABLED;
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
			End;
			Abort;
		End;
		If(X Component Of(Throttle Of(Event Player)) > 0);
			Call Subroutine(findLeft);
		Else;
			Call Subroutine(findRight);
		End;
	}
}

rule("[interface/menuDefinitions.ostw | SUB] Find first item upwards")
{
	event
	{
		Subroutine;
		findUp;
	}

	actions
	{
		Call Subroutine(zeroOffsets);
		While(Absolute Value(Event Player._extendedPlayerCollection[1]) < 2.500);
			Event Player._extendedPlayerCollection[0] = -1;
			While(Absolute Value(First Of(Event Player._extendedPlayerCollection)) < 6);
				"If item here, shift menu selection to the new item"
				If(Global.ButtonActionGrid[Event Player.currentMenuState][((Event Player.menuYIndex + First Of(
					Event Player._extendedPlayerCollection)) % 6 + 6)
					% 6 * 5 + Event Player.menuXIndex + Event Player._extendedPlayerCollection[1]] != 0);
					Call Subroutine(applyOffsets);
					Skip(8);
				End;
				Event Player._extendedPlayerCollection[0] -= 1;
			End;
			If(Event Player._extendedPlayerCollection[1] >= 0);
				Event Player._extendedPlayerCollection[1] += 1;
			End;
			Event Player._extendedPlayerCollection[1] = Event Player._extendedPlayerCollection[1] * -1;
		End;
	}
}

rule("interface/menuDefinitions.ostw | [SUB] Find first item downwards")
{
	event
	{
		Subroutine;
		findDown;
	}

	actions
	{
		Call Subroutine(zeroOffsets);
		While(Absolute Value(Event Player._extendedPlayerCollection[1]) < 2.500);
			Event Player._extendedPlayerCollection[0] = 1;
			While(First Of(Event Player._extendedPlayerCollection) < 6);
				"If item here, shift menu selection to the new item"
				If(Global.ButtonActionGrid[Event Player.currentMenuState][((Event Player.menuYIndex + First Of(
					Event Player._extendedPlayerCollection)) % 6 + 6)
					% 6 * 5 + Event Player.menuXIndex + Event Player._extendedPlayerCollection[1]] != 0);
					Call Subroutine(applyOffsets);
					Skip(8);
				End;
				Event Player._extendedPlayerCollection[0] += 1;
			End;
			If(Event Player._extendedPlayerCollection[1] >= 0);
				Event Player._extendedPlayerCollection[1] += 1;
			End;
			Event Player._extendedPlayerCollection[1] = Event Player._extendedPlayerCollection[1] * -1;
		End;
	}
}

rule("[interface/menu.ostw] Menu up-down")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.currentMenuState != 0;
		Absolute Value(Z Component Of(Throttle Of(Event Player))) > 0.500;
	}

	actions
	{
		If(Event Player.currentMenuState == 9);
			If(Z Component Of(Throttle Of(Event Player)) > 0.500);
				Event Player.menuYIndex -= 1;
				If(Event Player.menuYIndex < 0);
					Event Player.menuYIndex = Count Of(Global.AllButtons) - 1;
				End;
			Else;
				Event Player.menuYIndex += 1;
				If(Event Player.menuYIndex >= Count Of(Global.AllButtons));
					Event Player.menuYIndex = 0;
				End;
			End;
			Abort;
		End;
		If(Event Player.currentMenuState == 10);
			If(Z Component Of(Throttle Of(Event Player)) > 0 && Event Player.menuYIndex == 2);
				Event Player.menuYIndex = 1;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[6] = Custom String("◀");
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[8] = Custom String("▶");
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[11] = Custom String("");
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[13] = Custom String("");
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
			Else;
				Event Player.menuYIndex = 2;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[6] = Custom String("");
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[8] = Custom String("");
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[11] = Custom String("{0}{1}", Custom String("                      "), Custom String("◀"));
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[10];
				Global._arrayConstructor[13] = Custom String("{0}{1}", Custom String("▶"), Custom String("                      "));
				Event Player.ButtonLabelGrid[10] = Global._arrayConstructor;
			End;
			Abort;
		End;
		If(Z Component Of(Throttle Of(Event Player)) > 0);
			Call Subroutine(findUp);
		Else;
			Call Subroutine(findDown);
		End;
	}
}

rule("[lib/player/buttonControl.del] MONKEY PATCH - For Winston, disable secondary fire instead of just disallowing button (because disallow doesn't work on Winston)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Secondary Fire))] > 0;
		Hero Of(Event Player) == Hero(Winston);
	}

	actions
	{
		Set Secondary Fire Enabled(Event Player, False);
		Wait Until(Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Secondary Fire))] == 0 || Hero Of(Event Player)
			!= Hero(Winston), 99999);
		Set Secondary Fire Enabled(Event Player, True);
	}
}

rule("[lib/player/buttonControl.del] MONKEY PATCH - For Mauga, disable primary fire instead of just disallowing button (because disallow doesn't work on Winston)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Primary Fire))] > 0;
		Hero Of(Event Player) == Hero(Mauga);
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, False);
		Wait Until(Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Primary Fire))] == 0 || Hero Of(Event Player)
			!= Hero(Mauga), 99999);
		Set Primary Fire Enabled(Event Player, True);
	}
}

rule("[lib/player/buttonControl.del] MONKEY PATCH - For Mauga, disable secondary fire instead of just disallowing button (because disallow doesn't work on Mauga)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Secondary Fire))] > 0;
		Hero Of(Event Player) == Hero(Mauga);
	}

	actions
	{
		Set Secondary Fire Enabled(Event Player, False);
		Wait Until(Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Secondary Fire))] == 0 || Hero Of(Event Player)
			!= Hero(Mauga), 99999);
		Set Secondary Fire Enabled(Event Player, True);
	}
}

rule("[interface/toolsMenu.ostw] Handle toolsActionID")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.toolsActionID != 0;
	}

	actions
	{
		Skip(Array(191, 0, 24, 40, 58, 65, 68, 92, 107, 133, 160, 170)[Index Of Array Value(Array(1, 2, 3, 6, 10, 4, 5, 7, 8, 9, 11),
			Event Player.toolsActionID) + 1]);
		"[CASE] SET_RESPAWN"
		If(First Of(Event Player._extendedPlayerCollection[2]) == Null);
			Event Player._extendedPlayerCollection[2] = Array(Position Of(Event Player), Eye Position(Event Player), Facing Direction Of(
				Event Player));
			Play Effect(Event Player, Buff Impact Sound, Null, Event Player, 100);
			Small Message(Event Player, Custom String("Respawn point set!"));
			"Set new button look"
			Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
			Global._arrayConstructor[6] = Custom String("Clear Respawn Point");
			Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[5];
			Global._arrayConstructor[6] = Color(Gray);
			Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		Else;
			Global._arrayConstructor = Event Player._extendedPlayerCollection[2];
			Global._arrayConstructor[0] = Null;
			Event Player._extendedPlayerCollection[2] = Global._arrayConstructor;
			Play Effect(Event Player, Debuff Impact Sound, Null, Event Player, 100);
			Small Message(Event Player, Custom String("Respawn point cleared"));
			"Set new button look"
			Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
			Global._arrayConstructor[6] = Custom String("Set Respawn Point");
			Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[5];
			Global._arrayConstructor[6] = Custom Color(80, 187, 217, 255);
			Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		End;
		Skip(167);
		"[CASE] CHANGE_HERO"
		Set Player Allowed Heroes(Event Player, Remove From Array(Allowed Heroes(Event Player), Hero Of(Event Player)));
		Wait Until(!Has Spawned(Event Player), 3);
		Reset Player Hero Availability(Event Player);
		Wait Until(Has Spawned(Event Player), 9999);
		Stop Forcing Player Position(Event Player);
		Teleport(Event Player, First Of(Event Player.menuActivationPoint));
		Stop Facing(Event Player);
		Wait(0.016, Ignore Condition);
		Set Facing(Event Player, Event Player.menuActivationPoint[2], To World);
		"Because for SOME REASON setting FACING and TELEPORTING in the SAME FRAME cancels the TELEPORT"
		Wait(0.032, Ignore Condition);
		Start Facing(Event Player, Event Player.menuActivationPoint[2], 1000, To World, Direction and Turn Rate);
		Wait(0.016, Ignore Condition);
		Wait Until(Angle Between Vectors(Facing Direction Of(Event Player), Event Player.menuActivationPoint[2]) < 0.100, 0.250);
		Stop Facing(Event Player);
		Event Player.currentMenuState = 0;
		Skip(151);
		"[CASE] NO_CLIP"
		If(Event Player.isNoClipActive);
			"Set new button look"
			Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
			Global._arrayConstructor[8] = Custom String("Enable NoClip");
			Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[5];
			Global._arrayConstructor[8] = Color(Green);
			Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		Else;
			"Set new button look"
			Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
			Global._arrayConstructor[8] = Custom String("Disable NoClip");
			Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[5];
			Global._arrayConstructor[8] = Color(Red);
			Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		End;
		Event Player.isNoClipActive = !Event Player.isNoClipActive;
		Event Player.currentMenuState = 0;
		Skip(133);
		"[CASE] TOGGLE_PAUSE"
		If(Global.isTimePaused);
			Unpause Match Time;
		Else;
			Pause Match Time;
		End;
		Global.isTimePaused = !Global.isTimePaused;
		Skip(126);
		"[CASE] RETURN_TO_ASSEMBLING_HEROES"
		Go To Assemble Heroes;
		Event Player.currentMenuState = 0;
		Skip(123);
		"[CASE] FAST_FORWARD"
		If(Is In Setup);
			Set Match Time(0);
		Else If(Is Game In Progress);
			If(Current Game Mode == Game Mode(Control) || Current Game Mode == Game Mode(Flashpoint));
				Declare Round Victory(Team Of(Event Player));
			Else;
				Set Match Time(0);
			End;
		Else;
			Small Message(Event Player, Custom String(" Current phase can't be skipped?"));
			Play Effect(Event Player, Debuff Impact Sound, Null, Event Player, 100);
			Skip(11);
		"Otherwise, logic to end round"
		End;
		Event Player.currentMenuState = 0;
		If(Global.isTimePaused);
			Unpause Match Time;
			Global.isTimePaused = False;
			Wait(0.032, Ignore Condition);
			If(!Global.isTimePaused);
				Pause Match Time;
			End;
			Global.isTimePaused = True;
		End;
		Skip(99);
		"[CASE] END_GAME"
		Event Player.actionToConfirm = Custom String("end the game");
		Event Player.confirmationState = 0;
		Event Player.currentMenuState = 2;
		Wait Until(Event Player.confirmationState != 0, 1000000);
		If(Event Player.confirmationState == 1);
			Declare Match Draw;
			Wait Until(Is Match Complete, 3);
			If(Is Match Complete);
				Event Player.currentMenuState = 0;
				Skip(4);
			End;
			Small Message(Event Player, Custom String("Can't seem to end the game right now. Try again in a bit!"));
		End;
		Event Player.currentMenuState = 5;
		Skip(84);
		Skip(Array(24, 0, 9, 17)[Index Of Array Value(Array(0, 1, 2), Event Player.playerRulerState) + 1]);
		"[CASE] RULER"
		Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
		Global._arrayConstructor[11] = Custom String("Freeze Ruler");
		Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[5];
		Global._arrayConstructor[11] = Color(Orange);
		Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		Event Player.playerRulerState = 1;
		Event Player.currentMenuState = 0;
		Skip(15);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
		Global._arrayConstructor[11] = Custom String("Hide Ruler");
		Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[5];
		Global._arrayConstructor[11] = Custom Color(200, 50, 50, 255);
		Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		Event Player.playerRulerState = 2;
		Skip(7);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
		Global._arrayConstructor[11] = Custom String("Place Ruler");
		Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[5];
		Global._arrayConstructor[11] = Color(Yellow);
		Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		Event Player.playerRulerState = 0;
		Skip(58);
		Skip(Array(25, 0, 9, 18)[Index Of Array Value(Array(0, 1, 2), Event Player.thirdPersonState) + 1]);
		"[CASE] THIRD_PERSON"
		Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
		Global._arrayConstructor[13] = Custom String("Set 3P Camera Pos");
		Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[5];
		Global._arrayConstructor[13] = Color(Green);
		Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		Event Player.thirdPersonState = 1;
		Event Player.currentMenuState = 0;
		Skip(16);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
		Global._arrayConstructor[13] = Custom String("Stop 3rd Person");
		Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[5];
		Global._arrayConstructor[13] = Color(Red);
		Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		Event Player.thirdPersonState = 2;
		Event Player.currentMenuState = 0;
		Skip(7);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
		Global._arrayConstructor[13] = Custom String("Enable 3rd Person");
		Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[5];
		Global._arrayConstructor[13] = Color(Orange);
		Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		Event Player.thirdPersonState = 0;
		Skip(31);
		"[CASE] UNLOCK_ALL_BUTTONS"
		Event Player.buttonLocks = Mapped Array(Event Player.buttonLocks, 0);
		Global.player = Event Player;
		Call Subroutine(UpdatePlayerButtonStatus);
		Event Player.buttonLocks = Mapped Array(Event Player.buttonLocks, Current Array Element + 1);
		Global.player = Event Player;
		Call Subroutine(UpdatePlayerButtonStatus);
		Event Player.phasedOutLockCount = 1;
		Event Player.invisibilityLockCount = 1;
		Event Player.currentMenuState = 0;
		Skip(21);
		"[CASE] TOGGLE_INVIS"
		If(Event Player._extendedPlayerCollection[3]);
			Event Player.invisibilityLockCount -= 1;
			Event Player.phasedOutLockCount -= 1;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
			Global._arrayConstructor[2] = Custom String("Enable Invisibility");
			Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[5];
			Global._arrayConstructor[2] = Color(Violet);
			Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		Else;
			Event Player.invisibilityLockCount += 1;
			Event Player.phasedOutLockCount += 1;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
			Global._arrayConstructor[2] = Custom String("Disable Invisibility");
			Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[5];
			Global._arrayConstructor[2] = Color(Red);
			Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		End;
		Event Player._extendedPlayerCollection[3] = !Event Player._extendedPlayerCollection[3];
		Event Player.currentMenuState = 0;
	}
}

rule("[interface/toolsMenu.ostw] If respawn point is set, and player dies, respawn them at the respawn point")
{
	event
	{
		Player Died;
		All;
		All;
	}

	actions
	{
		Wait Until(Is Alive(Event Player), 9999);
		If(First Of(Event Player._extendedPlayerCollection[2]) != Null);
			Teleport(Event Player, First Of(Event Player._extendedPlayerCollection[2]));
			Stop Facing(Event Player);
			Wait(0.016, Ignore Condition);
			Set Facing(Event Player, Event Player._extendedPlayerCollection[2][2], To World);
			"Because for SOME REASON setting FACING and TELEPORTING in the SAME FRAME cancels the TELEPORT"
			Wait(0.032, Ignore Condition);
			Start Facing(Event Player, Event Player._extendedPlayerCollection[2][2], 1000, To World, Direction and Turn Rate);
			Wait(0.016, Ignore Condition);
			Wait Until(Angle Between Vectors(Facing Direction Of(Event Player), Event Player._extendedPlayerCollection[2][2]) < 0.100, 0.250);
			Stop Facing(Event Player);
		Else If(First Of(Event Player.replayResetPoint) != Null);
			Teleport(Event Player, First Of(Event Player.replayResetPoint));
			Stop Facing(Event Player);
			Wait(0.016, Ignore Condition);
			Set Facing(Event Player, Event Player.replayResetPoint[2], To World);
			"Because for SOME REASON setting FACING and TELEPORTING in the SAME FRAME cancels the TELEPORT"
			Wait(0.032, Ignore Condition);
			Start Facing(Event Player, Event Player.replayResetPoint[2], 1000, To World, Direction and Turn Rate);
			Wait(0.016, Ignore Condition);
			Wait Until(Angle Between Vectors(Facing Direction Of(Event Player), Event Player.replayResetPoint[2]) < 0.100, 0.250);
			Stop Facing(Event Player);
		End;
	}
}

rule("[interface/toolsMenu.ostw] Keep pause button appearance updated for everyone - Unpause")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.isTimePaused == True;
	}

	actions
	{
		Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
		Global._arrayConstructor[16] = Custom String("Unpause Match Time");
		Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[5];
		Global._arrayConstructor[16] = Custom Color(50, 220, 27, 255);
		Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
	}
}

rule("[interface/toolsMenu.ostw] Keep pause button appearance update for everyone - Pause")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		!Global.isTimePaused == True;
	}

	actions
	{
		Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
		Global._arrayConstructor[16] = Custom String("Pause Match Time");
		Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[5];
		Global._arrayConstructor[16] = Color(Purple);
		Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
	}
}

rule("[interface/toolsMenu.ostw] When in setup, change fast-forward button to skip setup")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is In Setup == True;
	}

	actions
	{
		Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
		Global._arrayConstructor[17] = Custom String("Skip Setup");
		Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[5];
		Global._arrayConstructor[17] = Color(Aqua);
		Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
	}
}

rule("[interface/toolsMenu.ostw] When game is in progress, change fast-forward button to end round")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
		Global._arrayConstructor[17] = Custom String("End Round");
		Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[5];
		Global._arrayConstructor[17] = Custom Color(212, 62, 62, 255);
		Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
	}
}

rule("Initiate confirmation dialog")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.currentMenuState == 2;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
	}

	actions
	{
		Event Player.menuXIndex = 1;
		Event Player.menuYIndex = 0;
	}
}

rule("[interface/tools/ruler.ostw] Create help text for ruler")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create HUD Text(Array Contains(All Players(All Teams), Local Player)
			&& Local Player.currentMenuState == 0 && Local Player.playerRulerState == 1 ? Local Player : Null, Null, Custom String(
			"Placing Ruler Endpoints"), Custom String("[{0}] Move Blue Point\n[{1}] Move Orange Point", Input Binding String(Button(
			Primary Fire)), Input Binding String(Button(Secondary Fire))), Right, 0, Color(White), Color(Yellow), Color(White),
			Visible To and String, Visible Never);
	}
}

rule("[interface/tools/ruler.ostw] When ruler is active, disable primary + secondary until ruler placement is not active")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.playerRulerState == 1;
	}

	actions
	{
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Primary Fire))] += 1;
		Disallow Button(Event Player, Button(Primary Fire));
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Secondary Fire))] += 1;
		Disallow Button(Event Player, Button(Secondary Fire));
		Wait Until(Event Player.playerRulerState != 1, 99999);
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Primary Fire))] -= 1;
		If(Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Primary Fire))] == 0);
			Allow Button(Event Player, Button(Primary Fire));
		End;
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Secondary Fire))] -= 1;
		If(Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Secondary Fire))] == 0);
			Allow Button(Event Player, Button(Secondary Fire));
		End;
	}
}

rule("[interface/tools/ruler.ostw] Manage ruler visual effects lifecycle")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.playerRulerState != 0;
	}

	actions
	{
		"Need to initialize ruler if it hasn't been placed before"
		If(Event Player.position1 == Null);
			Event Player.position1 = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 5 * Facing Direction Of(
				Event Player) + World Vector Of(Left, Event Player, Rotation), Null, Null, False);
		End;
		If(Event Player.position2 == Null);
			Event Player.position2 = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + 5 * Facing Direction Of(
				Event Player) + World Vector Of(Right, Event Player, Rotation), Null, Null, False);
		End;
		Create Effect(All Players(All Teams), Sphere, Color(Blue), Update Every Frame(
			Event Player.isMovingPosition1 ? Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ 5 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True) : Event Player.position1), 0.200,
			Visible To Position and Radius);
		Event Player.rulerEffects[0] = Last Created Entity;
		Create Effect(All Players(All Teams), Sphere, Color(Orange), Update Every Frame(
			Event Player.isMovingPosition2 ? Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ 5 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True) : Event Player.position2), 0.200,
			Visible To Position and Radius);
		Event Player.rulerEffects[1] = Last Created Entity;
		Create Beam Effect(All Players(All Teams), Grapple Beam, Update Every Frame(Event Player.isMovingPosition1 ? Ray Cast Hit Position(
			Eye Position(Event Player), Eye Position(Event Player) + 5 * Facing Direction Of(Event Player), All Players(All Teams),
			Event Player, True) : Event Player.position1), Update Every Frame(Event Player.isMovingPosition2 ? Ray Cast Hit Position(
			Eye Position(Event Player), Eye Position(Event Player) + 5 * Facing Direction Of(Event Player), All Players(All Teams),
			Event Player, True) : Event Player.position2), Null, Visible To Position and Radius);
		Event Player.rulerEffects[2] = Last Created Entity;
		Create In-World Text(Filtered Array(All Players(All Teams), Current Array Element.currentMenuState == 0), Custom String("{0}m\n",
			Distance Between(Event Player.isMovingPosition1 ? Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ 5 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True) : Event Player.position1,
			Event Player.isMovingPosition2 ? Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ 5 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True) : Event Player.position2)),
			Update Every Frame(((Event Player.isMovingPosition1 ? Ray Cast Hit Position(Eye Position(Event Player), Eye Position(
			Event Player) + 5 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True) : Event Player.position1)
			+ (Event Player.isMovingPosition2 ? Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ 5 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True) : Event Player.position2)) / 2), 1.500,
			Do Not Clip, Visible To Position and String, Color(White), Visible Always);
		Event Player.rulerEffects[3] = Last Text ID;
		Create In-World Text(Filtered Array(All Players(All Teams), Current Array Element.currentMenuState == 0), Custom String(
			" \nLOS: {0}", Is In Line of Sight(Event Player.isMovingPosition1 ? Ray Cast Hit Position(Eye Position(Event Player),
			Eye Position(Event Player) + 5 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True)
			: Event Player.position1, Event Player.isMovingPosition2 ? Ray Cast Hit Position(Eye Position(Event Player), Eye Position(
			Event Player) + 5 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True) : Event Player.position2,
			Barriers Do Not Block LOS)), Update Every Frame(((Event Player.isMovingPosition1 ? Ray Cast Hit Position(Eye Position(
			Event Player), Eye Position(Event Player) + 5 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True)
			: Event Player.position1) + (Event Player.isMovingPosition2 ? Ray Cast Hit Position(Eye Position(Event Player), Eye Position(
			Event Player) + 5 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True) : Event Player.position2))
			/ 2), 1.500, Do Not Clip, Visible To Position String and Color, Is In Line of Sight(
			Event Player.isMovingPosition1 ? Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ 5 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True) : Event Player.position1,
			Event Player.isMovingPosition2 ? Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ 5 * Facing Direction Of(Event Player), All Players(All Teams), Event Player, True) : Event Player.position2,
			Barriers Do Not Block LOS) ? Color(Green) : Color(Red), Visible Always);
		Event Player.rulerEffects[4] = Last Text ID;
		Wait Until(Event Player.playerRulerState == 0, 99999);
		Destroy Effect(Array Slice(Event Player.rulerEffects, 0, 3));
		Destroy In-World Text(Event Player.rulerEffects[3]);
		Destroy In-World Text(Event Player.rulerEffects[4]);
	}
}

rule("[interface/tools/thirdPerson.ostw] When person is in third person and their menu state becomes closed, start third person camera")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Event Player.thirdPersonState != 0;
		!Event Player.isNoClipActive == True;
		Event Player.currentMenuState == 0;
	}

	actions
	{
		Wait(0.016, Ignore Condition);
		"Code borrowed from workshop.codes/5AXEZ"
		Start Camera(Event Player, Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + World Vector Of(
			Direction From Angles(Event Player.thirdPersonPosAngle, 0)
			* Event Player.thirdPersonDistance + Event Player.thirdPersonHeight * Up, Event Player, Rotation), All Players(All Teams),
			Event Player, False), Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + World Vector Of(
			Direction From Angles(Event Player.thirdPersonPosAngle, 0)
			* Event Player.thirdPersonDistance + Event Player.thirdPersonHeight * Up, Event Player, Rotation), All Players(All Teams),
			Event Player, False) + World Vector Of(Direction From Angles(
			Event Player.thirdPersonPosAngle - Event Player.thirdPersonFacAzim, Event Player.thirdPersonFacPolar), Event Player, Rotation),
			25);
		If(Event Player.thirdPersonState == 2);
			Start Transforming Throttle(Event Player, 1, 1, World Vector Of(Direction From Angles(
				Event Player.thirdPersonPosAngle - Event Player.thirdPersonFacAzim, Event Player.thirdPersonFacPolar), Event Player,
				Rotation));
		End;
	}
}

rule("[interface/tools/thirdPerson.ostw] Handle entering and exiting adjustment")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.thirdPersonState == 1;
	}

	actions
	{
		Event Player._extendedPlayerCollection[4] = False;
		Event Player.thirdPersonHeight = 0;
		Event Player.thirdPersonDistance = 2;
		Event Player.thirdPersonPosAngle = 0;
		Event Player.thirdPersonFacPolar = 0;
		Event Player.thirdPersonFacAzim = 180;
		Wait(0.016, Ignore Condition);
		Start Forcing Throttle(Event Player, 0.900, 1, 0.900, 1, 0.900, 1);
		Start Facing(Event Player, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), 0), 1000,
			To World, Direction and Turn Rate);
		Set Facing(Event Player, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), 0), To World);
		Set Move Speed(Event Player, 0);
		Wait(0.500, Ignore Condition);
		Stop Facing(Event Player);
		Start Forcing Throttle(Event Player, 0, 0.700, 0, 0.700, 0, 0.700);
		Event Player._extendedPlayerCollection[4] = True;
		Event Player.baseFacingDirection = Facing Direction Of(Event Player);
		Wait(0.064, Ignore Condition);
		Event Player.thirdPersonFacPolar = 0;
		Chase Player Variable At Rate(Event Player, thirdPersonFacAzim, Event Player.thirdPersonFacAzim - Angle Difference(
			Horizontal Angle From Direction(Event Player.baseFacingDirection), Horizontal Angle From Direction(Facing Direction Of(
			Event Player))), 1000, Destination and Rate);
		Chase Player Variable At Rate(Event Player, thirdPersonFacPolar, Max(-89.500, Min(
			Event Player.thirdPersonFacPolar + Angle Difference(Vertical Angle From Direction(Event Player.baseFacingDirection),
			Vertical Angle From Direction(Facing Direction Of(Event Player))), 89.500)), 1000, Destination and Rate);
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Jump))] += 1;
		Disallow Button(Event Player, Button(Jump));
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Crouch))] += 1;
		Disallow Button(Event Player, Button(Crouch));
		While(Event Player.thirdPersonState == 1);
			Wait Until(Event Player.baseFacingDirection != Update Every Frame(Facing Direction Of(Event Player))
				|| Event Player.thirdPersonState != 1, 1000000);
			If(Event Player.thirdPersonState == 1);
				Set Facing(Event Player, Event Player.baseFacingDirection, To World);
				If(Absolute Value(Event Player.thirdPersonFacAzim) > 180);
					Event Player.thirdPersonFacAzim += Event Player.thirdPersonFacAzim > 0 ? -360 : 360;
				End;
				Wait(0.150, Ignore Condition);
			End;
		End;
		Stop Forcing Throttle(Event Player);
		Stop Chasing Player Variable(Event Player, thirdPersonFacAzim);
		Stop Chasing Player Variable(Event Player, thirdPersonFacPolar);
		Set Move Speed(Event Player, 100);
		Set Aim Speed(Event Player, 100);
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Jump))] -= 1;
		If(Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Jump))] == 0);
			Allow Button(Event Player, Button(Jump));
		End;
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Crouch))] -= 1;
		If(Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Crouch))] == 0);
			Allow Button(Event Player, Button(Crouch));
		End;
		Start Transforming Throttle(Event Player, 1, 1, World Vector Of(Direction From Angles(
			Event Player.thirdPersonPosAngle - Event Player.thirdPersonFacAzim, Event Player.thirdPersonFacPolar), Event Player,
			Rotation));
	}
}

rule("[interface/tools/thirdPerson.ostw] While adjusting, use Z Component of Throttle to adjust distance")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.thirdPersonState == 1;
		Event Player._extendedPlayerCollection[4] == True;
		Is Alive(Event Player) == True;
		Event Player.currentMenuState == 0;
		Absolute Value(Z Component Of(Throttle Of(Event Player))) >= 0.500;
	}

	actions
	{
		Chase Player Variable At Rate(Event Player, thirdPersonDistance, Z Component Of(Throttle Of(Event Player)) > 0 ? 0.100 : 7, 1,
			Destination and Rate);
		Wait Until(Event Player.thirdPersonState != 1 || !Event Player._extendedPlayerCollection[4] || Is Dead(Event Player)
			|| Event Player.currentMenuState != 0 || Absolute Value(Z Component Of(Throttle Of(Event Player))) < 0.500, 1000000);
		Stop Chasing Player Variable(Event Player, thirdPersonDistance);
	}
}

rule("[interface/tools/thirdPerson.ostw] While adjusting, use X Component of Throttle to adjust angle")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.thirdPersonState == 1;
		Event Player._extendedPlayerCollection[4] == True;
		Is Alive(Event Player) == True;
		Event Player.currentMenuState == 0;
		Absolute Value(X Component Of(Throttle Of(Event Player))) >= 0.500;
	}

	actions
	{
		Chase Player Variable At Rate(Event Player, thirdPersonPosAngle, X Component Of(Throttle Of(Event Player))
			> 0 ? -1000000 : 1000000, 30, Destination and Rate);
		While(Event Player.thirdPersonState == 1 && Event Player._extendedPlayerCollection[4] && Is Alive(Event Player)
			&& Event Player.currentMenuState == 0 && Absolute Value(X Component Of(Throttle Of(Event Player))) >= 0.500);
			If(Absolute Value(Event Player.thirdPersonPosAngle) > 180);
				Event Player.thirdPersonPosAngle += Event Player.thirdPersonPosAngle > 0 ? -360 : 360;
			End;
			Wait(0.016, Ignore Condition);
		End;
		Stop Chasing Player Variable(Event Player, thirdPersonPosAngle);
	}
}

rule("[interface/tools/thirdPerson.ostw] While adjusting, use jump/crouch to increase/decrease height")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.thirdPersonState == 1;
		Event Player._extendedPlayerCollection[4] == True;
		Is Alive(Event Player) == True;
		Event Player.currentMenuState == 0;
		(Is Button Held(Event Player, Button(Jump)) || Is Button Held(Event Player, Button(Crouch))) == True;
	}

	actions
	{
		Chase Player Variable At Rate(Event Player, thirdPersonHeight, 5 * (Is Button Held(Event Player, Button(Jump))
			+ -1 * Is Button Held(Event Player, Button(Crouch))), 0.600 * Absolute Value(Is Button Held(Event Player, Button(Jump))
			+ -1 * Is Button Held(Event Player, Button(Crouch))), Destination and Rate);
		Wait Until(Event Player.thirdPersonState != 1 || !Event Player._extendedPlayerCollection[4] || Is Dead(Event Player)
			|| Event Player.currentMenuState != 0 || !(Is Button Held(Event Player, Button(Jump)) || Is Button Held(Event Player, Button(
			Crouch))), 1000);
		Stop Chasing Player Variable(Event Player, thirdPersonHeight);
	}
}

rule("[lib/player/noClip.del] Global noclip setup")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create HUD Text(Local Player.isNoClipActive && Local Player.currentMenuState == 0 ? Local Player : Null, Null, Custom String(
			"NoClip Active"), Custom String("Hold [{0}] - Move Faster", Input Binding String(Button(Reload))), Right, 1, Color(White),
			Color(Orange), Is Button Held(Local Player, Button(Reload)) ? Color(Orange) : Color(Blue), Visible To String and Color,
			Visible Never);
	}
}

rule("[lib/player/noClip.del] Engage noclip")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.isNoClipActive == True;
	}

	actions
	{
		Set Gravity(Event Player, 0);
		Disable Movement Collision With Environment(Event Player, True);
		Disable Movement Collision With Players(Event Player);
		Set Move Speed(Event Player, 0);
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Jump))] += 1;
		Disallow Button(Event Player, Button(Jump));
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Crouch))] += 1;
		Disallow Button(Event Player, Button(Crouch));
		Event Player.invisibilityLockCount += 1;
		Event Player.phasedOutLockCount += 1;
		Wait Until(!Event Player.isNoClipActive, 1000000);
		Set Gravity(Event Player, 100);
		Enable Movement Collision With Environment(Event Player);
		Enable Movement Collision With Players(Event Player);
		Set Move Speed(Event Player, 100);
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Jump))] -= 1;
		If(Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Jump))] == 0);
			Allow Button(Event Player, Button(Jump));
		End;
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Crouch))] -= 1;
		If(Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Crouch))] == 0);
			Allow Button(Event Player, Button(Crouch));
		End;
		Event Player.invisibilityLockCount -= 1;
		Event Player.phasedOutLockCount -= 1;
	}
}

rule("[lib/player/noClip.del] Noclip camera")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.isNoClipActive == True;
		Event Player.currentMenuState == 0;
	}

	actions
	{
		Wait(0.016, Ignore Condition);
		"Stopping camera is handled by the fact that noclip must be stopped by opening menu."
		Start Camera(Event Player, Update Every Frame(Eye Position(Event Player)), Update Every Frame(Eye Position(Event Player)
			+ Facing Direction Of(Event Player)), 1000);
	}
}

rule("Noclip propulsion")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.isNoClipActive == True;
		(Is Button Held(Event Player, Button(Crouch)) || Is Button Held(Event Player, Button(Jump)) || Throttle Of(Event Player)
			!= Left - Left) == True;
	}

	actions
	{
		Apply Impulse(Event Player, Velocity Of(Event Player) * -1, Speed Of(Event Player) * 0.030, To World, Incorporate Contrary Motion);
		If(!(Is Button Held(Event Player, Button(Crouch)) && Is Button Held(Event Player, Button(Jump)) && Magnitude Of(Throttle Of(
			Event Player)) == 0));
			Apply Impulse(Event Player, Normalize(Facing Direction Of(Event Player) * Z Component Of(Throttle Of(Event Player))
				+ World Vector Of(Left, Event Player, Rotation) * X Component Of(Throttle Of(Event Player)) + Up * (Is Button Held(
				Event Player, Button(Jump)) - Is Button Held(Event Player, Button(Crouch)))), (100 + 300 * Is Button Held(Event Player, Button(
				Reload)) - Speed Of(Event Player)) / 31.250, To World, Incorporate Contrary Motion);
		End;
		Wait(0.064, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Noclip air resistance")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.isNoClipActive == True;
		(Is Button Held(Event Player, Button(Crouch)) || Is Button Held(Event Player, Button(Jump)) || Throttle Of(Event Player)
			!= Left - Left) == False;
		Speed Of(Event Player) > 0.010;
	}

	actions
	{
		Apply Impulse(Event Player, Velocity Of(Event Player) * -1, Speed Of(Event Player) * 0.200, To World, Incorporate Contrary Motion);
		Wait(0.064, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[interface/tools/invisibility.del] If invisibility locks greater than 0, make player invisible")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.invisibilityLockCount > 0;
	}

	actions
	{
		Set Invisible(Event Player, All);
		Wait Until(Event Player.invisibilityLockCount == 0, 1000000);
		Set Invisible(Event Player, None);
	}
}

rule("[interface/tools/invisibility.del] If phased out locks greater than 0, make player phased out")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.phasedOutLockCount > 0;
	}

	actions
	{
		Set Status(Event Player, Null, Phased Out, 1000000);
		Wait Until(Event Player.phasedOutLockCount == 0, 1000000);
		Clear Status(Event Player, Phased Out);
	}
}

rule("[lib/healingPerSecond.ostw] Track when a player receives healing")
{
	event
	{
		Player Received Healing;
		All;
		All;
	}

	conditions
	{
		Event Healing > 0;
		Is True For Any(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 3) || Array Contains(
			Current Array Element.activeInfoDisplays, 4)) == True;
	}

	actions
	{
		Event Player.eventTimestamp = Total Time Elapsed;
		Healee.healingReceivedEvents = Append To Array(Healee.healingReceivedEvents, Array(Array(Event Player.eventTimestamp,
			Event Healing, Healer, Healee)));
		Healer.healingDealtEvents = Append To Array(Healer.healingDealtEvents, Array(Array(Event Player.eventTimestamp, Event Healing,
			Healer, Healee)));
		If(Event Player.eventTimestamp < First Of(First Of(Healee.healingReceivedEvents)) + (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1));
			Healee.healReceivedInPeriod += Event Healing;
			If(Healer != Healee);
				Healee.healReceivedInPeriodNonSelf += Event Healing;
			End;
		End;
		If(Event Player.eventTimestamp < First Of(First Of(Healer.healingDealtEvents)) + (Global.OptimizeMetricsForOverTime ? 0.384 : 1));
			Healer.healDealtInPeriod += Event Healing;
			If(Healer != Healee);
				Healer.healDealtInPeriodNonSelf += Event Healing;
			End;
		End;
	}
}

rule("[lib/healingPerSecond.ostw] When the head of the healing received array has expired, remove all expired events")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Event Player.healingReceivedEvents) > 0;
		Update Every Frame(Total Time Elapsed) >= First Of(First Of(Event Player.healingReceivedEvents)) + (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1) + 0.250;
	}

	actions
	{
		Event Player.oldTimeAcceptanceThreshold = First Of(First Of(Event Player.healingReceivedEvents)) + (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1);
		Event Player.structArraysStartIndex = 0;
		Event Player.structArraysCount = Count Of(Event Player.healingReceivedEvents);
		"Remove expired events"
		While(First Of(Event Player.healingReceivedEvents[Event Player.structArraysStartIndex]) + (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1) + 0.250 < Total Time Elapsed && Event Player.structArraysStartIndex < Count Of(
			Event Player.healingReceivedEvents));
			Event Player.healReceivedInPeriod = Max(0,
				Event Player.healReceivedInPeriod - Event Player.healingReceivedEvents[Event Player.structArraysStartIndex][1]);
			If(
				Event Player.healingReceivedEvents[Event Player.structArraysStartIndex][3] != Event Player.healingReceivedEvents[Event Player.structArraysStartIndex][2]);
				Event Player.healReceivedInPeriodNonSelf = Max(0,
					Event Player.healReceivedInPeriodNonSelf - Event Player.healingReceivedEvents[Event Player.structArraysStartIndex][1]);
			End;
			Event Player.structArraysStartIndex += 1;
			Event Player.structArraysCount -= 1;
		End;
		"Early termination optimization/safety clause"
		If(Count Of(Event Player.healingReceivedEvents) == 0);
			Event Player.healReceivedInPeriod = 0;
			Event Player.healReceivedInPeriodNonSelf = 0;
			Wait(0.016, Ignore Condition);
			Loop If Condition Is True;
			Abort;
		End;
		Event Player.sweepNewlyValidEventsIndex = Event Player.structArraysStartIndex;
		"Add newly valid events"
		While(First Of(Event Player.healingReceivedEvents[Event Player.sweepNewlyValidEventsIndex]) < First Of(
			Event Player.healingReceivedEvents[Event Player.structArraysStartIndex]) + (Global.OptimizeMetricsForOverTime ? 0.384 : 1)
			&& Event Player.sweepNewlyValidEventsIndex < Count Of(Event Player.healingReceivedEvents));
			"Make sure to only include NEWLY valid events"
			If(First Of(Event Player.healingReceivedEvents[Event Player.sweepNewlyValidEventsIndex])
				>= Event Player.oldTimeAcceptanceThreshold);
				Event Player.healReceivedInPeriod += Event Player.healingReceivedEvents[Event Player.sweepNewlyValidEventsIndex][1];
				If(
					Event Player.healingReceivedEvents[Event Player.sweepNewlyValidEventsIndex][2] != Event Player.healingReceivedEvents[Event Player.sweepNewlyValidEventsIndex][3]);
					Event Player.healReceivedInPeriodNonSelf += Event Player.healingReceivedEvents[Event Player.sweepNewlyValidEventsIndex][1];
				End;
			End;
			Event Player.sweepNewlyValidEventsIndex += 1;
		End;
		"Slice arrays instead of doing incremental updates for perf"
		Event Player.healingReceivedEvents = Array Slice(Event Player.healingReceivedEvents, Event Player.structArraysStartIndex,
			Event Player.structArraysCount);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[lib/healingPerSecond.ostw] When the head of the healing dealt array has expired, remove all expired events")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Event Player.healingDealtEvents) > 0;
		Update Every Frame(Total Time Elapsed) >= First Of(First Of(Event Player.healingDealtEvents)) + (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1) + 0.250;
	}

	actions
	{
		Event Player.oldTimeAcceptanceThreshold = First Of(First Of(Event Player.healingDealtEvents)) + (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1);
		Event Player.structArraysStartIndex = 0;
		Event Player.structArraysCount = Count Of(Event Player.healingDealtEvents);
		"Remove expired events"
		While(First Of(Event Player.healingDealtEvents[Event Player.structArraysStartIndex]) + (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1) + 0.250 < Total Time Elapsed && Event Player.structArraysStartIndex < Count Of(
			Event Player.healingDealtEvents));
			Event Player.healDealtInPeriod = Max(0,
				Event Player.healDealtInPeriod - Event Player.healingDealtEvents[Event Player.structArraysStartIndex][1]);
			If(
				Event Player.healingDealtEvents[Event Player.structArraysStartIndex][3] != Event Player.healingDealtEvents[Event Player.structArraysStartIndex][2]);
				Event Player.healDealtInPeriodNonSelf = Max(0,
					Event Player.healDealtInPeriodNonSelf - Event Player.healingDealtEvents[Event Player.structArraysStartIndex][1]);
			End;
			Event Player.structArraysStartIndex += 1;
			Event Player.structArraysCount -= 1;
		End;
		"Early termination optimization/safety clause"
		If(Count Of(Event Player.healingDealtEvents) == 0);
			Event Player.healDealtInPeriod = 0;
			Event Player.healDealtInPeriodNonSelf = 0;
			Wait(0.016, Ignore Condition);
			Loop If Condition Is True;
			Abort;
		End;
		Event Player.sweepNewlyValidEventsIndex = Event Player.structArraysStartIndex;
		"Add newly valid events"
		While(First Of(Event Player.healingDealtEvents[Event Player.sweepNewlyValidEventsIndex]) < First Of(
			Event Player.healingDealtEvents[Event Player.structArraysStartIndex]) + (Global.OptimizeMetricsForOverTime ? 0.384 : 1)
			&& Event Player.sweepNewlyValidEventsIndex < Count Of(Event Player.healingDealtEvents));
			"Make sure to only include NEWLY valid events"
			If(First Of(Event Player.healingDealtEvents[Event Player.sweepNewlyValidEventsIndex]) >= Event Player.oldTimeAcceptanceThreshold);
				Event Player.healDealtInPeriod += Event Player.healingDealtEvents[Event Player.sweepNewlyValidEventsIndex][1];
				If(
					Event Player.healingDealtEvents[Event Player.sweepNewlyValidEventsIndex][2] != Event Player.healingDealtEvents[Event Player.sweepNewlyValidEventsIndex][3]);
					Event Player.healDealtInPeriodNonSelf += Event Player.healingDealtEvents[Event Player.sweepNewlyValidEventsIndex][1];
				End;
			End;
			Event Player.sweepNewlyValidEventsIndex += 1;
		End;
		"Slice arrays instead of doing incremental updates for perf"
		Event Player.healingDealtEvents = Array Slice(Event Player.healingDealtEvents, Event Player.structArraysStartIndex,
			Event Player.structArraysCount);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[lib/damagePerSecond.ostw] Track when a player receives damage")
{
	event
	{
		Player Took Damage;
		All;
		All;
	}

	conditions
	{
		Event Damage > 0;
		Is True For Any(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 5) || Array Contains(
			Current Array Element.activeInfoDisplays, 6)) == True;
	}

	actions
	{
		Event Player.eventTimestamp = Total Time Elapsed;
		Victim.damageReceivedEvents = Append To Array(Victim.damageReceivedEvents, Array(Array(Event Player.eventTimestamp, Event Damage,
			Attacker, Victim)));
		Attacker.damageDealtEvents = Append To Array(Attacker.damageDealtEvents, Array(Array(Event Player.eventTimestamp, Event Damage,
			Attacker, Victim)));
		If(Event Player.eventTimestamp < First Of(First Of(Victim.damageReceivedEvents)) + (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1));
			Victim.damageReceivedInPeriod += Event Damage;
			If(Attacker != Victim);
				Victim.damageReceivedInPeriodNonSelf += Event Damage;
			End;
		End;
		If(Event Player.eventTimestamp < First Of(First Of(Attacker.damageDealtEvents)) + (Global.OptimizeMetricsForOverTime ? 0.384 : 1));
			Attacker.damageDealtInPeriod += Event Damage;
			If(Attacker != Victim);
				Attacker.damageDealtInPeriodNonSelf += Event Damage;
			End;
		End;
	}
}

rule("[lib/damagePerSecond.ostw] When the head of the damage received array has expired, remove all expired events")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Event Player.damageReceivedEvents) > 0;
		Update Every Frame(Total Time Elapsed) >= First Of(First Of(Event Player.damageReceivedEvents)) + (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1) + 0.250;
	}

	actions
	{
		Event Player.oldTimeAcceptanceThreshold = First Of(First Of(Event Player.damageReceivedEvents)) + (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1);
		Event Player.structArraysStartIndex = 0;
		Event Player.structArraysCount = Count Of(Event Player.damageReceivedEvents);
		"Remove expired events"
		While(First Of(Event Player.damageReceivedEvents[Event Player.structArraysStartIndex]) + (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1) + 0.250 < Total Time Elapsed && Event Player.structArraysStartIndex < Count Of(
			Event Player.damageReceivedEvents));
			Event Player.damageReceivedInPeriod = Max(0,
				Event Player.damageReceivedInPeriod - Event Player.damageReceivedEvents[Event Player.structArraysStartIndex][1]);
			If(
				Event Player.damageReceivedEvents[Event Player.structArraysStartIndex][3] != Event Player.damageReceivedEvents[Event Player.structArraysStartIndex][2]);
				Event Player.damageReceivedInPeriodNonSelf = Max(0,
					Event Player.damageReceivedInPeriodNonSelf - Event Player.damageReceivedEvents[Event Player.structArraysStartIndex][1]);
			End;
			Event Player.structArraysStartIndex += 1;
			Event Player.structArraysCount -= 1;
		End;
		Event Player.sweepNewlyValidEventsIndex = Event Player.structArraysStartIndex;
		"Add newly valid events"
		While(First Of(Event Player.damageReceivedEvents[Event Player.sweepNewlyValidEventsIndex]) < First Of(
			Event Player.damageReceivedEvents[Event Player.structArraysStartIndex]) + (Global.OptimizeMetricsForOverTime ? 0.384 : 1)
			&& Event Player.sweepNewlyValidEventsIndex < Count Of(Event Player.damageReceivedEvents));
			"Make sure to only include NEWLY valid events"
			If(First Of(Event Player.damageReceivedEvents[Event Player.sweepNewlyValidEventsIndex])
				>= Event Player.oldTimeAcceptanceThreshold);
				Event Player.damageReceivedInPeriod += Event Player.damageReceivedEvents[Event Player.sweepNewlyValidEventsIndex][1];
				If(
					Event Player.damageReceivedEvents[Event Player.sweepNewlyValidEventsIndex][2] != Event Player.damageReceivedEvents[Event Player.sweepNewlyValidEventsIndex][3]);
					Event Player.damageReceivedInPeriodNonSelf += Event Player.damageReceivedEvents[Event Player.sweepNewlyValidEventsIndex][1];
				End;
			End;
			Event Player.sweepNewlyValidEventsIndex += 1;
		End;
		"Slice arrays instead of doing incremental updates for perf"
		Event Player.damageReceivedEvents = Array Slice(Event Player.damageReceivedEvents, Event Player.structArraysStartIndex,
			Event Player.structArraysCount);
		Wait(Global.MetricsUpdatePeriod, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[lib/damagePerSecond.ostw] When the head of the damage dealt array has expired, remove all expired events")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Event Player.damageDealtEvents) > 0;
		Update Every Frame(Total Time Elapsed) >= First Of(First Of(Event Player.damageDealtEvents)) + (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1) + 0.250;
	}

	actions
	{
		Event Player.oldTimeAcceptanceThreshold = First Of(First Of(Event Player.damageDealtEvents)) + (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1);
		Event Player.structArraysStartIndex = 0;
		Event Player.structArraysCount = Count Of(Event Player.damageDealtEvents);
		"Remove expired events"
		While(First Of(Event Player.damageDealtEvents[Event Player.structArraysStartIndex]) + (
			Global.OptimizeMetricsForOverTime ? 0.384 : 1) + 0.250 < Total Time Elapsed && Event Player.structArraysStartIndex < Count Of(
			Event Player.damageDealtEvents));
			Event Player.damageDealtInPeriod = Max(0,
				Event Player.damageDealtInPeriod - Event Player.damageDealtEvents[Event Player.structArraysStartIndex][1]);
			If(
				Event Player.damageDealtEvents[Event Player.structArraysStartIndex][3] != Event Player.damageDealtEvents[Event Player.structArraysStartIndex][2]);
				Event Player.damageDealtInPeriodNonSelf = Max(0,
					Event Player.damageDealtInPeriodNonSelf - Event Player.damageDealtEvents[Event Player.structArraysStartIndex][1]);
			End;
			Event Player.structArraysStartIndex += 1;
			Event Player.structArraysCount -= 1;
		End;
		Event Player.sweepNewlyValidEventsIndex = Event Player.structArraysStartIndex;
		"Add newly valid events"
		While(First Of(Event Player.damageDealtEvents[Event Player.sweepNewlyValidEventsIndex]) < First Of(
			Event Player.damageDealtEvents[Event Player.structArraysStartIndex]) + (Global.OptimizeMetricsForOverTime ? 0.384 : 1)
			&& Event Player.sweepNewlyValidEventsIndex < Count Of(Event Player.damageDealtEvents));
			"Make sure to only include NEWLY valid events"
			If(First Of(Event Player.damageDealtEvents[Event Player.sweepNewlyValidEventsIndex]) >= Event Player.oldTimeAcceptanceThreshold);
				Event Player.damageDealtInPeriod += Event Player.damageDealtEvents[Event Player.sweepNewlyValidEventsIndex][1];
				If(
					Event Player.damageDealtEvents[Event Player.sweepNewlyValidEventsIndex][2] != Event Player.damageDealtEvents[Event Player.sweepNewlyValidEventsIndex][3]);
					Event Player.damageDealtInPeriodNonSelf += Event Player.damageDealtEvents[Event Player.sweepNewlyValidEventsIndex][1];
				End;
			End;
			Event Player.sweepNewlyValidEventsIndex += 1;
		End;
		"Slice arrays instead of doing incremental updates for perf"
		Event Player.damageDealtEvents = Array Slice(Event Player.damageDealtEvents, Event Player.structArraysStartIndex,
			Event Player.structArraysCount);
		Wait(Global.MetricsUpdatePeriod, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[interface/information/statusEffects.ostw] Keep Status Effect button appearance up to date")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Array Contains(Event Player.activeInfoDisplays, 13) == True;
	}

	actions
	{
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[17] = Custom String("Hide Status Effects");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[17] = Color(Gray);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
		Wait Until(!Array Contains(Event Player.activeInfoDisplays, 13), 99999);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[17] = Custom String("Show Status Effects");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[17] = Color(Lime Green);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
	}
}

rule("[interface/information/statusEffects.ostw] Sleep")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Status(Event Player, Asleep) == True;
	}

	actions
	{
		Event Player.effectStartTimestamp[0] = Total Time Elapsed;
		Wait Until(False ? !Is Reloading(Event Player) : !Has Status(Event Player, Asleep), 99999);
		Event Player.effectDuration[0] = Total Time Elapsed - First Of(Event Player.effectStartTimestamp);
		Small Message(Filtered Array(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 13)), Custom String(
			"{0}{1}", Custom String(" {0} {1} had status {2}", Ability Icon String(Hero(Ana), Button(Ability 1)), Event Player,
			Custom String("ASLEEP")), Custom String(" for {0} secs ({1} ticks)", First Of(Event Player.effectDuration), Round To Integer(
			First Of(Event Player.effectDuration) / 0.016, To Nearest))));
	}
}

rule("[interface/information/statusEffects.ostw] Burning")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Status(Event Player, Burning) == True;
	}

	actions
	{
		Event Player.effectStartTimestamp[1] = Total Time Elapsed;
		Wait Until(False ? !Is Reloading(Event Player) : !Has Status(Event Player, Burning), 99999);
		Event Player.effectDuration[1] = Total Time Elapsed - Event Player.effectStartTimestamp[1];
		Small Message(Filtered Array(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 13)), Custom String(
			"{0}{1}", Custom String(" {0} {1} had status {2}", Icon String(Fire), Event Player, Custom String("BURNING")), Custom String(
			" for {0} secs ({1} ticks)", Event Player.effectDuration[1], Round To Integer(Event Player.effectDuration[1] / 0.016,
			To Nearest))));
	}
}

rule("[interface/information/statusEffects.ostw] Frozen")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Status(Event Player, Frozen) == True;
	}

	actions
	{
		Event Player.effectStartTimestamp[2] = Total Time Elapsed;
		Wait Until(False ? !Is Reloading(Event Player) : !Has Status(Event Player, Frozen), 99999);
		Event Player.effectDuration[2] = Total Time Elapsed - Event Player.effectStartTimestamp[2];
		Small Message(Filtered Array(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 13)), Custom String(
			"{0}{1}", Custom String(" {0} {1} had status {2}", Ability Icon String(Hero(Mei), Button(Ultimate)), Event Player,
			Custom String("FROZEN")), Custom String(" for {0} secs ({1} ticks)", Event Player.effectDuration[2], Round To Integer(
			Event Player.effectDuration[2] / 0.016, To Nearest))));
	}
}

rule("[interface/information/statusEffects.ostw] Hacked")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Status(Event Player, Hacked) == True;
	}

	actions
	{
		Event Player.effectStartTimestamp[3] = Total Time Elapsed;
		Wait Until(False ? !Is Reloading(Event Player) : !Has Status(Event Player, Hacked), 99999);
		Event Player.effectDuration[3] = Total Time Elapsed - Event Player.effectStartTimestamp[3];
		Small Message(Filtered Array(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 13)), Custom String(
			"{0}{1}", Custom String(" {0} {1} had status {2}", Ability Icon String(Hero(Sombra), Button(Ultimate)), Event Player,
			Custom String("HACKED")), Custom String(" for {0} secs ({1} ticks)", Event Player.effectDuration[3], Round To Integer(
			Event Player.effectDuration[3] / 0.016, To Nearest))));
	}
}

rule("[interface/information/statusEffects.ostw] Invincible")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Status(Event Player, Invincible) == True;
	}

	actions
	{
		Event Player.effectStartTimestamp[4] = Total Time Elapsed;
		Wait Until(False ? !Is Reloading(Event Player) : !Has Status(Event Player, Invincible), 99999);
		Event Player.effectDuration[4] = Total Time Elapsed - Event Player.effectStartTimestamp[4];
		Small Message(Filtered Array(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 13)), Custom String(
			"{0}{1}", Custom String(" {0} {1} had status {2}", Ability Icon String(Hero(Brigitte), Button(Secondary Fire)), Event Player,
			Custom String("INVINCIBLE")), Custom String(" for {0} secs ({1} ticks)", Event Player.effectDuration[4], Round To Integer(
			Event Player.effectDuration[4] / 0.016, To Nearest))));
	}
}

rule("[interface/information/statusEffects.ostw] Knocked Down")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Status(Event Player, Knocked Down) == True;
	}

	actions
	{
		Event Player.effectStartTimestamp[5] = Total Time Elapsed;
		Wait Until(False ? !Is Reloading(Event Player) : !Has Status(Event Player, Knocked Down), 99999);
		Event Player.effectDuration[5] = Total Time Elapsed - Event Player.effectStartTimestamp[5];
		Small Message(Filtered Array(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 13)), Custom String(
			"{0}{1}", Custom String(" {0} {1} had status {2}", Icon String(Arrow: Down), Event Player, Custom String("KNOCKED DOWN")),
			Custom String(" for {0} secs ({1} ticks)", Event Player.effectDuration[5], Round To Integer(
			Event Player.effectDuration[5] / 0.016, To Nearest))));
	}
}

rule("[interface/information/statusEffects.ostw] Phased Out")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Status(Event Player, Phased Out) == True;
	}

	actions
	{
		"This needs to be handled differently because spawn room gives phased out, as does opening menu"
		Abort If(Event Player.currentMenuState != 0 || Is In Spawn Room(Event Player));
		Event Player.effectStartTimestamp[6] = Total Time Elapsed;
		Wait Until(!Has Status(Event Player, Phased Out) || Event Player.currentMenuState != 0 || Is In Spawn Room(Event Player), 99999);
		"If the player entered the spawn room or entered the menu, don't print a message"
		Abort If(Event Player.currentMenuState != 0 || Is In Spawn Room(Event Player));
		Event Player.effectDuration[6] = Total Time Elapsed - Event Player.effectStartTimestamp[6];
		Small Message(Filtered Array(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 13)), Custom String(
			"{0}{1}", Custom String(" {0} {1} had status {2}", Ability Icon String(Hero(Reaper), Button(Ability 1)), Event Player,
			Custom String("PHASED OUT")), Custom String(" for {0} secs ({1} ticks)", Event Player.effectDuration[6] + 0.016,
			Round To Integer(Event Player.effectDuration[6] * 62.500 + 1, To Nearest))));
	}
}

rule("[interface/information/statusEffects.ostw] Rooted")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Status(Event Player, Rooted) == True;
	}

	actions
	{
		Event Player.effectStartTimestamp[7] = Total Time Elapsed;
		Wait Until(False ? !Is Reloading(Event Player) : !Has Status(Event Player, Rooted), 99999);
		Event Player.effectDuration[7] = Total Time Elapsed - Event Player.effectStartTimestamp[7];
		Small Message(Filtered Array(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 13)), Custom String(
			"{0}{1}", Custom String(" {0} {1} had status {2}", Ability Icon String(Hero(Junkrat), Button(Ability 2)), Event Player,
			Custom String("ROOTED")), Custom String(" for {0} secs ({1} ticks)", Event Player.effectDuration[7], Round To Integer(
			Event Player.effectDuration[7] / 0.016, To Nearest))));
	}
}

rule("[interface/information/statusEffects.ostw] Stunned")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Status(Event Player, Stunned) == True;
	}

	actions
	{
		Event Player.effectStartTimestamp[8] = Total Time Elapsed;
		Wait Until(False ? !Is Reloading(Event Player) : !Has Status(Event Player, Stunned), 99999);
		Event Player.effectDuration[8] = Total Time Elapsed - Event Player.effectStartTimestamp[8];
		Small Message(Filtered Array(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 13)), Custom String(
			"{0}{1}", Custom String(" {0} {1} had status {2}", Icon String(Dizzy), Event Player, Custom String("STUNNED")), Custom String(
			" for {0} secs ({1} ticks)", Event Player.effectDuration[8], Round To Integer(Event Player.effectDuration[8] / 0.016,
			To Nearest))));
	}
}

rule("[interface/information/statusEffects.ostw] Unkillable")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Status(Event Player, Unkillable) == True;
	}

	actions
	{
		Event Player.effectStartTimestamp[9] = Total Time Elapsed;
		Wait Until(False ? !Is Reloading(Event Player) : !Has Status(Event Player, Unkillable), 99999);
		Event Player.effectDuration[9] = Total Time Elapsed - Event Player.effectStartTimestamp[9];
		Small Message(Filtered Array(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 13)), Custom String(
			"{0}{1}", Custom String(" {0} {1} had status {2}", Ability Icon String(Hero(Baptiste), Button(Ability 2)), Event Player,
			Custom String("UNKILLABLE")), Custom String(" for {0} secs ({1} ticks)", Event Player.effectDuration[9], Round To Integer(
			Event Player.effectDuration[9] / 0.016, To Nearest))));
	}
}

rule("[interface/information/statusEffects.ostw] Reloading")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Reloading(Event Player) == True;
	}

	actions
	{
		Event Player.effectStartTimestamp[10] = Total Time Elapsed;
		Wait Until(True ? !Is Reloading(Event Player) : !Has Status(Event Player, Asleep), 99999);
		Event Player.effectDuration[10] = Total Time Elapsed - Event Player.effectStartTimestamp[10];
		Small Message(Filtered Array(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 13)), Custom String(
			"{0}{1}", Custom String(" {0} {1} had status {2}", Icon String(Recycle), Event Player, Custom String("RELOADING")),
			Custom String(" for {0} secs ({1} ticks)", Event Player.effectDuration[10], Round To Integer(
			Event Player.effectDuration[10] / 0.016, To Nearest))));
	}
}

rule("[interface/information/damageNumbers.ostw] Update Information Menu button appearance for damage/heal numbers")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Array Contains(Event Player.activeInfoDisplays, 16) == True;
	}

	actions
	{
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[22] = Custom String("Hide Damage/Heal Numbers");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[22] = Color(Gray);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
		Wait Until(!Array Contains(Event Player.activeInfoDisplays, 16), 99999);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[3];
		Global._arrayConstructor[22] = Custom String("Show Damage/Heal Numbers");
		Event Player.ButtonLabelGrid[3] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[3];
		Global._arrayConstructor[22] = Color(Blue);
		Event Player.ButtonColorGrid[3] = Global._arrayConstructor;
	}
}

rule("[interface/information/damageNumbers.ostw] When player takes damage, create the text if necessary and update values")
{
	event
	{
		Player Took Damage;
		All;
		All;
	}

	conditions
	{
		Event Damage > 0;
	}

	actions
	{
		Event Player.lastDamageInstanceAmount = Event Damage;
		Event Player.lastDamageInstancePosition = Position Of(Event Player);
		"If we don't have any active ***ulative damage number, reset and create it"
		If(Event Player.totalDamageDisplayTextID == -1);
			Event Player.totalDamage = Event Damage;
			Create In-World Text(Filtered Array(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 16)),
				Custom String("-{0}{1}", Event Player.totalDamage, Event Player.totalHealingDisplayTextID != -1 ? Custom String("    ")
				: Custom String("")), Update Every Frame(Position Of(Event Player)) + Vector(0, 4, 0), 4, Do Not Clip,
				Visible To Position and String, Custom Color(200, 50, 50, 255), Default Visibility);
			Event Player.totalDamageDisplayTextID = Last Text ID;
			Create In-World Text(Filtered Array(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 16)),
				Custom String("-{0}{1}", Event Player.lastDamageInstanceAmount, Event Player.totalHealingDisplayTextID != -1 ? Custom String(
				"    ") : Custom String("")), Event Player.lastDamageInstancePosition + Vector(0, 3, 0), 2, Do Not Clip,
				Visible To Position and String, Custom Color(200, 50, 50, 255), Default Visibility);
			Event Player.lastDamageDisplayTextID = Last Text ID;
		Else;
			Event Player.totalDamage += Event Damage;
		End;
		Wait(3, Restart When True);
		Destroy In-World Text(Event Player.totalDamageDisplayTextID);
		Destroy In-World Text(Event Player.lastDamageDisplayTextID);
		Event Player.totalDamageDisplayTextID = -1;
		Event Player.lastDamageDisplayTextID = -1;
	}
}

rule("[interface/information/damageNumbers.ostw] When player received healing, create the text if necessary and update values")
{
	event
	{
		Player Received Healing;
		All;
		All;
	}

	conditions
	{
		Event Healing > 0;
	}

	actions
	{
		Event Player.lastHealInstanceAmount = Event Healing;
		Event Player.lastHealInstancePosition = Position Of(Event Player);
		"If we don't have any active damage number, reset and create it"
		If(Event Player.totalHealingDisplayTextID == -1);
			Event Player.totalHealing = Event Healing;
			Create In-World Text(Filtered Array(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 16)),
				Custom String("{0}+{1}", Event Player.totalDamageDisplayTextID != -1 ? Custom String("    ") : Custom String(""),
				Event Player.totalHealing), Update Every Frame(Position Of(Event Player)) + Vector(0, 4, 0), 4, Do Not Clip,
				Visible To Position and String, Color(Yellow), Default Visibility);
			Event Player.totalHealingDisplayTextID = Last Text ID;
			Create In-World Text(Filtered Array(All Players(All Teams), Array Contains(Current Array Element.activeInfoDisplays, 16)),
				Custom String("{0}+{1}", Event Player.totalDamageDisplayTextID != -1 ? Custom String("    ") : Custom String(""),
				Event Player.lastHealInstanceAmount), Event Player.lastHealInstancePosition + Vector(0, 3, 0), 1.500, Do Not Clip,
				Visible To Position and String, Color(Yellow), Default Visibility);
			Event Player.lastHealingDisplayTextID = Last Text ID;
		Else;
			Event Player.totalHealing += Event Healing;
		End;
		Wait(3, Restart When True);
		Destroy In-World Text(Event Player.totalHealingDisplayTextID);
		Destroy In-World Text(Event Player.lastHealingDisplayTextID);
		Event Player.totalHealingDisplayTextID = -1;
		Event Player.lastHealingDisplayTextID = -1;
	}
}

rule("[interface/modifications/modsMenu.ostw] Update faster abilities button appearance")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[1] == True;
	}

	actions
	{
		Global._arrayConstructor = Event Player.ButtonLabelGrid[4];
		Global._arrayConstructor[6] = Custom String("Faster Abilities [ON]");
		Event Player.ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[4];
		Global._arrayConstructor[6] = Color(Blue);
		Event Player.ButtonColorGrid[4] = Global._arrayConstructor;
		Small Message(All Players(All Teams), Custom String("  {0} Faster Abilities On", Icon String(Checkmark)));
		Wait Until(!Global.activeModifications[1], 99999);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[4];
		Global._arrayConstructor[6] = Custom String("Faster Abilities [OFF]");
		Event Player.ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[4];
		Global._arrayConstructor[6] = Color(Gray);
		Event Player.ButtonColorGrid[4] = Global._arrayConstructor;
		Small Message(All Players(All Teams), Custom String("  {0} Faster Abilities Off", Icon String(X)));
	}
}

rule("[interface/modifications/modsMenu.ostw] Handle unkillable modification")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[9] == True;
	}

	actions
	{
		Set Status(Event Player, Null, Unkillable, 1000000);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[4];
		Global._arrayConstructor[7] = Custom String("Unkillable [ON]");
		Event Player.ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[4];
		Global._arrayConstructor[7] = Color(Green);
		Event Player.ButtonColorGrid[4] = Global._arrayConstructor;
		Small Message(All Players(All Teams), Custom String("  {0} Unkillable On", Icon String(Checkmark)));
		Wait Until(!Global.activeModifications[9], 1000000);
		Clear Status(Event Player, Unkillable);
		Small Message(All Players(All Teams), Custom String("  {0} Unkillable Off", Icon String(X)));
		Global._arrayConstructor = Event Player.ButtonLabelGrid[4];
		Global._arrayConstructor[7] = Custom String("Unkillable [OFF]");
		Event Player.ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[4];
		Global._arrayConstructor[7] = Color(Gray);
		Event Player.ButtonColorGrid[4] = Global._arrayConstructor;
	}
}

rule("[interface/modifications/modsMenu.ostw] Handle reduced damage taken")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[2] == True;
	}

	actions
	{
		Set Damage Received(Event Player, 10);
		Small Message(All Players(All Teams), Custom String("  {0} Reduced Damage On", Icon String(Checkmark)));
		Global._arrayConstructor = Event Player.ButtonLabelGrid[4];
		Global._arrayConstructor[11] = Custom String("Reduced Damage Taken [ON]");
		Event Player.ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[4];
		Global._arrayConstructor[11] = Color(Orange);
		Event Player.ButtonColorGrid[4] = Global._arrayConstructor;
		Wait Until(!Global.activeModifications[2], 99999);
		Set Damage Received(Event Player, 100);
		Small Message(All Players(All Teams), Custom String("  {0} Reduced Damage Off", Icon String(X)));
		Global._arrayConstructor = Event Player.ButtonLabelGrid[4];
		Global._arrayConstructor[11] = Custom String("Reduced Damage Taken [OFF]");
		Event Player.ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[4];
		Global._arrayConstructor[11] = Color(Gray);
		Event Player.ButtonColorGrid[4] = Global._arrayConstructor;
	}
}

rule("[interface/modifications/modsMenu.ostw] Handle increased damage dealt")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[3] == True;
	}

	actions
	{
		Set Damage Dealt(Event Player, 300);
		Small Message(All Players(All Teams), Custom String("  {0} Increased Damage On", Icon String(Checkmark)));
		Global._arrayConstructor = Event Player.ButtonLabelGrid[4];
		Global._arrayConstructor[8] = Custom String("Increased Damage Dealt [ON]");
		Event Player.ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[4];
		Global._arrayConstructor[8] = Color(Rose);
		Event Player.ButtonColorGrid[4] = Global._arrayConstructor;
		Wait Until(!Global.activeModifications[3], 99999);
		Set Damage Dealt(Event Player, 100);
		Small Message(All Players(All Teams), Custom String("  {0} Increased Damage Off", Icon String(X)));
		Global._arrayConstructor = Event Player.ButtonLabelGrid[4];
		Global._arrayConstructor[8] = Custom String("Increased Damage Dealt [OFF]");
		Event Player.ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[4];
		Global._arrayConstructor[8] = Color(Gray);
		Event Player.ButtonColorGrid[4] = Global._arrayConstructor;
	}
}

rule("[interface/modifications/modsMenu.ostw] Handle auto-regen health")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[4] == True;
	}

	actions
	{
		Small Message(All Players(All Teams), Custom String("  {0} Auto-Regen On", Icon String(Checkmark)));
		Global._arrayConstructor = Event Player.ButtonLabelGrid[4];
		Global._arrayConstructor[16] = Custom String("Auto-Regen Health [ON]");
		Event Player.ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[4];
		Global._arrayConstructor[16] = Color(Red);
		Event Player.ButtonColorGrid[4] = Global._arrayConstructor;
		Wait Until(!Global.activeModifications[4], 99999);
		Small Message(All Players(All Teams), Custom String("  {0} Auto-Regen Off", Icon String(X)));
		Global._arrayConstructor = Event Player.ButtonLabelGrid[4];
		Global._arrayConstructor[16] = Custom String("Auto-Regen Health [OFF]");
		Event Player.ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[4];
		Global._arrayConstructor[16] = Color(Gray);
		Event Player.ButtonColorGrid[4] = Global._arrayConstructor;
	}
}

rule("[interface/modifications/modsMenu.ostw] When player takes damage, and they avoid damage for 5 seconds, fill health")
{
	event
	{
		Player Took Damage;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[4] == True;
	}

	actions
	{
		Wait(Global.AUTO_REGEN_DELAY, Restart When True);
		Set Player Health(Event Player, Max Health(Event Player));
	}
}

rule("[interface/modifications/modsMenu.ostw] Handle faster respawn button appearance")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[5] == True;
	}

	actions
	{
		Small Message(All Players(All Teams), Custom String("  {0} Faster Respawn On", Icon String(Checkmark)));
		Global._arrayConstructor = Event Player.ButtonLabelGrid[4];
		Global._arrayConstructor[13] = Custom String("Faster Respawn [ON]");
		Event Player.ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[4];
		Global._arrayConstructor[13] = Color(Aqua);
		Event Player.ButtonColorGrid[4] = Global._arrayConstructor;
		Wait Until(!Global.activeModifications[5], 99999);
		Small Message(All Players(All Teams), Custom String("  {0} Faster Respawn Off", Icon String(X)));
		Global._arrayConstructor = Event Player.ButtonLabelGrid[4];
		Global._arrayConstructor[13] = Custom String("Faster Respawn [OFF]");
		Event Player.ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[4];
		Global._arrayConstructor[13] = Color(Gray);
		Event Player.ButtonColorGrid[4] = Global._arrayConstructor;
	}
}

rule("[interface/modifications/modsMenu.ostw] Make respawn happen faster if enabled")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[5] == True;
	}

	actions
	{
		Wait Until(Is Alive(Event Player), 3);
		Abort If(Is Alive(Event Player));
		Respawn(Event Player);
	}
}

rule("[interface/modifications/modsMenu.ostw] Handle disable mode completion button appearance")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[6] == True;
	}

	actions
	{
		Small Message(All Players(All Teams), Custom String("  {0} Mode Completion Disabled", Icon String(Checkmark)));
		Global._arrayConstructor = All Players(All Teams).ButtonLabelGrid[4];
		Global._arrayConstructor[18] = Custom String("Disable Mode Completion [ON]");
		All Players(All Teams).ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = All Players(All Teams).ButtonColorGrid[4];
		Global._arrayConstructor[18] = Color(Sky Blue);
		All Players(All Teams).ButtonColorGrid[4] = Global._arrayConstructor;
		Wait Until(!Global.activeModifications[6], 99999);
		Small Message(All Players(All Teams), Custom String("  {0} Mode Completion Enabled", Icon String(X)));
		Global._arrayConstructor = All Players(All Teams).ButtonLabelGrid[4];
		Global._arrayConstructor[18] = Custom String("Disable Mode Completion [OFF]");
		All Players(All Teams).ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = All Players(All Teams).ButtonColorGrid[4];
		Global._arrayConstructor[18] = Color(Gray);
		All Players(All Teams).ButtonColorGrid[4] = Global._arrayConstructor;
	}
}

rule("[interface/modifications/modsMenu.ostw] Handle disable mode completion")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.activeModifications[6] == True;
	}

	actions
	{
		Disable Built-In Game Mode Completion;
		Wait Until(!Global.activeModifications[6], 99999);
		Enable Built-In Game Mode Completion;
	}
}

rule("[interface/modifications/modsMenu.ostw] Handle slow motion button appearanace")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[7] == True;
	}

	actions
	{
		Small Message(All Players(All Teams), Custom String("  {0} Slow Motion On", Icon String(Checkmark)));
		Global._arrayConstructor = Event Player.ButtonLabelGrid[4];
		Global._arrayConstructor[12] = Custom String("Slow Motion [ON]");
		Event Player.ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[4];
		Global._arrayConstructor[12] = Color(Violet);
		Event Player.ButtonColorGrid[4] = Global._arrayConstructor;
		Wait Until(!Global.activeModifications[7], 99999);
		Small Message(All Players(All Teams), Custom String("  {0} Slow Motion Off", Icon String(X)));
		Global._arrayConstructor = Event Player.ButtonLabelGrid[4];
		Global._arrayConstructor[12] = Custom String("Slow Motion [OFF]");
		Event Player.ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[4];
		Global._arrayConstructor[12] = Color(Gray);
		Event Player.ButtonColorGrid[4] = Global._arrayConstructor;
	}
}

rule("[interface/modifications/modsMenu.ostw] Handle slow motion")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.activeModifications[7] == True;
	}

	actions
	{
		Set Slow Motion(Global.SLOW_MOTION_SPEED);
		Wait Until(!Global.activeModifications[7], 99999);
		Set Slow Motion(100);
	}
}

rule("[interface/modifications/modsMenu.ostw] Handle disable self-heal passive button appearance")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[8] == True;
	}

	actions
	{
		Small Message(All Players(All Teams), Custom String("  {0} Self-Heal Passive Off", Icon String(X)));
		Global._arrayConstructor = Event Player.ButtonLabelGrid[4];
		Global._arrayConstructor[17] = Custom String("Self-Heal Passive [OFF]");
		Event Player.ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[4];
		Global._arrayConstructor[17] = Color(Gray);
		Event Player.ButtonColorGrid[4] = Global._arrayConstructor;
		Wait Until(!Global.activeModifications[8], 99999);
		Small Message(All Players(All Teams), Custom String("  {0} Self-Heal Passive On", Icon String(Checkmark)));
		Global._arrayConstructor = Event Player.ButtonLabelGrid[4];
		Global._arrayConstructor[17] = Custom String("Self-Heal Passive [ON]");
		Event Player.ButtonLabelGrid[4] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[4];
		Global._arrayConstructor[17] = Color(Yellow);
		Event Player.ButtonColorGrid[4] = Global._arrayConstructor;
	}
}

rule("[interface/modifications/modsMenu.ostw] Handle preventing heal passive")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
		Normalized Health(Event Player) < 1;
	}

	actions
	{
		Wait(Array Contains(All Support Heroes, Is Duplicating(Event Player) ? Hero Being Duplicated(Event Player) : Hero Of(Event Player))
			? 2.450 : (Max Health Of Type(Event Player, Shields) > 0 ? 2.950 : 4.950), Abort When False);
		Loop If(Has Status(Event Player, Asleep) || (!Global.activeModifications[8] && !Event Player.isPunchingBag));
		If(Health(Event Player) <= 0.001);
			Set Player Health(Event Player, 0.002);
		End;
		Damage(Event Player, Null, 0.001);
		Heal(Event Player, Null, 0.001);
		Loop If Condition Is True;
	}
}

rule("[interface/modifications/fasterAbilities.ostw] Ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[1] == True;
		Ultimate Charge Percent(Event Player) < 100;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
		Wait(0.500, Abort When False);
		Loop;
	}
}

rule("[interface/modifications/fasterAbilities.ostw] Primary fire cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[1] == True;
		Ability Cooldown(Event Player, Button(Primary Fire)) > 0;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Primary Fire), 1);
	}
}

rule("[interface/modifications/fasterAbilities.ostw] Primary fire: Refill Moira Biotic Energy")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[1] == True;
		(Is Duplicating(Event Player) ? Hero Being Duplicated(Event Player) : Hero Of(Event Player)) == Hero(Moira);
		Ability Resource(Event Player, Button(Primary Fire)) < 95;
	}

	actions
	{
		"Don't fill all the way because that makes the meter disappear"
		Set Ability Resource(Event Player, Button(Primary Fire), 95);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[interface/modifications/fasterAbilities.ostw] Secondary fire cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[1] == True;
		Ability Cooldown(Event Player, Button(Secondary Fire)) > 0;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 1);
	}
}

rule("[interface/modifications/fasterCooldown.ostw] Secondary fire: Refill D.Va defense matrix")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[1] == True;
		(Is Duplicating(Event Player) ? Hero Being Duplicated(Event Player) : Hero Of(Event Player)) == Hero(D.Va);
		Ability Resource(Event Player, Button(Secondary Fire)) < 100;
	}

	actions
	{
		Set Ability Resource(Event Player, Button(Secondary Fire), 100);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[interface/modifications/fasterAbilities.ostw] Ability 1 cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[1] == True;
		Ability Cooldown(Event Player, Button(Ability 1)) > 0;
	}

	actions
	{
		If(Array Contains(Array(Hero(Roadhog), Hero(Ashe), Hero(Genji)), Is Duplicating(Event Player) ? Hero Being Duplicated(Event Player)
			: Hero Of(Event Player)));
			Wait Until(!Is Using Ability 1(Event Player), Ability Cooldown(Event Player, Button(Ability 1)));
		End;
		Wait(0.016, Ignore Condition);
		Set Ability Cooldown(Event Player, Button(Ability 1), 1);
	}
}

rule("[interface/modifications/fasterAbilities.ostw] Zarya/Junkrat - 2 Ability 1 charges")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[1] == True;
		Array Contains(Array(Hero(Zarya), Hero(Junkrat)), Is Duplicating(Event Player) ? Hero Being Duplicated(Event Player) : Hero Of(
			Event Player)) == True;
		Ability Charge(Event Player, Button(Ability 1)) < 2;
	}

	actions
	{
		Wait(1, Abort When False);
		Set Ability Charge(Event Player, Button(Ability 1), Ability Charge(Event Player, Button(Ability 1)) + 1);
		Loop If Condition Is True;
	}
}

rule("[interface/modifications/fasterAbilities.ostw] Symmetra/Tracer - 3 Ability 1 charges")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[1] == True;
		Array Contains(Array(Hero(Tracer), Hero(Symmetra)), Is Duplicating(Event Player) ? Hero Being Duplicated(Event Player) : Hero Of(
			Event Player)) == True;
		Ability Charge(Event Player, Button(Ability 1)) < 3;
	}

	actions
	{
		Wait(1, Abort When False);
		Set Ability Charge(Event Player, Button(Ability 1), Ability Charge(Event Player, Button(Ability 1)) + 1);
		Loop If Condition Is True;
	}
}

rule("[interface/modifications/fasterAbilities.ostw] Ability 2 cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[1] == True;
		Ability Cooldown(Event Player, Button(Ability 2)) > 0;
	}

	actions
	{
		If(Array Contains(Array(Hero(D.Va), Hero(Reaper)), Is Duplicating(Event Player) ? Hero Being Duplicated(Event Player) : Hero Of(
			Event Player)));
			Wait Until(!Is Using Ability 2(Event Player), Ability Cooldown(Event Player, Button(Ability 2)));
		End;
		Wait(0.016, Ignore Condition);
		Set Ability Cooldown(Event Player, Button(Ability 2), 1);
	}
}

rule("[interface/modifications/fasterAbilities.ostw] Reinhardt - 2 Ability 2 charges")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[1] == True;
		(Is Duplicating(Event Player) ? Hero Being Duplicated(Event Player) : Hero Of(Event Player)) == Hero(Reinhardt);
		Ability Charge(Event Player, Button(Ability 2)) < 2;
	}

	actions
	{
		Wait(1, Abort When False);
		Set Ability Charge(Event Player, Button(Ability 2), Ability Charge(Event Player, Button(Ability 2)) + 1);
		Loop If Condition Is True;
	}
}

rule("[interface/modifications/fasterAbilities.ostw] Brigitte - 3 Ability 2 charges")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[1] == True;
		(Is Duplicating(Event Player) ? Hero Being Duplicated(Event Player) : Hero Of(Event Player)) == Hero(Brigitte);
		Ability Charge(Event Player, Button(Ability 2)) < 3;
	}

	actions
	{
		Wait(1, Abort When False);
		Set Ability Charge(Event Player, Button(Ability 2), Ability Charge(Event Player, Button(Ability 2)) + 1);
		Loop If Condition Is True;
	}
}

rule("[interface/modifications/fasterAbilities.ostw] Doomfist - charge block instantly")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[1] == True;
		(Is Duplicating(Event Player) ? Hero Being Duplicated(Event Player) : Hero Of(Event Player)) == Hero(Doomfist);
		Is Using Ability 2(Event Player) == True;
		Ability Resource(Event Player, Button(Ability 2)) < 100;
	}

	actions
	{
		Set Ability Resource(Event Player, Button(Ability 2), 100);
	}
}

rule("[interface/modifications/fasterAbilities.ostw] Crouch cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[1] == True;
		Ability Cooldown(Event Player, Button(Crouch)) > 0;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Crouch), 1);
	}
}

rule("[interface/modifications/fasterAbilities.ostw] Jump cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.activeModifications[1] == True;
		Ability Cooldown(Event Player, Button(Jump)) > 0;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Jump), 1);
	}
}

rule("[interface/dummyBotsAndReplay/botsMenu.ostw] Initiator perspective for resetting all bots to reset points")
{
	event
	{
		Subroutine;
		ResetAllBotsToResetPoints;
	}

	actions
	{
		Big Message(All Players(All Teams), Custom String("Reset all bots to their reset points"));
		If(Is True For Any(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)), First Of(
			Current Array Element.replayResetPoint) == Null && First Of(Current Array Element._extendedPlayerCollection[2]) == Null));
			Small Message(Event Player, Custom String("  Some bots do not have reset points set!"));
			Play Effect(Event Player, Debuff Impact Sound, Null, Event Player, 100);
			Wait(0.250, Ignore Condition);
			Small Message(Event Player, Custom String("  Teleporting those bots to you..."));
			Skip(1);
		End;
	}
}

rule("[interface/dummyBotsAndReplay/botsMenu.ostw] Handle bots menu actions")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.selectedBotsReplayAction != 0;
	}

	actions
	{
		Skip(Array(70, 0, 0, 8, 31, 33, 43, 55)[Index Of Array Value(Array(1, 2, 3, 4, 5, 6, 7), Event Player.selectedBotsReplayAction)
			+ 1]);
		"[CASE] Create dummy bot/punching bag"
		Create Dummy Bot(Hero Of(Event Player), Opposite Team Of(Team Of(Event Player)), -1, Ray Cast Hit Position(Eye Position(
			Event Player), Eye Position(Event Player) + Facing Direction Of(Event Player) * 10, Null, Null, False),
			-1 * Facing Direction Of(Event Player));
		If(Event Player.selectedBotsReplayAction == 2);
			Event Player.bot = Last Created Entity;
			Event Player.bot.isPunchingBag = True;
			Add Health Pool To Player(Event Player.bot, Health, 1250, True, False);
			Event Player.bot._extendedPlayerCollection[5] = Last Created Health Pool;
		End;
		Skip(62);
		"[CASE] Toggle bot edit mode"
		If(Event Player.botControlMode == 0);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[6];
			Global._arrayConstructor[12] = Custom String("Stop Editing Bots");
			Event Player.ButtonLabelGrid[6] = Global._arrayConstructor;
			Event Player.botControlMode = 1;
			If(!Event Player.isNoClipActive);
				Event Player.toolsActionID = 3;
				Wait(0.016, Ignore Condition);
				Event Player.toolsActionID = 0;
			End;
		Else;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[6];
			Global._arrayConstructor[12] = Custom String("Edit Dummy Bots");
			Event Player.ButtonLabelGrid[6] = Global._arrayConstructor;
			Event Player.botControlMode = 0;
			If(Event Player.isNoClipActive);
				Event Player.toolsActionID = 3;
				Wait(0.016, Ignore Condition);
				Event Player.toolsActionID = 0;
			End;
		End;
		Event Player.currentMenuState = 0;
		Skip(39);
		"[CASE] Reset all bots to reset points"
		Start Rule(ResetAllBotsToResetPoints, Do Nothing);
		Skip(37);
		"[CASE] Destroy all bots"
		Event Player.actionToConfirm = Custom String("delete ALL bots");
		Event Player.confirmationState = 0;
		Event Player.currentMenuState = 2;
		Wait Until(Event Player.confirmationState != 0, 1000000);
		If(Event Player.confirmationState == 1);
			Destroy All Dummy Bots;
			Big Message(All Players(All Teams), Custom String("All Dummy Bots Destroyed"));
		End;
		Event Player.currentMenuState = 6;
		Skip(27);
		"[CASE] Initiate playback of all bots with clips"
		If(Count Of(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element) && Current Array Element.totalFrames > 0))
			== 0);
			Small Message(Event Player, Custom String("  No replays recorded yet!"));
			Play Effect(Event Player, Debuff Impact Sound, Null, Event Player, 100);
			Skip(7);
		End;
		If(Is True For Any(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)), Array Contains(Array(Custom String(
			"PREPARING_FOR_PLAYBACK"), Custom String("PLAYING"), Custom String("REACHED_END_OF_REPLAY")),
			Current Array Element.replayState)));
			Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)).recordingPlayStopFlag = 2;
			Skip(3);
		End;
		Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)).recordingPlayStopFlag = 1;
		Event Player.currentMenuState = 0;
		Skip(15);
		"[CASE] Delete all replay clips"
		If(Count Of(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element) && Current Array Element.totalFrames > 0))
			== 0);
			Big Message(Event Player, Custom String("  No replays recorded yet!"));
			Play Effect(Event Player, Debuff Impact Sound, Null, Event Player, 100);
			Skip(11);
		End;
		Event Player.actionToConfirm = Custom String("delete ALL replays");
		Event Player.confirmationState = 0;
		Event Player.currentMenuState = 2;
		Wait Until(Event Player.confirmationState != 0, 1000000);
		If(Event Player.confirmationState == 1);
			Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)).recordingPlayStopFlag = 3;
			Big Message(Event Player, Custom String("  All Replays Deleted"));
			Play Effect(Event Player, Buff Impact Sound, Null, Event Player, 100);
		End;
		Event Player.currentMenuState = 6;
	}
}

rule("[interface/dummyBotsAndReplay/botEditPage.del] Handle resetting all bots to their reset points")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is True For Any(Filtered Array(All Players(All Teams), !Is Dummy Bot(Current Array Element)),
			Current Array Element.selectedBotsReplayAction == 4) == True;
	}

	actions
	{
		Respawn(Event Player);
		Wait Until(Is Alive(Event Player), 1);
		If(First Of(Event Player.replayResetPoint) != Null);
			Teleport(Event Player, First Of(Event Player.replayResetPoint));
			Stop Facing(Event Player);
			Wait(0.016, Ignore Condition);
			Set Facing(Event Player, Event Player.replayResetPoint[2], To World);
			"Because for SOME REASON setting FACING and TELEPORTING in the SAME FRAME cancels the TELEPORT"
			Wait(0.032, Ignore Condition);
			Start Facing(Event Player, Event Player.replayResetPoint[2], 1000, To World, Direction and Turn Rate);
			Wait(0.016, Ignore Condition);
			Wait Until(Angle Between Vectors(Facing Direction Of(Event Player), Event Player.replayResetPoint[2]) < 0.100, 0.250);
			Stop Facing(Event Player);
		Else If(First Of(Event Player._extendedPlayerCollection[2]) != Null);
			Teleport(Event Player, First Of(Event Player._extendedPlayerCollection[2]));
			Stop Facing(Event Player);
			Wait(0.016, Ignore Condition);
			Set Facing(Event Player, Event Player._extendedPlayerCollection[2][2], To World);
			"Because for SOME REASON setting FACING and TELEPORTING in the SAME FRAME cancels the TELEPORT"
			Wait(0.032, Ignore Condition);
			Start Facing(Event Player, Event Player._extendedPlayerCollection[2][2], 1000, To World, Direction and Turn Rate);
			Wait(0.016, Ignore Condition);
			Wait Until(Angle Between Vectors(Facing Direction Of(Event Player), Event Player._extendedPlayerCollection[2][2]) < 0.100, 0.250);
			Stop Facing(Event Player);
		Else;
			Teleport(Event Player, First Of(Filtered Array(All Players(All Teams), !Is Dummy Bot(Current Array Element)
				&& Current Array Element.selectedBotsReplayAction == 4)));
		End;
		If(Altitude Of(Event Player) > 1);
			Set Gravity(Event Player, 0);
			Wait(0.016, Ignore Condition);
			If(Speed Of(Event Player) > 0.050);
				Apply Impulse(Event Player, Velocity Of(Event Player) * -1, Speed Of(Event Player), To World, Incorporate Contrary Motion);
			End;
		Else;
			Set Gravity(Event Player, 100);
		End;
	}
}

rule("[interface/dummyBotsAndReplay/botsMenu.ostw] Update Play/Stop All Replays button appearance")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is True For Any(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)), Array Contains(Array(Custom String(
			"PREPARING_FOR_PLAYBACK"), Custom String("PLAYING"), Custom String("REACHED_END_OF_REPLAY")),
			Current Array Element.replayState)) == True;
	}

	actions
	{
		Global._arrayConstructor = Event Player.ButtonLabelGrid[6];
		Global._arrayConstructor[11] = Custom String("Stop All Replays");
		Event Player.ButtonLabelGrid[6] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[6];
		Global._arrayConstructor[11] = Color(Red);
		Event Player.ButtonColorGrid[6] = Global._arrayConstructor;
		Wait Until(Is True For Any(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)), Array Contains(Array(
			Custom String("PREPARING_FOR_PLAYBACK"), Custom String("PLAYING"), Custom String("REACHED_END_OF_REPLAY")),
			Current Array Element.replayState)) == False, 9999);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[6];
		Global._arrayConstructor[11] = Custom String("Play All Replays");
		Event Player.ButtonLabelGrid[6] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[6];
		Global._arrayConstructor[11] = Color(Lime Green);
		Event Player.ButtonColorGrid[6] = Global._arrayConstructor;
	}
}

rule("[interface/dummyBotsAndReplay/botPlacementModule.ostw] Maintain punching bag health")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.isPunchingBag == True;
		Absolute Value(Normalized Health(Event Player) - Global.punchingBagTargetHealthProportio) > 0.075;
	}

	actions
	{
		Set Player Health(Event Player, Global.punchingBagTargetHealthProportio * Max Health(Event Player));
		Wait(1, Abort When False);
		Loop If Condition Is True;
	}
}

rule("[interface/dummyBotsAndReplay/botPlacementModule.ostw] When entering edit mode, add locks to used buttons")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.botControlMode == 1;
	}

	actions
	{
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Primary Fire))] += 1;
		Disallow Button(Event Player, Button(Primary Fire));
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Secondary Fire))] += 1;
		Disallow Button(Event Player, Button(Secondary Fire));
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Reload))] += 1;
		Disallow Button(Event Player, Button(Reload));
		Wait Until(Event Player.botControlMode != 1, 1000000);
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Primary Fire))] -= 1;
		If(Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Primary Fire))] == 0);
			Allow Button(Event Player, Button(Primary Fire));
		End;
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Secondary Fire))] -= 1;
		If(Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Secondary Fire))] == 0);
			Allow Button(Event Player, Button(Secondary Fire));
		End;
		Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Reload))] -= 1;
		If(Event Player.buttonLocks[Index Of Array Value(Global.AllButtons, Button(Reload))] == 0);
			Allow Button(Event Player, Button(Reload));
		End;
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[interface/dummyBotsAndReplay/botPlacementModule.ostw] When a player joins, update the number of hero-skin combos remaining")
{
	event
	{
		Player Joined Match;
		All;
		All;
	}

	actions
	{
		Global.uniqueHeroSkinCombosRemaining = 12 - Count Of(All Players(All Teams));
	}
}

rule("[interface/dummyBotsAndReplay/botPlacementModule.ostw] When a player leaves, update the number of hero-skin combos remaining")
{
	event
	{
		Player Left Match;
		All;
		All;
	}

	actions
	{
		Global.uniqueHeroSkinCombosRemaining = 12 - Count Of(All Players(All Teams));
	}
}

rule("[interface/dummyBotsAndReplay/botPlacementModule.ostw] Initialize selection entities for dummy bots")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Event Player.positionControl = Array(Event Player, Global.nextSelectionEntityId, Position Of(Event Player) + Up, 1);
		Event Player.facingControl = Array(Event Player, Global.nextSelectionEntityId + 1, Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 5, 2);
		"Create the facing location control orb"
		Create Effect(Entity Exists(Local Player) && Is Dummy Bot(First Of(Event Player.positionControl)) && Is Alive(First Of(
			Event Player.positionControl)) && First Of(Event Player.positionControl).replayState == Custom String("NONE")
			&& Local Player.botControlMode == 1 ? Local Player : Null, Sphere, First Of(Sorted Array(Filtered Array(Append To Array(
			Mapped Array(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.positionControl), Mapped Array(
			Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.facingControl)), Distance Between(
			Eye Position(Local Player) + Facing Direction Of(Local Player) * Distance Between(Eye Position(Local Player),
			Current Array Element[2]), Current Array Element[2]) <= 1.250), -1 * Dot Product(Facing Direction Of(Local Player),
			Direction Towards(Eye Position(Local Player), Current Array Element[2]))))[1] == Evaluate Once(
			Global.nextSelectionEntityId + 1) ? Color(Orange) : Color(Yellow), Update Every Frame(Ray Cast Hit Position(Eye Position(
			Event Player), Eye Position(Event Player) + Facing Direction Of(Event Player) * 5, Null, Null, False)),
			Local Player.selectedControl[1] == Evaluate Once(Global.nextSelectionEntityId + 1) ? 0.100 : 0.250,
			Visible To Position and Radius);
		Create Beam Effect(Entity Exists(Local Player) && Is Dummy Bot(First Of(Event Player.facingControl)) && Is Alive(First Of(
			Event Player.facingControl)) && First Of(Event Player.facingControl).replayState == Custom String("NONE")
			&& Local Player.botControlMode == 1 ? Local Player : Null, Grapple Beam, Update Every Frame(Eye Position(Event Player)),
			Update Every Frame(Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(
			Event Player) * 5, Null, Null, False)), Null, Visible To Position and Radius);
		Global.nextSelectionEntityId += 2;
	}
}

rule("[interface/dummyBotsAndReplay/botPlacementModule.ostw] Create effects on closest selection entity")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create Effect(Entity Exists(Local Player) && Local Player.botControlMode == 1 && !Is Button Held(Local Player, Button(
			Primary Fire)) && First Of(Sorted Array(Filtered Array(Append To Array(Mapped Array(Filtered Array(All Players(All Teams),
			Is Dummy Bot(Current Array Element) && Current Array Element.replayState == Custom String("NONE")),
			Current Array Element.positionControl), Mapped Array(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.facingControl)), Distance Between(
			Eye Position(Local Player) + Facing Direction Of(Local Player) * Distance Between(Eye Position(Local Player),
			Current Array Element[2]), Current Array Element[2]) <= 1.250), -1 * Dot Product(Facing Direction Of(Local Player),
			Direction Towards(Eye Position(Local Player), Current Array Element[2]))))[1] != 0 && Is Alive(First Of(First Of(Sorted Array(
			Filtered Array(Append To Array(Mapped Array(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.positionControl), Mapped Array(
			Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.facingControl)), Distance Between(
			Eye Position(Local Player) + Facing Direction Of(Local Player) * Distance Between(Eye Position(Local Player),
			Current Array Element[2]), Current Array Element[2]) <= 1.250), -1 * Dot Product(Facing Direction Of(Local Player),
			Direction Towards(Eye Position(Local Player), Current Array Element[2])))))) ? Local Player : Null, Sphere, Color(Blue),
			First Of(Sorted Array(Filtered Array(Append To Array(Mapped Array(Filtered Array(All Players(All Teams), Is Dummy Bot(
			Current Array Element) && Current Array Element.replayState == Custom String("NONE")), Current Array Element.positionControl),
			Mapped Array(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.facingControl)), Distance Between(
			Eye Position(Local Player) + Facing Direction Of(Local Player) * Distance Between(Eye Position(Local Player),
			Current Array Element[2]), Current Array Element[2]) <= 1.250), -1 * Dot Product(Facing Direction Of(Local Player),
			Direction Towards(Eye Position(Local Player), Current Array Element[2]))))[2], 0.250, Visible To Position and Radius);
		Create HUD Text(Entity Exists(Local Player) && Local Player.botControlMode == 1 ? Local Player : Null, Null, Null, Custom String(
			"Editing Bots"), Top, 10, Color(White), Color(White), Custom Color(X Component Of(Global.rainbowVector), Y Component Of(
			Global.rainbowVector), Z Component Of(Global.rainbowVector), 255), Visible To String and Color, Default Visibility);
		Create In-World Text(Entity Exists(Local Player)
			&& Local Player.botControlMode == 1 && Local Player.currentMenuState == 0 && Local Player.selectedControl[1] == 0 && First Of(
			Sorted Array(Filtered Array(Append To Array(Mapped Array(Filtered Array(All Players(All Teams), Is Dummy Bot(
			Current Array Element) && Current Array Element.replayState == Custom String("NONE")), Current Array Element.positionControl),
			Mapped Array(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.facingControl)), Distance Between(
			Eye Position(Local Player) + Facing Direction Of(Local Player) * Distance Between(Eye Position(Local Player),
			Current Array Element[2]), Current Array Element[2]) <= 1.250), -1 * Dot Product(Facing Direction Of(Local Player),
			Direction Towards(Eye Position(Local Player), Current Array Element[2]))))[1] != 0 && Is Alive(First Of(First Of(Sorted Array(
			Filtered Array(Append To Array(Mapped Array(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.positionControl), Mapped Array(
			Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.facingControl)), Distance Between(
			Eye Position(Local Player) + Facing Direction Of(Local Player) * Distance Between(Eye Position(Local Player),
			Current Array Element[2]), Current Array Element[2]) <= 1.250), -1 * Dot Product(Facing Direction Of(Local Player),
			Direction Towards(Eye Position(Local Player), Current Array Element[2])))))) ? Local Player : Null, Custom String(
			"{0} | Drag{1}", Input Binding String(Button(Primary Fire)), First Of(Sorted Array(Filtered Array(Append To Array(Mapped Array(
			Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.positionControl), Mapped Array(
			Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.facingControl)), Distance Between(
			Eye Position(Local Player) + Facing Direction Of(Local Player) * Distance Between(Eye Position(Local Player),
			Current Array Element[2]), Current Array Element[2]) <= 1.250), -1 * Dot Product(Facing Direction Of(Local Player),
			Direction Towards(Eye Position(Local Player), Current Array Element[2]))))[3] == 1 ? Custom String("\n{0} | Edit Bot",
			Input Binding String(Button(Secondary Fire))) : Custom String("")), First Of(Sorted Array(Filtered Array(Append To Array(
			Mapped Array(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.positionControl), Mapped Array(
			Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.replayState == Custom String("NONE")), Current Array Element.facingControl)), Distance Between(
			Eye Position(Local Player) + Facing Direction Of(Local Player) * Distance Between(Eye Position(Local Player),
			Current Array Element[2]), Current Array Element[2]) <= 1.250), -1 * Dot Product(Facing Direction Of(Local Player),
			Direction Towards(Eye Position(Local Player), Current Array Element[2]))))[2] + Up, 1.500, Do Not Clip,
			Visible To Position and String, Color(White), Default Visibility);
	}
}

rule("[interface/dummyBotsAndReplay/botPlacementModule.ostw] Update position control orb")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Event Player.replayState == Custom String("NONE");
		Distance Between(Position Of(Event Player) + Up, Event Player.positionControl[2]) > 0.010;
	}

	actions
	{
		Event Player.positionControl[2] = Position Of(Event Player) + Up;
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[interface/dummyBotsAndReplay/botPlacementModule.ostw] Update facing control orb")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Event Player.replayState == Custom String("NONE");
		Distance Between(Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(Event Player)
			* 5, Null, Null, False), Event Player.facingControl[2]) > 0.010;
	}

	actions
	{
		Event Player.facingControl[2] = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(
			Event Player) * 5, Null, Null, False);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Initialize the gay (Patriq made me name it this, it actually just initialize the rainbow color changing)")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Chase Global Variable At Rate(rainbowVector, Vector(Min(Max(Absolute Value(Total Time Elapsed * 500 % 765 - 382.500), 127.500),
			255), Min(Max(Absolute Value((Total Time Elapsed * 500 + 255) % 765 - 382.500), 127.500), 255), Min(Max(Absolute Value((
			Total Time Elapsed * 500 + 510) % 765 - 382.500), 127.500), 255)), 99999, Destination and Rate);
	}
}

rule("[interface/dummyBotsAndReplay/botEditPage.del] When a bot becomes selected, initialize display options")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.selectedBot != Null;
	}

	actions
	{
		If(First Of(Event Player.selectedBot._extendedPlayerCollection[2]) != Null);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[7] = Custom String("Clear Respawn Point");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[7] = Color(Orange);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
		Else;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[7] = Custom String("Set Respawn Point");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[7] = Color(Yellow);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
		End;
		If(First Of(Event Player.selectedBot.pinnedPosition) != Null);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[17] = Custom String("Unpin Bot");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[17] = Color(Orange);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
		Else;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[17] = Custom String("Pin Bot");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[17] = Color(Orange);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
		End;
		If(Event Player.selectedBot.totalFrames > 0);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[12] = Custom String("Play Replay");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[12] = Color(Lime Green);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[11] = Custom String("Edit Replay");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[11] = Color(Turquoise);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[10] = Custom String("Delete Replay");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[10] = Color(Red);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
		Else;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[12] = Custom String("Record Replay");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[12] = Custom Color(186, 70, 213, 255);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[11] = Custom String("Edit Replay");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[11] = Color(Gray);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[10] = Custom String("Delete Replay");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[10] = Color(Gray);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
		End;
		If(Event Player.selectedBot.isPunchingBag);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[8] = Custom String("Make Normal Bot");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[8] = Custom Color(244, 205, 116, 255);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
		Else;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[8] = Custom String("Make Punching Bag");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[8] = Color(Purple);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
		End;
		Wait Until(Event Player.selectedBot != Evaluate Once(Event Player.selectedBot)
			|| Event Player.selectedBot.totalFrames != Evaluate Once(Event Player.selectedBot.totalFrames), 1000000);
		Loop If Condition Is True;
	}
}

rule("[SUB | interface/dummyBotsAndReplay/botEditPage.del] Store data from bot onto player")
{
	event
	{
		Subroutine;
		StoreTempDataFromBot;
	}

	actions
	{
		Event Player.tempHeroStorage = Hero Of(Event Player.selectedBot);
		Event Player._extendedPlayerCollection[11] = Array(Position Of(Event Player.selectedBot), Eye Position(Event Player.selectedBot),
			Facing Direction Of(Event Player.selectedBot));
		Event Player._extendedPlayerCollection[6] = Event Player.selectedBot.isPunchingBag;
		Event Player._extendedPlayerCollection[7] = Event Player.selectedBot.pinnedPosition;
		Event Player._extendedPlayerCollection[8] = Event Player.selectedBot._extendedPlayerCollection[2];
		Event Player._extendedPlayerCollection[9] = Event Player.selectedBot.replayResetPoint;
		Event Player._extendedPlayerCollection[10] = Team Of(Event Player.selectedBot);
		"Temporarily store recording on player who is performing the action"
		If(Event Player.selectedBot.totalFrames > 0);
			Global.logBuffer = Custom String("{0}{1}", Custom String("{0}{1}{2}", Custom String("{0}{1}{2}", Custom String("{0}{1}{2}",
				Custom String("TR "), Team Of(Event Player.selectedBot), Custom String(" ")), Slot Of(Event Player.selectedBot), Custom String(
				" ")), Team Of(Event Player), Custom String(" ")), Slot Of(Event Player));
			Enable Inspector Recording;
			Log To Inspector(Global.logBuffer);
			If(First Of(Global._extendedGlobalCollection));
				Disable Inspector Recording;
			End;
			Global.logBuffer = Custom String("");
			Event Player.recording_changes_type = Event Player.selectedBot.recording_changes_type;
			Event Player.recording_changes_new_value = Event Player.selectedBot.recording_changes_new_value;
			Event Player.recording_frame = Event Player.selectedBot.recording_frame;
			Event Player.totalFrames = Event Player.selectedBot.totalFrames;
			Event Player.playbackOffset = Event Player.selectedBot.playbackOffset;
			Event Player.recordingHero = Event Player.selectedBot.recordingHero;
			Event Player.selectedBot.recording_changes_type = Array(Empty Array);
			Event Player.selectedBot.recording_changes_new_value = Array(Empty Array);
			Event Player.selectedBot.recording_frame = Array(Empty Array);
			Event Player.selectedBot.totalFrames = 0;
			Event Player.selectedBot.playbackOffset = 0;
			Event Player.selectedBot.recordingHero = Null;
		End;
	}
}

rule("[SUB | interface/dummyBotsAndReplay/botEditPage.del] Load data from player onto bot")
{
	event
	{
		Subroutine;
		LoadTempDataToSelectedBot;
	}

	actions
	{
		If(Event Player._extendedPlayerCollection[6]);
			Event Player.bot_0 = Last Created Entity;
			Event Player.bot_0.isPunchingBag = True;
			Add Health Pool To Player(Event Player.bot_0, Health, 1250, True, False);
			Event Player.bot_0._extendedPlayerCollection[5] = Last Created Health Pool;
		End;
		If(First Of(Event Player._extendedPlayerCollection[7]) != Null);
			Event Player.selectedBot.pinnedPosition = Event Player._extendedPlayerCollection[7];
		End;
		If(First Of(Event Player._extendedPlayerCollection[9]) != Null);
			Event Player.selectedBot.replayResetPoint = Event Player._extendedPlayerCollection[9];
		End;
		If(First Of(Event Player._extendedPlayerCollection[8]) != Null);
			Event Player.selectedBot._extendedPlayerCollection[2] = Event Player._extendedPlayerCollection[8];
			Create Effect(Entity Exists(Local Player) && Is Dummy Bot(First Of(Event Player.selectedBot.positionControl)) && Is Alive(First Of(
				Event Player.selectedBot.positionControl)) && First Of(Event Player.selectedBot.positionControl).replayState == Custom String(
				"NONE") && Local Player.botControlMode == 1 ? Local Player : Null, Sphere, Color(Green), First Of(
				Event Player.selectedBot._extendedPlayerCollection[2]), 0.500, Visible To Position and Radius);
			Event Player._extendedPlayerCollection[12] = Last Created Entity;
			Create Beam Effect(Entity Exists(Local Player) && Is Dummy Bot(First Of(Event Player.selectedBot.positionControl)) && Is Alive(
				First Of(Event Player.selectedBot.positionControl)) && First Of(Event Player.selectedBot.positionControl)
				.replayState == Custom String("NONE") && Local Player.botControlMode == 1 ? Local Player : Null, Good Beam, First Of(
				Event Player.selectedBot._extendedPlayerCollection[2]) + Vector(0, 0.250, 0), First Of(
				Event Player.selectedBot._extendedPlayerCollection[2]) + Event Player.selectedBot._extendedPlayerCollection[2][2] + Vector(0,
				0.250, 0), Team Of(Event Player.selectedBot), Visible To Position and Radius);
			Event Player._extendedPlayerCollection[13] = Last Created Entity;
		End;
		Wait(0.064, Ignore Condition);
		"We wait to transfer the recording to the new bot to avoid overloading the server"
		If(Event Player.totalFrames > 0);
			Global.logBuffer = Custom String("{0}{1}", Custom String("{0}{1}{2}", Custom String("{0}{1}{2}", Custom String("{0}{1}{2}",
				Custom String("TR "), Team Of(Event Player), Custom String(" ")), Slot Of(Event Player), Custom String(" ")), Team Of(
				Event Player.selectedBot), Custom String(" ")), Slot Of(Event Player.selectedBot));
			Enable Inspector Recording;
			Log To Inspector(Global.logBuffer);
			If(First Of(Global._extendedGlobalCollection));
				Disable Inspector Recording;
			End;
			Global.logBuffer = Custom String("");
			Event Player.selectedBot.recording_changes_type = Event Player.recording_changes_type;
			Event Player.selectedBot.recording_changes_new_value = Event Player.recording_changes_new_value;
			Event Player.selectedBot.recording_frame = Event Player.recording_frame;
			Event Player.selectedBot.totalFrames = Event Player.totalFrames;
			Event Player.selectedBot.playbackOffset = Event Player.playbackOffset;
			Event Player.selectedBot.recordingHero = Event Player.recordingHero;
			Event Player.recording_changes_type = Array(Empty Array);
			Event Player.recording_changes_new_value = Array(Empty Array);
			Event Player.recording_frame = Array(Empty Array);
			Event Player.totalFrames = 0;
			Event Player.playbackOffset = 0;
			Event Player.recordingHero = Null;
		End;
		If(Event Player.selectedBot.totalFrames > 0);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[12] = Custom String("Play Replay");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[12] = Color(Lime Green);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[11] = Custom String("Edit Replay");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[11] = Color(Turquoise);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[10] = Custom String("Delete Replay");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[10] = Color(Red);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
		Else;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[12] = Custom String("Record Replay");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[12] = Custom Color(186, 70, 213, 255);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[11] = Custom String("Edit Replay");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[11] = Color(Gray);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[10] = Custom String("Delete Replay");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[10] = Color(Gray);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
		End;
		Wait(0.064, Ignore Condition);
		Teleport(Event Player.selectedBot, First Of(Event Player._extendedPlayerCollection[11]));
		Stop Facing(Event Player.selectedBot);
		Wait(0.016, Ignore Condition);
		Set Facing(Event Player.selectedBot, Event Player._extendedPlayerCollection[11][2], To World);
		"Because for SOME REASON setting FACING and TELEPORTING in the SAME FRAME cancels the TELEPORT"
		Wait(0.032, Ignore Condition);
		Start Facing(Event Player.selectedBot, Event Player._extendedPlayerCollection[11][2], 1000, To World, Direction and Turn Rate);
		Wait(0.016, Ignore Condition);
		Wait Until(Angle Between Vectors(Facing Direction Of(Event Player.selectedBot), Event Player._extendedPlayerCollection[11][2])
			< 0.100, 0.250);
		Stop Facing(Event Player.selectedBot);
	}
}

rule("[interface/dummyBotsAndReplay/botEditPage.del] Handle bot edit actions")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.selectedBotEditAction != 0;
	}

	actions
	{
		Skip(Array(213, 0, 33, 40, 70, 72, 92, 124, 158, 180, 192)[Index Of Array Value(Array(2, 1, 5, 4, 6, 7, 8, 9, 3, 10),
			Event Player.selectedBotEditAction) + 1]);
		"[CASE] Change hero"
		If(Event Player.selectedBot.totalFrames > 0);
			Small Message(Event Player, Custom String("  Replays are hero-specific and cannot be transferred between heroes!"));
			Small Message(Event Player, Custom String("  Delete the replay before changing the bot's hero."));
			Play Effect(Event Player, Debuff Impact Sound, Null, Event Player, 100);
			Skip(27);
		End;
		Call Subroutine(StoreTempDataFromBot);
		Event Player.tempHeroStorage = Hero Of(Event Player);
		Set Player Allowed Heroes(Event Player, Remove From Array(All Heroes, Event Player.tempHeroStorage));
		Wait Until(!Has Spawned(Event Player), 1);
		Reset Player Hero Availability(Event Player);
		Wait Until(Has Spawned(Event Player), 1000000);
		Destroy Dummy Bot(Team Of(Event Player.selectedBot), Slot Of(Event Player.selectedBot));
		Wait(0.064, Ignore Condition);
		Create Dummy Bot(Hero Of(Event Player), Event Player._extendedPlayerCollection[10], -1, First Of(
			Event Player._extendedPlayerCollection[11]), Event Player._extendedPlayerCollection[11][2]);
		Event Player.selectedBot = Last Created Entity;
		Start Forcing Player To Be Hero(Event Player, Event Player.tempHeroStorage);
		Wait(0.016, Ignore Condition);
		Stop Forcing Player To Be Hero(Event Player);
		Wait(0.064, Ignore Condition);
		Teleport(Event Player, First Of(Event Player.menuActivationPoint));
		Stop Facing(Event Player);
		Wait(0.016, Ignore Condition);
		Set Facing(Event Player, Event Player.menuActivationPoint[2], To World);
		"Because for SOME REASON setting FACING and TELEPORTING in the SAME FRAME cancels the TELEPORT"
		Wait(0.032, Ignore Condition);
		Start Facing(Event Player, Event Player.menuActivationPoint[2], 1000, To World, Direction and Turn Rate);
		Wait(0.016, Ignore Condition);
		Wait Until(Angle Between Vectors(Facing Direction Of(Event Player), Event Player.menuActivationPoint[2]) < 0.100, 0.250);
		Stop Facing(Event Player);
		Event Player.selectedControl = Null;
		Event Player.currentMenuState = 0;
		Call Subroutine(LoadTempDataToSelectedBot);
		Skip(180);
		"[CASE] Change team"
		Call Subroutine(StoreTempDataFromBot);
		Destroy Dummy Bot(Team Of(Event Player.selectedBot), Slot Of(Event Player.selectedBot));
		Wait(0.064, Ignore Condition);
		Create Dummy Bot(Event Player.tempHeroStorage, Opposite Team Of(Event Player._extendedPlayerCollection[10]), -1, First Of(
			Event Player._extendedPlayerCollection[11]), Event Player._extendedPlayerCollection[11][2]);
		Event Player.selectedBot = Last Created Entity;
		Call Subroutine(LoadTempDataToSelectedBot);
		Skip(173);
		"[CASE] Set respawn point"
		If(First Of(Event Player.selectedBot._extendedPlayerCollection[2]) == Null);
			Event Player.selectedBot._extendedPlayerCollection[2] = Array(Position Of(Event Player.selectedBot), Eye Position(
				Event Player.selectedBot), Facing Direction Of(Event Player.selectedBot));
			Play Effect(Event Player, Buff Impact Sound, Null, Event Player, 100);
			Small Message(Event Player, Custom String("Respawn point set!"));
			Create Effect(Entity Exists(Local Player) && Is Dummy Bot(First Of(Event Player.selectedBot.positionControl)) && Is Alive(First Of(
				Event Player.selectedBot.positionControl)) && First Of(Event Player.selectedBot.positionControl).replayState == Custom String(
				"NONE") && Local Player.botControlMode == 1 ? Local Player : Null, Sphere, Color(Green), First Of(
				Event Player.selectedBot._extendedPlayerCollection[2]), 0.500, Visible To Position and Radius);
			Event Player._extendedPlayerCollection[12] = Last Created Entity;
			Create Beam Effect(Entity Exists(Local Player) && Is Dummy Bot(First Of(Event Player.selectedBot.positionControl)) && Is Alive(
				First Of(Event Player.selectedBot.positionControl)) && First Of(Event Player.selectedBot.positionControl)
				.replayState == Custom String("NONE") && Local Player.botControlMode == 1 ? Local Player : Null, Good Beam, First Of(
				Event Player.selectedBot._extendedPlayerCollection[2]) + Vector(0, 0.250, 0), First Of(
				Event Player.selectedBot._extendedPlayerCollection[2]) + Event Player.selectedBot._extendedPlayerCollection[2][2] + Vector(0,
				0.250, 0), Team Of(Event Player.selectedBot), Visible To Position and Radius);
			Event Player._extendedPlayerCollection[13] = Last Created Entity;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[7] = Custom String("Clear Respawn Point");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[7] = Color(Orange);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
		Else;
			Global._arrayConstructor = Event Player.selectedBot._extendedPlayerCollection[2];
			Global._arrayConstructor[0] = Null;
			Event Player.selectedBot._extendedPlayerCollection[2] = Global._arrayConstructor;
			Play Effect(Event Player, Debuff Impact Sound, Null, Event Player, 100);
			Small Message(Event Player, Custom String("Respawn point cleared"));
			Destroy Effect(Event Player._extendedPlayerCollection[12]);
			Destroy Effect(Event Player._extendedPlayerCollection[13]);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[7] = Custom String("Set Respawn Point");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[7] = Color(Yellow);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
		End;
		Skip(143);
		"[CASE] Edit button control"
		Event Player.currentMenuState = 9;
		Skip(141);
		"[CASE] Pin/unpin bot to position"
		If(First Of(Event Player.selectedBot.pinnedPosition) == Null);
			Event Player.selectedBot.pinnedPosition = Array(Position Of(Event Player.selectedBot), Eye Position(Event Player.selectedBot),
				Facing Direction Of(Event Player.selectedBot));
			Small Message(Event Player, Custom String("  Pinned bot to current position"));
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[17] = Custom String("Unpin Bot");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[17] = Color(Orange);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
		Else;
			Event Player.selectedBot.pinnedPosition = Null;
			Small Message(Event Player, Custom String("  Unpinned bot"));
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[17] = Custom String("Pin Bot");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[17] = Color(Orange);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
		End;
		Skip(121);
		"[CASE] Record replay"
		If(Array Contains(Array(Custom String("PREPARING_FOR_PLAYBACK"), Custom String("PLAYING"), Custom String("REACHED_END_OF_REPLAY")),
			Event Player.selectedBot.replayState));
			If(Event Player.selectedBot == Null);
				Small Message(Event Player, Custom String("  No bot selected, this is a bug!"));
				Wait(0.250, Ignore Condition);
				Small Message(Event Player, Custom String("  Please report this to CactusPuppy."));
				Skip(25);
			End;
			Event Player.selectedBot.replayStateAction = Custom String("STOP_PLAYBACK");
			Skip(22);
		End;
		If(Event Player.replayState == Custom String("RECORDING"));
			Small Message(Event Player, Custom String("  Menu opening should end recording. This is a bug!"));
			Wait(0.250, Ignore Condition);
			Small Message(Event Player, Custom String("  Please report this to CactusPuppy."));
			Skip(16);
		End;
		If(Event Player.replayState == Custom String("NONE"));
			If(Event Player.selectedBot == Null);
				Small Message(Event Player, Custom String("  No bot selected, this is a bug!"));
				Wait(0.250, Ignore Condition);
				Small Message(Event Player, Custom String("  Please report this to CactusPuppy."));
				Skip(9);
			End;
			If(Event Player.selectedBot.totalFrames > 0);
				Event Player.selectedBot.replayStateAction = Custom String("PREPARE_FOR_PLAYBACK");
				Event Player.currentMenuState = 0;
			Else;
				Event Player.replayStateAction = Custom String("PREPARE_TO_RECORD");
			End;
			Skip(1);
		End;
		Skip(89);
		"[CASE] Edit replay"
		If(Event Player.selectedBot == Null);
			Small Message(Event Player, Custom String("  No bot selected, this is a bug!"));
			Wait(0.250, Ignore Condition);
			Small Message(Event Player, Custom String("  Please report this to CactusPuppy."));
			Skip(28);
		End;
		If(Event Player.selectedBot.totalFrames > 0);
			Event Player.currentMenuState = 8;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
			Global._arrayConstructor[12] = Event Player.selectedBot.playbackOffset;
			Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[8];
			Global._arrayConstructor[12] = Color(White);
			Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
			If(Event Player.selectedBot.playbackOffset == 1);
				Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
				Global._arrayConstructor[17] = Custom String("FRAME");
				Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
				Global._arrayConstructor = Event Player.ButtonColorGrid[8];
				Global._arrayConstructor[17] = Color(White);
				Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
			Else;
				Global._arrayConstructor = Event Player.ButtonLabelGrid[8];
				Global._arrayConstructor[17] = Custom String("FRAMES");
				Event Player.ButtonLabelGrid[8] = Global._arrayConstructor;
				Global._arrayConstructor = Event Player.ButtonColorGrid[8];
				Global._arrayConstructor[17] = Color(White);
				Event Player.ButtonColorGrid[8] = Global._arrayConstructor;
			End;
		Else;
			Small Message(Event Player, Custom String("  No replay recorded. Record a replay first!"));
			Play Effect(Event Player, Debuff Impact Sound, Null, Event Player, 100);
		End;
		Skip(55);
		"[CASE] Delete replay"
		If(Event Player.selectedBot == Null);
			Small Message(Event Player, Custom String("  No bot selected, this is a bug!"));
			Wait(0.250, Ignore Condition);
			Small Message(Event Player, Custom String("  Please report this to CactusPuppy."));
			Skip(16);
		End;
		If(Event Player.selectedBot.totalFrames > 0);
			Event Player.actionToConfirm = Custom String("delete this replay");
			Event Player.confirmationState = 0;
			Event Player.currentMenuState = 2;
			Wait Until(Event Player.confirmationState != 0, 1000000);
			If(Event Player.confirmationState == 1);
				Event Player.selectedBot.recordingPlayStopFlag = 3;
				Wait(0.500, Ignore Condition);
				Small Message(Event Player, Custom String("  Replay deleted"));
			End;
			Event Player.currentMenuState = 7;
		Else;
			Small Message(Event Player, Custom String("  No replay to delete"));
			Play Effect(Event Player, Debuff Impact Sound, Null, Event Player, 100);
		End;
		Skip(33);
		"[CASE] Delete bot"
		Event Player.actionToConfirm = Custom String("{0}{1}", Custom String("delete "), Event Player.selectedBot);
		Event Player.confirmationState = 0;
		Event Player.currentMenuState = 2;
		Wait Until(Event Player.confirmationState != 0, 1000000);
		If(Event Player.confirmationState == 1);
			Destroy Dummy Bot(Team Of(Event Player.selectedBot), Slot Of(Event Player.selectedBot));
			Event Player.selectedBot = Null;
			Event Player.currentMenuState = 0;
		Else;
			Event Player.currentMenuState = 7;
		End;
		Skip(21);
		"[CASE] Toggle whether bot is a punching bag"
		If(Event Player.selectedBot.isPunchingBag);
			Event Player.selectedBot.isPunchingBag = False;
			Remove Health Pool From Player(Event Player.selectedBot._extendedPlayerCollection[5]);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[8] = Custom String("Make Punching Bag");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[8] = Color(Purple);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
		Else;
			Event Player.bot_1 = Event Player.selectedBot;
			Event Player.bot_1.isPunchingBag = True;
			Add Health Pool To Player(Event Player.bot_1, Health, 1250, True, False);
			Event Player.bot_1._extendedPlayerCollection[5] = Last Created Health Pool;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[7];
			Global._arrayConstructor[8] = Custom String("Make Normal Bot");
			Event Player.ButtonLabelGrid[7] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[7];
			Global._arrayConstructor[8] = Custom Color(244, 205, 116, 255);
			Event Player.ButtonColorGrid[7] = Global._arrayConstructor;
		End;
	}
}

rule("[interface/dummyBotsAndReplay/botEditPage.del] Handle pinning bot to current position")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		First Of(Event Player.pinnedPosition) != Null;
	}

	actions
	{
		While(First Of(Event Player.pinnedPosition) != Null);
			Start Forcing Player Position(Event Player, First Of(Event Player.pinnedPosition), True);
			Wait Until(First Of(Event Player.pinnedPosition) == Null, 0.200);
			Stop Forcing Player Position(Event Player);
			Wait(0.016, Ignore Condition);
		End;
		Wait(0.016, Ignore Condition);
		If(Speed Of(Event Player) > 0.050);
			Apply Impulse(Event Player, Velocity Of(Event Player) * -1, 0.010, To World, Cancel Contrary Motion XYZ);
		End;
	}
}

rule("[interface/dummyBotsAndReplay/botEditPage_ButtonsControl] Primary fire control")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Primary Fire))] != Custom String("None");
	}

	actions
	{
		If(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Primary Fire))] == Custom String("Holding"));
			Start Holding Button(Event Player, Button(Primary Fire));
		Else;
			Stop Holding Button(Event Player, Button(Primary Fire));
		End;
		While(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Primary Fire))] == Custom String(
			"Spamming"));
			Start Holding Button(Event Player, Button(Primary Fire));
			Wait(0.064, Ignore Condition);
			Stop Holding Button(Event Player, Button(Primary Fire));
			Wait(Global.BUTTON_SPAM_PERIOD, Abort When False);
		End;
		Wait Until(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Primary Fire))] != Evaluate Once(
			Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Primary Fire))]), 1000000);
		Loop If Condition Is True;
	}
}

rule("If secondary fire button is marked as being spammed, start spamming it")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Secondary Fire))] != Custom String("None");
	}

	actions
	{
		If(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Secondary Fire))] == Custom String("Holding"));
			Start Holding Button(Event Player, Button(Secondary Fire));
		Else;
			Stop Holding Button(Event Player, Button(Secondary Fire));
		End;
		While(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Secondary Fire))] == Custom String(
			"Spamming"));
			Start Holding Button(Event Player, Button(Secondary Fire));
			Wait(0.064, Ignore Condition);
			Stop Holding Button(Event Player, Button(Secondary Fire));
			Wait(Global.BUTTON_SPAM_PERIOD, Abort When False);
		End;
		Wait Until(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Secondary Fire))] != Evaluate Once(
			Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Secondary Fire))]), 1000000);
		Loop If Condition Is True;
	}
}

rule("If Ability 1 button is marked as being spammed, start spamming it")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Ability 1))] != Custom String("None");
	}

	actions
	{
		If(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Ability 1))] == Custom String("Holding"));
			Start Holding Button(Event Player, Button(Ability 1));
		Else;
			Stop Holding Button(Event Player, Button(Ability 1));
		End;
		While(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Ability 1))] == Custom String("Spamming"));
			Start Holding Button(Event Player, Button(Ability 1));
			Wait(0.064, Ignore Condition);
			Stop Holding Button(Event Player, Button(Ability 1));
			Wait(Global.BUTTON_SPAM_PERIOD, Abort When False);
		End;
		Wait Until(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Ability 1))] != Evaluate Once(
			Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Ability 1))]), 1000000);
		Loop If Condition Is True;
	}
}

rule("If Ability 2 button is marked as being spammed, start spamming it")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Ability 2))] != Custom String("None");
	}

	actions
	{
		If(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Ability 2))] == Custom String("Holding"));
			Start Holding Button(Event Player, Button(Ability 2));
		Else;
			Stop Holding Button(Event Player, Button(Ability 2));
		End;
		While(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Ability 2))] == Custom String("Spamming"));
			Start Holding Button(Event Player, Button(Ability 2));
			Wait(0.064, Ignore Condition);
			Stop Holding Button(Event Player, Button(Ability 2));
			Wait(Global.BUTTON_SPAM_PERIOD, Abort When False);
		End;
		Wait Until(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Ability 2))] != Evaluate Once(
			Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Ability 2))]), 1000000);
		Loop If Condition Is True;
	}
}

rule("If Ultimate button is marked as being spammed, start spamming it")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Ultimate))] != Custom String("None");
	}

	actions
	{
		If(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Ultimate))] == Custom String("Holding"));
			Start Holding Button(Event Player, Button(Ultimate));
		Else;
			Stop Holding Button(Event Player, Button(Ultimate));
		End;
		While(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Ultimate))] == Custom String("Spamming"));
			Start Holding Button(Event Player, Button(Ultimate));
			Wait(0.064, Ignore Condition);
			Stop Holding Button(Event Player, Button(Ultimate));
			Wait(Global.BUTTON_SPAM_PERIOD, Abort When False);
		End;
		Wait Until(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Ultimate))] != Evaluate Once(
			Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Ultimate))]), 1000000);
		Loop If Condition Is True;
	}
}

rule("If Interact button is marked as being spammed, start spamming it")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Interact))] != Custom String("None");
	}

	actions
	{
		If(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Interact))] == Custom String("Holding"));
			Start Holding Button(Event Player, Button(Interact));
		Else;
			Stop Holding Button(Event Player, Button(Interact));
		End;
		While(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Interact))] == Custom String("Spamming"));
			Start Holding Button(Event Player, Button(Interact));
			Wait(0.064, Ignore Condition);
			Stop Holding Button(Event Player, Button(Interact));
			Wait(Global.BUTTON_SPAM_PERIOD, Abort When False);
		End;
		Wait Until(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Interact))] != Evaluate Once(
			Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Interact))]), 1000000);
		Loop If Condition Is True;
	}
}

rule("If Reload button is marked as being spammed, start spamming it")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Reload))] != Custom String("None");
	}

	actions
	{
		If(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Reload))] == Custom String("Holding"));
			Start Holding Button(Event Player, Button(Reload));
		Else;
			Stop Holding Button(Event Player, Button(Reload));
		End;
		While(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Reload))] == Custom String("Spamming"));
			Start Holding Button(Event Player, Button(Reload));
			Wait(0.064, Ignore Condition);
			Stop Holding Button(Event Player, Button(Reload));
			Wait(Global.BUTTON_SPAM_PERIOD, Abort When False);
		End;
		Wait Until(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Reload))] != Evaluate Once(
			Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Reload))]), 1000000);
		Loop If Condition Is True;
	}
}

rule("If Jump button is marked as being spammed, start spamming it")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Jump))] != Custom String("None");
	}

	actions
	{
		If(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Jump))] == Custom String("Holding"));
			Start Holding Button(Event Player, Button(Jump));
		Else;
			Stop Holding Button(Event Player, Button(Jump));
		End;
		While(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Jump))] == Custom String("Spamming"));
			Start Holding Button(Event Player, Button(Jump));
			Wait(0.064, Ignore Condition);
			Stop Holding Button(Event Player, Button(Jump));
			Wait(Global.BUTTON_SPAM_PERIOD, Abort When False);
		End;
		Wait Until(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Jump))] != Evaluate Once(
			Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Jump))]), 1000000);
		Loop If Condition Is True;
	}
}

rule("If Crouch button is marked as being spammed, start spamming it")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Crouch))] != Custom String("None");
	}

	actions
	{
		If(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Crouch))] == Custom String("Holding"));
			Start Holding Button(Event Player, Button(Crouch));
		Else;
			Stop Holding Button(Event Player, Button(Crouch));
		End;
		While(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Crouch))] == Custom String("Spamming"));
			Start Holding Button(Event Player, Button(Crouch));
			Wait(0.064, Ignore Condition);
			Stop Holding Button(Event Player, Button(Crouch));
			Wait(Global.BUTTON_SPAM_PERIOD, Abort When False);
		End;
		Wait Until(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Crouch))] != Evaluate Once(
			Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Crouch))]), 1000000);
		Loop If Condition Is True;
	}
}

rule("If Melee button is marked as being spammed, start spamming it")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Melee))] != Custom String("None");
	}

	actions
	{
		If(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Melee))] == Custom String("Holding"));
			Start Holding Button(Event Player, Button(Melee));
		Else;
			Stop Holding Button(Event Player, Button(Melee));
		End;
		While(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Melee))] == Custom String("Spamming"));
			Start Holding Button(Event Player, Button(Melee));
			Wait(0.064, Ignore Condition);
			Stop Holding Button(Event Player, Button(Melee));
			Wait(Global.BUTTON_SPAM_PERIOD, Abort When False);
		End;
		Wait Until(Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Melee))] != Evaluate Once(
			Event Player.buttonControlStates[Index Of Array Value(Global.AllButtons, Button(Melee))]), 1000000);
		Loop If Condition Is True;
	}
}

rule("When player enters this menu, set menuXIndex and menuYIndex to 0")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.currentMenuState == 9;
	}

	actions
	{
		Event Player.menuXIndex = 0;
		Event Player.menuYIndex = 0;
	}
}

rule("When player is holding Reload in the button control menu, start holding the current button until reload is released")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.currentMenuState == 9;
		Is Button Held(Event Player, Button(Reload)) == True;
	}

	actions
	{
		Event Player.cacheMenuYIndex = Event Player.menuYIndex;
		Start Holding Button(Event Player.selectedBot, Global.AllButtons[Event Player.cacheMenuYIndex]);
		Wait Until(!Is Button Held(Event Player, Button(Reload)) || Event Player.menuYIndex != Event Player.cacheMenuYIndex, 1000000);
		Stop Holding Button(Event Player.selectedBot, Global.AllButtons[Event Player.cacheMenuYIndex]);
		Loop If Condition Is True;
	}
}

rule("[UI] - HUD")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create HUD Text(Filtered Array(Local Player, Current Array Element.replayState == Custom String("RECORDING")), Icon String(
			Radioactive), Null, Custom String("Recording..."), Right, -9, Color(Red), Color(Red), Color(Red), Visible To and String,
			Default Visibility);
		Create HUD Text(Filtered Array(Local Player, Current Array Element.replayState == Custom String("RECORDING")), Null, Custom String(
			"Clip: {0} (FRAME {1})", Custom String("{0}{1}", Custom String("{0}{1}{2}", Custom String("{0}{1}{2}", Round To Integer(
			Local Player.frame * 0.016 / 60, Down) < 10 ? 0 : Custom String(""), Round To Integer(Local Player.frame * 0.016 / 60, Down),
			Custom String(":")), Round To Integer(Local Player.frame * 0.016 % 60, Down) < 10 ? 0 : Custom String(""),
			Local Player.frame * 0.016 % 60), Local Player.frame * 0.016 % 1 == 0 ? Custom String(".00") : Custom String("")),
			Local Player.frame), Null, Right, -8, Color(Red), Color(Red), Color(Red), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(Local Player, Current Array Element.replayState == Custom String("RECORDING")), Null, Custom String(
			"Hold Interact to Save"), Null, Right, -4, Color(Orange), Color(Orange), Color(Orange), Visible To and String,
			Default Visibility);
	}
}

rule("[interface/dummyBotsAndReplay/replay/replay.del] If player dies while recording, stop recording")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Event Player.replayState == Custom String("RECORDING");
	}

	actions
	{
		Event Player.replayStateAction = Custom String("STOP_PLAYBACK");
	}
}

rule("[interface/dummyBotsAndReplay/replay/replay.del] If player dies while playing, stop playing")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Event Player.replayState == Custom String("PLAYING");
	}

	actions
	{
		Event Player.replayStateAction = Custom String("STOP_PLAYBACK");
	}
}

rule("[SUB | interface/dummyBotsAndReplay/replay/replayDefs.del] Delete Recording")
{
	event
	{
		Subroutine;
		DeleteRecording;
	}

	actions
	{
		Event Player.frame = 0;
		Event Player.totalFrames = 0;
		Event Player.playbackOffset = 0;
		Event Player.recording_changes_type = Array(Empty Array);
		Event Player.recording_changes_new_value = Array(Empty Array);
		Event Player.recording_frame = Array(Empty Array);
		Event Player.replayResetPoint[0] = Null;
		Event Player.recordingHero = Null;
	}
}

rule("[interface/dummyBotsAndReplay/botEditPage.del] Handle when replay flag is set")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Event Player.recordingPlayStopFlag != 0;
	}

	actions
	{
		If(Array Contains(Array(Custom String("PREPARING_FOR_PLAYBACK"), Custom String("PLAYING"), Custom String("REACHED_END_OF_REPLAY")),
			Event Player.replayState) && Event Player.recordingPlayStopFlag == 2);
			Event Player.replayStateAction = Custom String("STOP_PLAYBACK");
		Else If(Event Player.replayState == Custom String("NONE")
				&& Event Player.recordingPlayStopFlag == 1 && Event Player.totalFrames > 0);
			Event Player.replayStateAction = Custom String("PREPARE_FOR_PLAYBACK");
		Else If(Event Player.recordingPlayStopFlag == 3);
			If(Event Player.replayState == Custom String("PLAYING"));
				Event Player.replayStateAction = Custom String("STOP_PLAYBACK");
			End;
			Call Subroutine(DeleteRecording);
		End;
		Event Player.recordingPlayStopFlag = 0;
	}
}

rule("[interface/dummyBotsAndReplay/replay/replayDefs.del] When bot is in recording state, loop every frame and record inputs")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.replayState == Custom String("RECORDING");
	}

	actions
	{
		"End the recording if the player opens the menu or switches to another hero"
		If(Event Player.currentMenuState != 0 || Hero Of(Event Player) != Event Player.recordingHero);
			Event Player.replayStateAction = Custom String("STOP_RECORDING");
			Abort;
		End;
		If(Event Player.frame >= 0);
			Global.logBuffer = Custom String("");
			Event Player.selectedBot.changeBuffer_type = Empty Array;
			Event Player.selectedBot.changeBuffer_new_value = Empty Array;
			"THROTTLE"
			If(First Of(Event Player.selectedBot.lastRecordedState) != Throttle Of(Event Player));
				Modify Player Variable(Event Player.selectedBot, changeBuffer_type, Append To Array, 0);
				Modify Player Variable(Event Player.selectedBot, changeBuffer_new_value, Append To Array, Throttle Of(Event Player));
				Event Player.selectedBot.lastRecordedState[0] = Throttle Of(Event Player);
				Global.logBuffer = Custom String("{0}{1}", Global.logBuffer, Custom String("T {0} ", Throttle Of(Event Player)));
			End;
			"FACING"
			If(Event Player.selectedBot.lastRecordedState[1] != Facing Direction Of(Event Player));
				Modify Player Variable(Event Player.selectedBot, changeBuffer_type, Append To Array, 1);
				Modify Player Variable(Event Player.selectedBot, changeBuffer_new_value, Append To Array, Facing Direction Of(Event Player));
				Event Player.selectedBot.lastRecordedState[1] = Facing Direction Of(Event Player);
				Global.logBuffer = Custom String("{0}{1}", Global.logBuffer, Custom String("F {0} ", Facing Direction Of(Event Player) * 1000));
			End;
			"WEAPON"
			If(Event Player.selectedBot.lastRecordedState[2] != Weapon(Event Player));
				Modify Player Variable(Event Player.selectedBot, changeBuffer_type, Append To Array, 2);
				Modify Player Variable(Event Player.selectedBot, changeBuffer_new_value, Append To Array, Weapon(Event Player));
				Event Player.selectedBot.lastRecordedState[2] = Weapon(Event Player);
				Global.logBuffer = Custom String("{0}{1}", Global.logBuffer, Custom String("W {0}", Weapon(Event Player)));
			End;
			"PRIMARY FIRE"
			If(Event Player.selectedBot.lastRecordedState[3] != Is Button Held(Event Player, Button(Primary Fire)));
				Modify Player Variable(Event Player.selectedBot, changeBuffer_type, Append To Array, 3);
				Modify Player Variable(Event Player.selectedBot, changeBuffer_new_value, Append To Array, Is Button Held(Event Player, Button(
					Primary Fire)));
				Event Player.selectedBot.lastRecordedState[3] = Is Button Held(Event Player, Button(Primary Fire));
				Global.logBuffer = Custom String("{0}{1}", Global.logBuffer, Custom String("PF {0}", Is Button Held(Event Player, Button(
					Primary Fire))));
			End;
			"SECONDARY FIRE"
			If(Event Player.selectedBot.lastRecordedState[4] != Is Button Held(Event Player, Button(Secondary Fire)));
				Modify Player Variable(Event Player.selectedBot, changeBuffer_type, Append To Array, 4);
				Modify Player Variable(Event Player.selectedBot, changeBuffer_new_value, Append To Array, Is Button Held(Event Player, Button(
					Secondary Fire)));
				Event Player.selectedBot.lastRecordedState[4] = Is Button Held(Event Player, Button(Secondary Fire));
				Global.logBuffer = Custom String("{0}{1}", Global.logBuffer, Custom String("SF {0}", Is Button Held(Event Player, Button(
					Secondary Fire))));
			End;
			"ABILITY 1"
			If(Event Player.selectedBot.lastRecordedState[5] != Is Button Held(Event Player, Button(Ability 1)));
				Modify Player Variable(Event Player.selectedBot, changeBuffer_type, Append To Array, 5);
				Modify Player Variable(Event Player.selectedBot, changeBuffer_new_value, Append To Array, Is Button Held(Event Player, Button(
					Ability 1)));
				Event Player.selectedBot.lastRecordedState[5] = Is Button Held(Event Player, Button(Ability 1));
				Global.logBuffer = Custom String("{0}{1}", Global.logBuffer, Custom String("A1 {0}", Is Button Held(Event Player, Button(
					Ability 1))));
			End;
			"ABILITY 2"
			If(Event Player.selectedBot.lastRecordedState[6] != Is Button Held(Event Player, Button(Ability 2)));
				Modify Player Variable(Event Player.selectedBot, changeBuffer_type, Append To Array, 6);
				Modify Player Variable(Event Player.selectedBot, changeBuffer_new_value, Append To Array, Is Button Held(Event Player, Button(
					Ability 2)));
				Event Player.selectedBot.lastRecordedState[6] = Is Button Held(Event Player, Button(Ability 2));
				Global.logBuffer = Custom String("{0}{1}", Global.logBuffer, Custom String("A2 {0}", Is Button Held(Event Player, Button(
					Ability 2))));
			End;
			"CROUCH"
			If(Event Player.selectedBot.lastRecordedState[7] != Is Button Held(Event Player, Button(Crouch)));
				Modify Player Variable(Event Player.selectedBot, changeBuffer_type, Append To Array, 7);
				Modify Player Variable(Event Player.selectedBot, changeBuffer_new_value, Append To Array, Is Button Held(Event Player, Button(
					Crouch)));
				Event Player.selectedBot.lastRecordedState[7] = Is Button Held(Event Player, Button(Crouch));
				Global.logBuffer = Custom String("{0}{1}", Global.logBuffer, Custom String("C {0}", Is Button Held(Event Player, Button(Crouch))));
			End;
			"JUMP"
			If(Event Player.selectedBot.lastRecordedState[8] != Is Button Held(Event Player, Button(Jump)));
				Modify Player Variable(Event Player.selectedBot, changeBuffer_type, Append To Array, 8);
				Modify Player Variable(Event Player.selectedBot, changeBuffer_new_value, Append To Array, Is Button Held(Event Player, Button(
					Jump)));
				Event Player.selectedBot.lastRecordedState[8] = Is Button Held(Event Player, Button(Jump));
				Global.logBuffer = Custom String("{0}{1}", Global.logBuffer, Custom String("J {0}", Is Button Held(Event Player, Button(Jump))));
			End;
			"MELEE"
			If(Event Player.selectedBot.lastRecordedState[9] != Is Button Held(Event Player, Button(Melee)));
				Modify Player Variable(Event Player.selectedBot, changeBuffer_type, Append To Array, 9);
				Modify Player Variable(Event Player.selectedBot, changeBuffer_new_value, Append To Array, Is Button Held(Event Player, Button(
					Melee)));
				Event Player.selectedBot.lastRecordedState[9] = Is Button Held(Event Player, Button(Melee));
				Global.logBuffer = Custom String("{0}{1}", Global.logBuffer, Custom String("M {0}", Is Button Held(Event Player, Button(Melee))));
			End;
			"RELOAD"
			If(Event Player.selectedBot.lastRecordedState[10] != Is Button Held(Event Player, Button(Reload)));
				Modify Player Variable(Event Player.selectedBot, changeBuffer_type, Append To Array, 10);
				Modify Player Variable(Event Player.selectedBot, changeBuffer_new_value, Append To Array, Is Button Held(Event Player, Button(
					Reload)));
				Event Player.selectedBot.lastRecordedState[10] = Is Button Held(Event Player, Button(Reload));
				Global.logBuffer = Custom String("{0}{1}", Global.logBuffer, Custom String("R {0}", Is Button Held(Event Player, Button(Reload))));
			End;
			"ULTIMATE"
			If(Event Player.selectedBot.lastRecordedState[11] != Is Button Held(Event Player, Button(Ultimate)));
				Modify Player Variable(Event Player.selectedBot, changeBuffer_type, Append To Array, 11);
				Modify Player Variable(Event Player.selectedBot, changeBuffer_new_value, Append To Array, Is Button Held(Event Player, Button(
					Ultimate)));
				Event Player.selectedBot.lastRecordedState[11] = Is Button Held(Event Player, Button(Ultimate));
				Global.logBuffer = Custom String("{0}{1}", Global.logBuffer, Custom String("U {0}", Is Button Held(Event Player, Button(
					Ultimate))));
			End;
			"INTERACT"
			If(Event Player.selectedBot.lastRecordedState[12] != Is Button Held(Event Player, Button(Interact)));
				Modify Player Variable(Event Player.selectedBot, changeBuffer_type, Append To Array, 12);
				Modify Player Variable(Event Player.selectedBot, changeBuffer_new_value, Append To Array, Is Button Held(Event Player, Button(
					Interact)));
				Event Player.selectedBot.lastRecordedState[12] = Is Button Held(Event Player, Button(Interact));
				Global.logBuffer = Custom String("{0}{1}", Global.logBuffer, Custom String("I {0}", Is Button Held(Event Player, Button(
					Interact))));
			End;
			If(Count Of(Event Player.selectedBot.changeBuffer_type) > 0);
				If(Count Of(Event Player.selectedBot.recording_changes_type) == 1000);
					Event Player.selectedBot.recording_changes_type[Count Of(Event Player.selectedBot.recording_changes_type)] = Array(Array(
						Event Player.selectedBot.changeBuffer_type));
					Event Player.selectedBot.recording_changes_new_value[Count Of(Event Player.selectedBot.recording_changes_type)] = Array(Array(
						Event Player.selectedBot.changeBuffer_new_value));
					Event Player.selectedBot.recording_frame[Count Of(Event Player.selectedBot.recording_changes_type)] = Array(Array(
						Event Player.frame));
				Else;
					Modify Player Variable At Index(Event Player.selectedBot, recording_changes_type, Count Of(
						Event Player.selectedBot.recording_changes_type) - 1, Append To Array, Array(Event Player.selectedBot.changeBuffer_type));
					Modify Player Variable At Index(Event Player.selectedBot, recording_changes_new_value, Count Of(
						Event Player.selectedBot.recording_changes_type) - 1, Append To Array, Array(Event Player.selectedBot.changeBuffer_new_value));
					Modify Player Variable At Index(Event Player.selectedBot, recording_frame, Count Of(
						Event Player.selectedBot.recording_changes_type) - 1, Append To Array, Array(Event Player.frame));
				End;
			End;
		End;
		Event Player.frame += 1;
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[interface/dummyBotsAndReplay/replay/replayDefs.del] When bot is in playing state, loop every frame and replay inputs")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.replayState == Custom String("PLAYING");
	}

	actions
	{
		For Player Variable(Event Player, frame, Event Player.playbackOffset * -1, Event Player.totalFrames, 1);
			If(Event Player.frame >= 0 && Event Player.frame >= Event Player.currentFrame_frame);
				For Global Variable(i, 0, Count Of(Event Player.currentFrame_changes_type), 1);
					Skip(Array(76, 0, 2, 4, 6, 12, 18, 27, 33, 39, 45, 51, 57, 63)[Index Of Array Value(Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
						12), Event Player.currentFrame_changes_type[Global.i]) + 1]);
					Start Throttle In Direction(Event Player, Event Player.currentFrame_changes_new_value[Global.i], Magnitude Of(
						Event Player.currentFrame_changes_new_value[Global.i]), To Player, Replace existing throttle, None);
					Skip(74);
					Set Facing(Event Player, Event Player.currentFrame_changes_new_value[Global.i], To World);
					Skip(72);
					Set Weapon(Event Player, Event Player.currentFrame_changes_new_value[Global.i]);
					Skip(70);
					If(Event Player.currentFrame_changes_new_value[Global.i]);
						Start Holding Button(Event Player, Button(Primary Fire));
					Else;
						Stop Holding Button(Event Player, Button(Primary Fire));
					End;
					Skip(64);
					If(Event Player.currentFrame_changes_new_value[Global.i]);
						Start Holding Button(Event Player, Button(Secondary Fire));
					Else;
						Stop Holding Button(Event Player, Button(Secondary Fire));
					End;
					Skip(58);
					If(Event Player.currentFrame_changes_new_value[Global.i]);
						"SPECIAL CASE: Bots do not cancel Rein charge. Stop it manually if charging and ability 1 is pressed."
						If((Is Duplicating(Event Player) ? Hero Being Duplicated(Event Player) : Hero Of(Event Player)) == Hero(Reinhardt)
							&& Is Using Ability 1(Event Player));
							Cancel Primary Action(Event Player);
						End;
						Start Holding Button(Event Player, Button(Ability 1));
					Else;
						Stop Holding Button(Event Player, Button(Ability 1));
					End;
					Skip(49);
					If(Event Player.currentFrame_changes_new_value[Global.i]);
						Start Holding Button(Event Player, Button(Ability 2));
					Else;
						Stop Holding Button(Event Player, Button(Ability 2));
					End;
					Skip(43);
					If(Event Player.currentFrame_changes_new_value[Global.i]);
						Start Holding Button(Event Player, Button(Crouch));
					Else;
						Stop Holding Button(Event Player, Button(Crouch));
					End;
					Skip(37);
					If(Event Player.currentFrame_changes_new_value[Global.i]);
						Start Holding Button(Event Player, Button(Jump));
					Else;
						Stop Holding Button(Event Player, Button(Jump));
					End;
					Skip(31);
					If(Event Player.currentFrame_changes_new_value[Global.i]);
						Start Holding Button(Event Player, Button(Melee));
					Else;
						Stop Holding Button(Event Player, Button(Melee));
					End;
					Skip(25);
					If(Event Player.currentFrame_changes_new_value[Global.i]);
						Start Holding Button(Event Player, Button(Reload));
					Else;
						Stop Holding Button(Event Player, Button(Reload));
					End;
					Skip(19);
					If(Event Player.currentFrame_changes_new_value[Global.i]);
						Start Holding Button(Event Player, Button(Ultimate));
					Else;
						Stop Holding Button(Event Player, Button(Ultimate));
					End;
					Skip(13);
					If(Event Player.currentFrame_changes_new_value[Global.i]);
						If(Global.interactDestroysDeployableCompen);
							If((Is Duplicating(Event Player) ? Hero Being Duplicated(Event Player) : Hero Of(Event Player)) == Hero(Illari));
								Press Button(Event Player, Button(Ability 2));
							End;
							If((Is Duplicating(Event Player) ? Hero Being Duplicated(Event Player) : Hero Of(Event Player)) == Hero(Torbjörn));
								Press Button(Event Player, Button(Ability 1));
							End;
						End;
						Start Holding Button(Event Player, Button(Interact));
					Else;
						Stop Holding Button(Event Player, Button(Interact));
					End;
				End;
				Event Player.nextFrameIndex += 1;
				Event Player.currentFrame_changes_type = Event Player.recording_changes_type[Round To Integer(Event Player.nextFrameIndex / 1000,
					Down)][Event Player.nextFrameIndex % 1000];
				Event Player.currentFrame_changes_new_value = Event Player.recording_changes_new_value[Round To Integer(
					Event Player.nextFrameIndex / 1000, Down)][Event Player.nextFrameIndex % 1000];
				Event Player.currentFrame_frame = Event Player.recording_frame[Round To Integer(Event Player.nextFrameIndex / 1000, Down)
					][Event Player.nextFrameIndex % 1000];
			End;
			Wait(0.016, Abort When False);
		End;
		Event Player.replayStateAction = Custom String("REACHED_END_OF_REPLAY");
	}
}

rule("[interface/dummyBotsAndReplay/replay/replayStateMachine.del] Auto-transition to recording state")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.replayState == Custom String("PREPARING_TO_RECORD");
	}

	actions
	{
		Event Player.selectedBot.replayStateAction = Custom String("DELETE_RECORDING");
		"Wait one tick to allow deletion to occur"
		Wait(0.016, Ignore Condition);
		Event Player.selectedBot.replayResetPoint = Array(Position Of(Event Player.selectedBot), Eye Position(Event Player.selectedBot),
			Facing Direction Of(Event Player.selectedBot));
		Event Player.recordingHero = Hero Of(Event Player.selectedBot);
		Global.logBuffer = Custom String("{0}{1}", Custom String("{0}{1}{2}", Custom String("{0}{1}{2}", Custom String("{0}{1}{2}",
			Custom String("{0}{1}{2}", Custom String("REC "), Team Of(Event Player.selectedBot) == Team 1 ? Custom String("T1")
			: Custom String("T2"), Custom String(" ")), Slot Of(Event Player.selectedBot), Custom String(" ")), Event Player.recordingHero,
			Custom String(" ")), 1000 * First Of(Event Player.selectedBot.replayResetPoint), Custom String(" ")),
			1000 * Event Player.selectedBot.replayResetPoint[2]);
		Enable Inspector Recording;
		Log To Inspector(Global.logBuffer);
		If(First Of(Global._extendedGlobalCollection));
			Disable Inspector Recording;
		End;
		Global.logBuffer = Custom String("");
		Event Player.originalHero = Hero Of(Event Player);
		"Move bot away from recording area"
		Stop Forcing Player Position(Event Player.selectedBot);
		Start Forcing Player Position(Event Player.selectedBot, Vector(0, 1000, 0), True);
		Set Invisible(Event Player.selectedBot, All);
		"Prepare player to record"
		Global._arrayConstructor = Event Player.ButtonLabelGrid[6];
		Global._arrayConstructor[12] = Custom String("Edit Dummy Bots");
		Event Player.ButtonLabelGrid[6] = Global._arrayConstructor;
		Event Player.botControlMode = 0;
		If(Event Player.isNoClipActive);
			Event Player.toolsActionID = 3;
			Wait(0.016, Ignore Condition);
			Event Player.toolsActionID = 0;
		End;
		Event Player.currentMenuState = 0;
		If(Event Player.botControlMode == 1);
			Event Player.botControlMode = 0;
		End;
		Wait(0.016, Ignore Condition);
		Start Forcing Player To Be Hero(Event Player, Event Player.recordingHero);
		Start Forcing Player Position(Event Player, First Of(Event Player.selectedBot.replayResetPoint), True);
		Start Facing(Event Player, Event Player.selectedBot.replayResetPoint[2], 1000, To World, Direction and Turn Rate);
		Event Player.buttonLocks = Mapped Array(Event Player.buttonLocks, Current Array Element + 1);
		Global.player = Event Player;
		Call Subroutine(UpdatePlayerButtonStatus);
		"If we should prompt all other bots to play their recordings,\r\nprompt them now."
		If(Global.allBotsReplayDuringRecording);
			Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element) && Current Array Element.totalFrames > 0)
				.waitingOnPlayer = Event Player;
			Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element) && Current Array Element.totalFrames > 0)
				.replayStateAction = Custom String("PREPARE_FOR_PLAYBACK");
		End;
		Event Player.recordingCountdownText = Array(3, Custom Color(200, 50, 50, 255), Null);
		If(Global.RECORD_IN_SLOW_MOTION);
			Global.activeModifications[7] = True;
		End;
		Wait Until(Is Dead(Event Player) || Event Player.currentMenuState != 0, 0.800);
		If(Is Dead(Event Player) || Event Player.currentMenuState != 0);
			Event Player.replayStateAction = Custom String("STOP_RECORDING");
			Small Message(Event Player, Custom String("  Recording aborted"));
			Abort;
		End;
		Create In-World Text(Event Player, Custom String("{0}{1}{2}", Custom String("Recording starts in "), First Of(
			Event Player.recordingCountdownText), Custom String("...")), Update Every Frame(True * Eye Position(Local Player)
			+ Empty Array * Cross Product(Facing Direction Of(Local Player), Direction From Angles(Horizontal Angle From Direction(
			Facing Direction Of(Local Player)), Vertical Angle From Direction(Facing Direction Of(Local Player)) - 90))
			+ -70 * Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Local Player)),
			Vertical Angle From Direction(Facing Direction Of(Local Player)) - 90) + 300 * Facing Direction Of(Local Player)), 2.500,
			Do Not Clip, Visible To Position String and Color, Event Player.recordingCountdownText[1], Default Visibility);
		Event Player.recordingCountdownText[2] = Last Text ID;
		Wait Until(Is Dead(Event Player) || Event Player.currentMenuState != 0,
			Global.activeModifications[7] ? 0.800 * Global.SLOW_MOTION_SPEED / 100 : 0.800);
		If(Is Dead(Event Player) || Event Player.currentMenuState != 0);
			Event Player.replayStateAction = Custom String("STOP_RECORDING");
			Small Message(Event Player, Custom String("  Recording aborted"));
			Abort;
		End;
		Event Player.recordingCountdownText[0] = 2;
		Event Player.recordingCountdownText[1] = Color(Yellow);
		Wait Until(Is Dead(Event Player) || Event Player.currentMenuState != 0,
			Global.activeModifications[7] ? 0.800 * Global.SLOW_MOTION_SPEED / 100 : 0.800);
		If(Is Dead(Event Player) || Event Player.currentMenuState != 0);
			Event Player.replayStateAction = Custom String("STOP_RECORDING");
			Small Message(Event Player, Custom String("  Recording aborted"));
			Abort;
		End;
		Event Player.recordingCountdownText[0] = 1;
		Event Player.recordingCountdownText[1] = Color(Green);
		Wait Until(Is Dead(Event Player) || Event Player.currentMenuState != 0,
			Global.activeModifications[7] ? 0.800 * Global.SLOW_MOTION_SPEED / 100 : 0.800);
		If(Is Dead(Event Player) || Event Player.currentMenuState != 0);
			Event Player.replayStateAction = Custom String("STOP_RECORDING");
			Small Message(Event Player, Custom String("  Recording aborted"));
			Abort;
		End;
		Event Player.recordingCountdownText[0] = 0;
		Destroy In-World Text(Event Player.recordingCountdownText[2]);
		"Release player to record"
		Stop Forcing Player Position(Event Player);
		Stop Facing(Event Player);
		Event Player.buttonLocks = Mapped Array(Event Player.buttonLocks, 0);
		Global.player = Event Player;
		Call Subroutine(UpdatePlayerButtonStatus);
		Event Player.replayStateAction = Custom String("START_RECORDING");
	}
}

rule("[interface/dummyBotsAndReplay/replay/replayStateMachine.del] Auto-transition to playback state")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.replayState == Custom String("PREPARING_FOR_PLAYBACK");
	}

	actions
	{
		If(Event Player.waitingOnPlayer != Null);
			Wait Until(Event Player.waitingOnPlayer.replayState != Custom String("PREPARING_TO_RECORD"), 5);
			If(Event Player.waitingOnPlayer.replayState != Custom String("RECORDING"));
				Event Player.replayStateAction = Custom String("STOP_PLAYBACK");
				Event Player.waitingOnPlayer = Null;
				Abort;
			End;
			Event Player.waitingOnPlayer = Null;
		Else;
			Wait(1, Abort When False);
		End;
		Abort If((Event Player.totalFrames > 0) == False);
		Event Player.replayStateAction = Custom String("START_PLAYBACK");
	}
}

rule("[interface/dummyBotsAndReplay/replay/replayStateMachine.del] Auto-transition to looping if needed, otherwise end playback")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.replayState == Custom String("REACHED_END_OF_REPLAY");
	}

	actions
	{
		"If recording, we should never loop, since recordings"
		If(Is True For Any(All Players(All Teams), Array Contains(Array(Custom String("PREPARING_TO_RECORD"), Custom String("RECORDING")),
			Current Array Element.replayState)));
			Event Player.replayStateAction = Custom String("STOP_PLAYBACK");
			Abort;
		End;
		Wait Until(Is True For All(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)
			&& Current Array Element.totalFrames > 0), Array Contains(Array(Custom String("REACHED_END_OF_REPLAY"), Custom String("NONE")),
			Current Array Element.replayState)), 1000000);
		If(Global.SHOULD_LOOP_CLIP && Event Player.replayState == Custom String("REACHED_END_OF_REPLAY"));
			Event Player.replayStateAction = Custom String("START_PLAYBACK");
		Else;
			Event Player.replayStateAction = Custom String("STOP_PLAYBACK");
		End;
	}
}

rule("[lib/quickActions/quickAction.del] Set up quick actions")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		For Global Variable(i, 0, Count Of(Array(Array(Button(Crouch), Button(Reload)), Array(Button(Crouch), Button(Melee)), Array(Button(
			Crouch), Button(Interact)), Array(Button(Ability 1), Button(Interact)), Array(Button(Ability 2), Button(Interact)), Array(
			Button(Ultimate), Button(Interact)))), 1);
			If(Global.ActionSettings[Global.i] > 0);
				Global.t = Array(Array(Array(Button(Crouch), Button(Reload)), Array(Button(Crouch), Button(Melee)), Array(Button(Crouch), Button(
					Interact)), Array(Button(Ability 1), Button(Interact)), Array(Button(Ability 2), Button(Interact)), Array(Button(Ultimate),
					Button(Interact)))[Global.i], Global.QuickActions[Global.ActionSettings[Global.i]]);
				Modify Global Variable(_watch_triggers, Append To Array, Array(Global.t));
			End;
		End;
	}
}

rule("Check players for triggers")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.TRIGGERS_ENABLED == True;
		Is Dummy Bot(Event Player) == False;
		(Is Alive(Event Player) && Count Of(Global._watch_triggers) != 0) == True;
		Is True For Any(Global._watch_triggers, 0 >= Count Of(First Of(Current Array Element)) || (Is Button Held(Event Player, First Of(
			First Of(Current Array Element))) && (1 >= Count Of(First Of(Current Array Element)) || (Is Button Held(Event Player, First Of(
			Current Array Element)[1]) && (2 >= Count Of(First Of(Current Array Element)) || (Is Button Held(Event Player, First Of(
			Current Array Element)[2]) && True)))))) == True;
	}

	actions
	{
		Abort If(Event Player.currentMenuState != 0);
		For Player Variable(Event Player, t, 0, Count Of(Global._watch_triggers), 1);
			If(0 >= Count Of(First Of(Global._watch_triggers[Event Player.t])) || (Is Button Held(Event Player, First Of(First Of(
				Global._watch_triggers[Event Player.t]))) && (1 >= Count Of(First Of(Global._watch_triggers[Event Player.t])) || (
				Is Button Held(Event Player, First Of(Global._watch_triggers[Event Player.t])[1]) && (2 >= Count Of(First Of(
				Global._watch_triggers[Event Player.t])) || (Is Button Held(Event Player, First Of(Global._watch_triggers[Event Player.t])[2])
				&& True))))));
				Modify Global Variable(func_group, Append To Array, Array(Global._watch_triggers[Event Player.t][1]));
				Call Subroutine(func_group);
			End;
		End;
	}
}

rule("[DEBUG | main.ostw] Show diagnostics")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Workshop Setting Toggle(Custom String("99. Debug"), Custom String("Show Diagnostics"), False, 0) == True;
	}

	actions
	{
		Create HUD Text(Host Player, Null, Custom String("[ {0} ]  Server Load", Server Load), Null, Right, 1, Color(White), Array(Color(
			Green), Color(Lime Green), Color(Yellow), Color(Orange), Color(Red))[Round To Integer(Max(0, Min(Server Load / 255, 1))
			* 0.999 * Count Of(Array(Color(Green), Color(Lime Green), Color(Yellow), Color(Orange), Color(Red))), Down)], Color(White),
			Visible To String and Color, Visible Always);
		Create HUD Text(Host Player, Null, Custom String("[ {0} ]  Server Load Average", Server Load Average), Null, Right, 2, Color(
			White), Array(Color(Green), Color(Lime Green), Color(Yellow), Color(Orange), Color(Red))[Round To Integer(Max(0, Min(
			Server Load Average / 255, 1)) * 0.999 * Count Of(Array(Color(Green), Color(Lime Green), Color(Yellow), Color(Orange), Color(
			Red))), Down)], Color(White), Visible To String and Color, Visible Always);
		Create HUD Text(Host Player, Null, Custom String("[ {0} ]  Server Load Peak", Server Load Peak), Null, Right, 3, Color(White),
			Array(Color(Green), Color(Lime Green), Color(Yellow), Color(Orange), Color(Red))[Round To Integer(Max(0, Min(
			Server Load Peak / 255, 1)) * 0.999 * Count Of(Array(Color(Green), Color(Lime Green), Color(Yellow), Color(Orange), Color(
			Red))), Down)], Color(White), Visible To String and Color, Visible Always);
		Create HUD Text(Host Player, Null, Custom String("[ {0} / {1} ]  Entity Count", Entity Count, 128), Null, Right, 4, Color(White),
			Array(Color(Green), Color(Lime Green), Color(Yellow), Color(Orange), Color(Red))[Round To Integer(Max(0, Min(
			Entity Count / 128, 1)) * 0.999 * Count Of(Array(Color(Green), Color(Lime Green), Color(Yellow), Color(Orange), Color(Red))),
			Down)], Color(White), Visible To String and Color, Visible Always);
		Create HUD Text(Host Player, Null, Custom String("[ {0} / {1} ]  Text Count", Text Count, 128), Null, Right, 5, Color(White),
			Array(Color(Green), Color(Lime Green), Color(Yellow), Color(Orange), Color(Red))[Round To Integer(Max(0, Min(Text Count / 128,
			1)) * 0.999 * Count Of(Array(Color(Green), Color(Lime Green), Color(Yellow), Color(Orange), Color(Red))), Down)], Color(White),
			Visible To String and Color, Visible Always);
		Create HUD Text(Host Player, Null, Custom String("[ {0} / {1} ]  Dummy Bot Count", Count Of(Filtered Array(All Players(All Teams),
			Is Dummy Bot(Current Array Element))), 12 - Count Of(Filtered Array(All Players(All Teams), !Is Dummy Bot(
			Current Array Element)))), Null, Right, 6, Color(White), Array(Color(Green), Color(Lime Green), Color(Yellow), Color(Orange),
			Color(Red))[Round To Integer(Max(0, Min(Count Of(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)))
			/ (12 - Count Of(Filtered Array(All Players(All Teams), !Is Dummy Bot(Current Array Element)))), 1)) * 0.999 * Count Of(Array(
			Color(Green), Color(Lime Green), Color(Yellow), Color(Orange), Color(Red))), Down)], Color(White), Visible To String and Color,
			Visible Always);
		Create HUD Text(Host Player, Null, Custom String("DIST: {0} | ANG: {1}", Local Player.thirdPersonDistance,
			Local Player.thirdPersonPosAngle), Null, Right, 7, Color(White), Color(White), Color(White), Visible To String and Color,
			Visible Always);
		Create HUD Text(Host Player, Null, Custom String("POLAR: {0} | AZIM: {1}", Local Player.thirdPersonFacPolar,
			Local Player.thirdPersonFacAzim), Null, Right, 8, Color(White), Color(White), Color(White), Visible To String and Color,
			Visible Always);
	}
}

rule("lambda")
{
	event
	{
		Subroutine;
		func_group;
	}

	actions
	{
		Skip(Array(131, 0, 0, 17, 38, 50, 52, 68, 70, 96, 126, 128, 130)[Index Of Array Value(Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),
			First Of(Last Of(Global.func_group))) + 1]);
		"Set the point for the player to return to"
		Event Player.menuActivationPoint = Array(Position Of(Event Player), Eye Position(Event Player), Facing Direction Of(Event Player));
		Set Player Allowed Heroes(Event Player, Remove From Array(Allowed Heroes(Event Player), Hero Of(Event Player)));
		Wait Until(!Has Spawned(Event Player), 3);
		Reset Player Hero Availability(Event Player);
		Wait Until(Has Spawned(Event Player), 9999);
		Stop Forcing Player Position(Event Player);
		Teleport(Event Player, First Of(Event Player.menuActivationPoint));
		Stop Facing(Event Player);
		Wait(0.016, Ignore Condition);
		Set Facing(Event Player, Event Player.menuActivationPoint[2], To World);
		"Because for SOME REASON setting FACING and TELEPORTING in the SAME FRAME cancels the TELEPORT"
		Wait(0.032, Ignore Condition);
		Start Facing(Event Player, Event Player.menuActivationPoint[2], 1000, To World, Direction and Turn Rate);
		Wait(0.016, Ignore Condition);
		Wait Until(Angle Between Vectors(Facing Direction Of(Event Player), Event Player.menuActivationPoint[2]) < 0.100, 0.250);
		Stop Facing(Event Player);
		Event Player.currentMenuState = 0;
		Skip(114);
		If(Event Player.isNoClipActive);
			"Set new button look"
			Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
			Global._arrayConstructor[8] = Custom String("Enable NoClip");
			Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[5];
			Global._arrayConstructor[8] = Color(Green);
			Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		Else;
			"Set new button look"
			Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
			Global._arrayConstructor[8] = Custom String("Disable NoClip");
			Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
			Global._arrayConstructor = Event Player.ButtonColorGrid[5];
			Global._arrayConstructor[8] = Color(Red);
			Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		End;
		Event Player.isNoClipActive = !Event Player.isNoClipActive;
		Event Player.currentMenuState = 0;
		"Must manually stop camera since we didn't deactivate noclip by using the menu"
		If(!Event Player.isNoClipActive);
			Stop Camera(Event Player);
		End;
		Skip(93);
		If(Count Of(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element) && Current Array Element.totalFrames > 0))
			== 0);
			Small Message(Event Player, Custom String("  No replays recorded yet!"));
			Play Effect(Event Player, Debuff Impact Sound, Null, Event Player, 100);
			Skip(89);
		End;
		If(Is True For Any(Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)), Array Contains(Array(Custom String(
			"PREPARING_FOR_PLAYBACK"), Custom String("PLAYING"), Custom String("REACHED_END_OF_REPLAY")),
			Current Array Element.replayState)));
			Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)).recordingPlayStopFlag = 2;
			Skip(85);
		End;
		Filtered Array(All Players(All Teams), Is Dummy Bot(Current Array Element)).recordingPlayStopFlag = 1;
		Event Player.currentMenuState = 0;
		Skip(81);
		Damage(Event Player, Null, 0.200 * Max Health(Event Player));
		Skip(79);
		If(First Of(Event Player._extendedPlayerCollection[2]) == Null);
			Small Message(Event Player, Custom String("{0}{1}", Icon String(Warning), Custom String("No respawn point set")));
			Play Effect(Event Player, Debuff Impact Sound, Null, Event Player, 100);
			Skip(75);
		End;
		Respawn(Event Player);
		Teleport(Event Player, First Of(Event Player._extendedPlayerCollection[2]));
		Stop Facing(Event Player);
		Wait(0.016, Ignore Condition);
		Set Facing(Event Player, Event Player._extendedPlayerCollection[2][2], To World);
		"Because for SOME REASON setting FACING and TELEPORTING in the SAME FRAME cancels the TELEPORT"
		Wait(0.032, Ignore Condition);
		Start Facing(Event Player, Event Player._extendedPlayerCollection[2][2], 1000, To World, Direction and Turn Rate);
		Wait(0.016, Ignore Condition);
		Wait Until(Angle Between Vectors(Facing Direction Of(Event Player), Event Player._extendedPlayerCollection[2][2]) < 0.100, 0.250);
		Stop Facing(Event Player);
		Skip(63);
		Start Rule(ResetAllBotsToResetPoints, Do Nothing);
		Skip(61);
		If(Event Player.botControlMode == 0);
			Global._arrayConstructor = Event Player.ButtonLabelGrid[6];
			Global._arrayConstructor[12] = Custom String("Stop Editing Bots");
			Event Player.ButtonLabelGrid[6] = Global._arrayConstructor;
			Event Player.botControlMode = 1;
			If(!Event Player.isNoClipActive);
				Event Player.toolsActionID = 3;
				Wait(0.016, Ignore Condition);
				Event Player.toolsActionID = 0;
			End;
		Else;
			Global._arrayConstructor = Event Player.ButtonLabelGrid[6];
			Global._arrayConstructor[12] = Custom String("Edit Dummy Bots");
			Event Player.ButtonLabelGrid[6] = Global._arrayConstructor;
			Event Player.botControlMode = 0;
			If(Event Player.isNoClipActive);
				Event Player.toolsActionID = 3;
				Wait(0.016, Ignore Condition);
				Event Player.toolsActionID = 0;
			End;
		End;
		Event Player.currentMenuState = 0;
		"Must manually stop camera since we didn't deactivate noclip by using the menu"
		If(!Event Player.isNoClipActive);
			Stop Camera(Event Player);
		End;
		Skip(35);
		Skip(Array(25, 0, 9, 18)[Index Of Array Value(Array(0, 1, 2), Event Player.thirdPersonState) + 1]);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
		Global._arrayConstructor[13] = Custom String("Set 3P Camera Pos");
		Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[5];
		Global._arrayConstructor[13] = Color(Green);
		Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		Event Player.thirdPersonState = 1;
		Event Player.currentMenuState = 0;
		Skip(16);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
		Global._arrayConstructor[13] = Custom String("Stop 3rd Person");
		Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[5];
		Global._arrayConstructor[13] = Color(Red);
		Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		Event Player.thirdPersonState = 2;
		Event Player.currentMenuState = 0;
		Skip(7);
		Global._arrayConstructor = Event Player.ButtonLabelGrid[5];
		Global._arrayConstructor[13] = Custom String("Enable 3rd Person");
		Event Player.ButtonLabelGrid[5] = Global._arrayConstructor;
		Global._arrayConstructor = Event Player.ButtonColorGrid[5];
		Global._arrayConstructor[13] = Color(Orange);
		Event Player.ButtonColorGrid[5] = Global._arrayConstructor;
		Event Player.thirdPersonState = 0;
		"For SOME reason trying to do this without opening the menu\r\ncauses some baloney and I can't be bothered to figure it out"
		Event Player.currentMenuState = 1;
		Wait(0.016, Ignore Condition);
		Event Player.currentMenuState = 0;
		Skip(5);
		Global.activeModifications[1] = !Global.activeModifications[1];
		Skip(3);
		Global.activeModifications[7] = !Global.activeModifications[7];
		Skip(1);
		Global.activeModifications[8] = !Global.activeModifications[8];
		Modify Global Variable(func_group, Remove From Array By Index, Count Of(Global.func_group) - 1);
	}
}

rule("[interface/dummyBotsAndReplay/replay/replayStateMachine.del] Process replay state action")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.replayStateAction != Custom String("NONE");
	}

	actions
	{
		"DEBUG"
		Global.logBuffer = Custom String("{0}{1}{2}", Custom String("{0}{1}{2}", Custom String("{0}{1}{2}", Custom String(
			"Replay State Handler for "), Event Player, Custom String(": [State ")), Event Player.replayState, Custom String(
			"] [Action: ")), Event Player.replayStateAction, Custom String("]"));
		Enable Inspector Recording;
		Log To Inspector(Global.logBuffer);
		If(First Of(Global._extendedGlobalCollection));
			Disable Inspector Recording;
		End;
		Global.logBuffer = Custom String("");
		Skip(Array(161, 0, 18, 59, 102, 124, 143)[Index Of Array Value(Array(Custom String("NONE"), Custom String("PREPARING_TO_RECORD"),
			Custom String("RECORDING"), Custom String("PREPARING_FOR_PLAYBACK"), Custom String("PLAYING"), Custom String(
			"REACHED_END_OF_REPLAY")), Event Player.replayState) + 1]);
		Skip(Array(16, 0, 2, 4)[Index Of Array Value(Array(Custom String("DELETE_RECORDING"), Custom String("PREPARE_TO_RECORD"),
			Custom String("PREPARE_FOR_PLAYBACK")), Event Player.replayStateAction) + 1]);
		Call Subroutine(DeleteRecording);
		Skip(14);
		"All handling for entering this state is done in the auto-transition rule"
		Event Player.replayState = Custom String("PREPARING_TO_RECORD");
		Skip(12);
		Respawn(Event Player);
		Teleport(Event Player, First Of(Event Player.replayResetPoint));
		Stop Facing(Event Player);
		Wait(0.016, Ignore Condition);
		Set Facing(Event Player, Event Player.replayResetPoint[2], To World);
		"Because for SOME REASON setting FACING and TELEPORTING in the SAME FRAME cancels the TELEPORT"
		Wait(0.032, Ignore Condition);
		Start Facing(Event Player, Event Player.replayResetPoint[2], 1000, To World, Direction and Turn Rate);
		Wait(0.250, Ignore Condition);
		Stop Facing(Event Player);
		Start Forcing Player Position(Event Player, First Of(Event Player.replayResetPoint), True);
		Set Weapon(Event Player, 0);
		Event Player.replayState = Custom String("PREPARING_FOR_PLAYBACK");
		Skip(143);
		Skip(Array(39, 0, 2, 21)[Index Of Array Value(Array(Custom String("DELETE_RECORDING"), Custom String("START_RECORDING"),
			Custom String("STOP_RECORDING")), Event Player.replayStateAction) + 1]);
		"Recording cases"
		Call Subroutine(DeleteRecording);
		Skip(37);
		Event Player.replayState = Custom String("RECORDING");
		If(Global.RECORD_IN_SLOW_MOTION);
			Global.activeModifications[7] = True;
		End;
		Event Player.frame = 0;
		Event Player.selectedBot.changeBuffer_type = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
		Event Player.selectedBot.changeBuffer_new_value = Array(Throttle Of(Event Player), Facing Direction Of(Event Player), Weapon(
			Event Player), Is Button Held(Event Player, Button(Primary Fire)), Is Button Held(Event Player, Button(Secondary Fire)),
			Is Button Held(Event Player, Button(Ability 1)), Is Button Held(Event Player, Button(Ability 2)), Is Button Held(Event Player,
			Button(Crouch)), Is Button Held(Event Player, Button(Jump)), Is Button Held(Event Player, Button(Melee)), Is Button Held(
			Event Player, Button(Reload)), Is Button Held(Event Player, Button(Ultimate)), Is Button Held(Event Player, Button(Interact)));
		If(Count Of(Event Player.selectedBot.recording_changes_type) == 1000);
			Event Player.selectedBot.recording_changes_type[Count Of(Event Player.selectedBot.recording_changes_type)] = Array(Array(
				Event Player.selectedBot.changeBuffer_type));
			Event Player.selectedBot.recording_changes_new_value[Count Of(Event Player.selectedBot.recording_changes_type)] = Array(Array(
				Event Player.selectedBot.changeBuffer_new_value));
			Event Player.selectedBot.recording_frame[Count Of(Event Player.selectedBot.recording_changes_type)] = Array(Array(0));
		Else;
			Modify Player Variable At Index(Event Player.selectedBot, recording_changes_type, Count Of(
				Event Player.selectedBot.recording_changes_type) - 1, Append To Array, Array(Event Player.selectedBot.changeBuffer_type));
			Modify Player Variable At Index(Event Player.selectedBot, recording_changes_new_value, Count Of(
				Event Player.selectedBot.recording_changes_type) - 1, Append To Array, Array(Event Player.selectedBot.changeBuffer_new_value));
			Modify Player Variable At Index(Event Player.selectedBot, recording_frame, Count Of(
				Event Player.selectedBot.recording_changes_type) - 1, Append To Array, Array(0));
		End;
		Event Player.selectedBot.lastRecordedState = Array(Throttle Of(Event Player), Facing Direction Of(Event Player), Weapon(
			Event Player), Is Button Held(Event Player, Button(Primary Fire)), Is Button Held(Event Player, Button(Secondary Fire)),
			Is Button Held(Event Player, Button(Ability 1)), Is Button Held(Event Player, Button(Ability 2)), Is Button Held(Event Player,
			Button(Crouch)), Is Button Held(Event Player, Button(Jump)), Is Button Held(Event Player, Button(Melee)), Is Button Held(
			Event Player, Button(Reload)), Is Button Held(Event Player, Button(Ultimate)), Is Button Held(Event Player, Button(Interact)));
		"Wait one frame to start recording if all bots play their recordings during recording,\r\nsince they need time to being playback."
		Event Player.selectedBot.frame = Global.allBotsReplayDuringRecording ? -1 : 0;
		Skip(18);
		If(Global.RECORD_IN_SLOW_MOTION);
			Global.activeModifications[7] = False;
		End;
		Destroy In-World Text(Event Player.recordingCountdownText[2]);
		"Restore bot to reset point and recording player to original hero"
		Start Forcing Player To Be Hero(Event Player, Event Player.originalHero);
		Stop Forcing Player To Be Hero(Event Player);
		Stop Forcing Player Position(Event Player.selectedBot);
		Set Invisible(Event Player.selectedBot, None);
		Teleport(Event Player.selectedBot, First Of(Event Player.selectedBot.replayResetPoint));
		Stop Facing(Event Player.selectedBot);
		Wait(0.016, Ignore Condition);
		Set Facing(Event Player.selectedBot, Event Player.selectedBot.replayResetPoint[2], To World);
		"Because for SOME REASON setting FACING and TELEPORTING in the SAME FRAME cancels the TELEPORT"
		Wait(0.032, Ignore Condition);
		Start Facing(Event Player.selectedBot, Event Player.selectedBot.replayResetPoint[2], 1000, To World, Direction and Turn Rate);
		Wait(0.016, Ignore Condition);
		Wait Until(Angle Between Vectors(Facing Direction Of(Event Player.selectedBot), Event Player.selectedBot.replayResetPoint[2])
			< 0.100, 0.250);
		Stop Facing(Event Player.selectedBot);
		Event Player.replayState = Custom String("NONE");
		Skip(102);
		Skip(Array(41, 0)[Index Of Array Value(Array(Custom String("STOP_RECORDING")), Event Player.replayStateAction) + 1]);
		If(Global.RECORD_IN_SLOW_MOTION);
			Global.activeModifications[7] = False;
		End;
		Global._arrayConstructor = Event Player.ButtonLabelGrid[6];
		Global._arrayConstructor[12] = Custom String("Stop Editing Bots");
		Event Player.ButtonLabelGrid[6] = Global._arrayConstructor;
		Event Player.botControlMode = 1;
		If(!Event Player.isNoClipActive);
			Event Player.toolsActionID = 3;
			Wait(0.016, Ignore Condition);
			Event Player.toolsActionID = 0;
		End;
		Event Player.currentMenuState = 0;
		"Restore bot to reset point and recording player to original hero"
		Start Forcing Player To Be Hero(Event Player, Event Player.originalHero);
		Stop Forcing Player To Be Hero(Event Player);
		Stop Forcing Player Position(Event Player.selectedBot);
		Set Invisible(Event Player.selectedBot, None);
		Teleport(Event Player.selectedBot, First Of(Event Player.selectedBot.replayResetPoint));
		Stop Facing(Event Player.selectedBot);
		Wait(0.016, Ignore Condition);
		Set Facing(Event Player.selectedBot, Event Player.selectedBot.replayResetPoint[2], To World);
		"Because for SOME REASON setting FACING and TELEPORTING in the SAME FRAME cancels the TELEPORT"
		Wait(0.032, Ignore Condition);
		Start Facing(Event Player.selectedBot, Event Player.selectedBot.replayResetPoint[2], 1000, To World, Direction and Turn Rate);
		Wait(0.016, Ignore Condition);
		Wait Until(Angle Between Vectors(Facing Direction Of(Event Player.selectedBot), Event Player.selectedBot.replayResetPoint[2])
			< 0.100, 0.250);
		Stop Facing(Event Player.selectedBot);
		Event Player.replayState = Custom String("NONE");
		"Add one more dummy frame to the end to ensure OOB doesn't happen"
		If(Count Of(Event Player.selectedBot.recording_changes_type) == 1000);
			Event Player.selectedBot.recording_changes_type[Count Of(Event Player.selectedBot.recording_changes_type)] = Array(Array(
				Empty Array));
			Event Player.selectedBot.recording_changes_new_value[Count Of(Event Player.selectedBot.recording_changes_type)] = Array(Array(
				Empty Array));
			Event Player.selectedBot.recording_frame[Count Of(Event Player.selectedBot.recording_changes_type)] = Array(Array(
				Event Player.frame));
		Else;
			Modify Player Variable At Index(Event Player.selectedBot, recording_changes_type, Count Of(
				Event Player.selectedBot.recording_changes_type) - 1, Append To Array, Array(Empty Array));
			Modify Player Variable At Index(Event Player.selectedBot, recording_changes_new_value, Count Of(
				Event Player.selectedBot.recording_changes_type) - 1, Append To Array, Array(Empty Array));
			Modify Player Variable At Index(Event Player.selectedBot, recording_frame, Count Of(
				Event Player.selectedBot.recording_changes_type) - 1, Append To Array, Array(Event Player.frame));
		End;
		Event Player.selectedBot.totalFrames = Event Player.frame;
		"If bots are prompted to start replaying when"
		If(Global.allBotsReplayDuringRecording);
			Filtered Array(All Players(All Teams), Array Contains(Array(Custom String("PREPARING_FOR_PLAYBACK"), Custom String("PLAYING"),
				Custom String("REACHED_END_OF_REPLAY")), Current Array Element.replayState)).replayStateAction = Custom String(
				"STOP_PLAYBACK");
		End;
		Small Message(Event Player, Custom String("  Recording complete"));
		Skip(59);
		Skip(Array(20, 0, 4, 17)[Index Of Array Value(Array(Custom String("DELETE_RECORDING"), Custom String("START_PLAYBACK"),
			Custom String("STOP_PLAYBACK")), Event Player.replayStateAction) + 1]);
		"Playback cases"
		Stop Forcing Player Position(Event Player);
		Call Subroutine(DeleteRecording);
		Event Player.replayState = Custom String("NONE");
		Skip(16);
		Event Player.waitingOnPlayer = Null;
		Stop Forcing Player Position(Event Player);
		Event Player.frame = 0;
		Event Player.nextFrameIndex = 0;
		Event Player.currentFrame_changes_type = Event Player.recording_changes_type[Round To Integer(Event Player.nextFrameIndex / 1000,
			Down)][Event Player.nextFrameIndex % 1000];
		Event Player.currentFrame_changes_new_value = Event Player.recording_changes_new_value[Round To Integer(
			Event Player.nextFrameIndex / 1000, Down)][Event Player.nextFrameIndex % 1000];
		Event Player.currentFrame_frame = Event Player.recording_frame[Round To Integer(Event Player.nextFrameIndex / 1000, Down)
			][Event Player.nextFrameIndex % 1000];
		If(Global.SHOW_REPLAY_TIMECODES);
			Create In-World Text(All Players(All Teams), Update Every Frame(Custom String("{0}{1}", Custom String("{0}{1}", Custom String(
				"{0}{1}{2}", Custom String("{0}{1}{2}", Round To Integer(Event Player.frame * 0.016 / 60, Down) < 10 ? 0 : Custom String(""),
				Round To Integer(Event Player.frame * 0.016 / 60, Down), Custom String(":")), Round To Integer(Event Player.frame * 0.016 % 60,
				Down) < 10 ? 0 : Custom String(""), Event Player.frame * 0.016 % 60), Event Player.frame * 0.016 % 1 == 0 ? Custom String(
				".00") : Custom String("")), Custom String("{0}{1}", Custom String(" | "), Event Player.frame))), Event Player, 0,
				Clip Against Surfaces, Visible To Position and String, Color(White), Default Visibility);
			Event Player._extendedPlayerCollection[14] = Last Text ID;
		End;
		Event Player.replayState = Custom String("PLAYING");
		Skip(3);
		Event Player.waitingOnPlayer = Null;
		Stop Forcing Player Position(Event Player);
		Event Player.replayState = Custom String("NONE");
		Skip(37);
		Skip(Array(17, 0, 9)[Index Of Array Value(Array(Custom String("REACHED_END_OF_REPLAY"), Custom String("STOP_PLAYBACK")),
			Event Player.replayStateAction) + 1]);
		Event Player.replayState = Custom String("REACHED_END_OF_REPLAY");
		Cancel Primary Action(Event Player);
		Stop Throttle In Direction(Event Player);
		Stop Facing(Event Player);
		For Global Variable(i, 0, Count Of(Global.AllButtons), 1);
			Stop Holding Button(Event Player, Global.AllButtons[Global.i]);
		End;
		Destroy In-World Text(Event Player._extendedPlayerCollection[14]);
		Skip(8);
		Event Player.replayState = Custom String("NONE");
		Cancel Primary Action(Event Player);
		Stop Throttle In Direction(Event Player);
		Stop Facing(Event Player);
		For Global Variable(i, 0, Count Of(Global.AllButtons), 1);
			Stop Holding Button(Event Player, Global.AllButtons[Global.i]);
		End;
		Destroy In-World Text(Event Player._extendedPlayerCollection[14]);
		Skip(18);
		Skip(Array(17, 0, 3, 16)[Index Of Array Value(Array(Custom String("DELETE_RECORDING"), Custom String("START_PLAYBACK"),
			Custom String("STOP_PLAYBACK")), Event Player.replayStateAction) + 1]);
		Call Subroutine(DeleteRecording);
		Event Player.replayState = Custom String("NONE");
		Skip(14);
		Respawn(Event Player);
		Teleport(Event Player, First Of(Event Player.replayResetPoint));
		Stop Facing(Event Player);
		Wait(0.016, Ignore Condition);
		Set Facing(Event Player, Event Player.replayResetPoint[2], To World);
		"Because for SOME REASON setting FACING and TELEPORTING in the SAME FRAME cancels the TELEPORT"
		Wait(0.032, Ignore Condition);
		Start Facing(Event Player, Event Player.replayResetPoint[2], 1000, To World, Direction and Turn Rate);
		Wait(0.250, Ignore Condition);
		Stop Facing(Event Player);
		Start Forcing Player Position(Event Player, First Of(Event Player.replayResetPoint), True);
		Set Weapon(Event Player, 0);
		Event Player.replayState = Custom String("PREPARING_FOR_PLAYBACK");
		Skip(1);
		Event Player.replayState = Custom String("NONE");
		"DEBUG"
		Global.logBuffer = Custom String("{0}{1}{2}", Custom String("{0}{1}{2}", Custom String("{0}{1}{2}", Custom String(
			"Exiting Replay State Handler for "), Event Player, Custom String(": [State ")), Event Player.replayState, Custom String(
			"] [Action: ")), Event Player.replayStateAction, Custom String("]"));
		Enable Inspector Recording;
		Log To Inspector(Global.logBuffer);
		If(First Of(Global._extendedGlobalCollection));
			Disable Inspector Recording;
		End;
		Global.logBuffer = Custom String("");
		Event Player.replayStateAction = Custom String("NONE");
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}
